# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: minknow_api/device.proto
"""Generated protocol buffer code."""
from google.protobuf.internal import enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from minknow_api import rpc_options_pb2 as minknow__api_dot_rpc__options__pb2
from google.protobuf import wrappers_pb2 as google_dot_protobuf_dot_wrappers__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x18minknow_api/device.proto\x12\x12minknow_api.device\x1a\x1dminknow_api/rpc_options.proto\x1a\x1egoogle/protobuf/wrappers.proto\":\n\x14\x43hannelConfiguration\x12\x0c\n\x04well\x18\x01 \x01(\r\x12\x14\n\x0ctest_current\x18\x02 \x01(\x08\"S\n\x1cReturnedChannelConfiguration\x12\x0c\n\x04well\x18\x01 \x01(\r\x12\x14\n\x0ctest_current\x18\x02 \x01(\x08\x12\x0f\n\x07unblock\x18\x04 \x01(\x08\"\x16\n\x14GetDeviceInfoRequest\"\xf2\x03\n\x15GetDeviceInfoResponse\x12\x11\n\tdevice_id\x18\x01 \x01(\t\x12I\n\x0b\x64\x65vice_type\x18\x02 \x01(\x0e\x32\x34.minknow_api.device.GetDeviceInfoResponse.DeviceType\x12\x14\n\x0cis_simulated\x18\x03 \x01(\x08\x12\x19\n\x11max_channel_count\x18\x04 \x01(\r\x12\x1d\n\x15max_wells_per_channel\x18\x05 \x01(\r\x12\x1b\n\x13\x63\x61n_set_temperature\x18\x06 \x01(\x08\x12\x14\n\x0c\x64igitisation\x18\x07 \x01(\r\x12T\n\x10\x66irmware_version\x18\n \x03(\x0b\x32:.minknow_api.device.GetDeviceInfoResponse.ComponentVersion\x1aM\n\x10\x43omponentVersion\x12\x11\n\tcomponent\x18\x01 \x01(\t\x12\x0f\n\x07version\x18\x02 \x01(\t\x12\x15\n\rserial_number\x18\x03 \x01(\t\"S\n\nDeviceType\x12\n\n\x06MINION\x10\x00\x12\x0b\n\x07GRIDION\x10\x02\x12\x0e\n\nPROMETHION\x10\x03\x12\x0f\n\x0bMINION_MK1C\x10\x04\x12\x0b\n\x07TRAXION\x10\x05\"\x17\n\x15GetDeviceStateRequest\"\xe8\x01\n\x16GetDeviceStateResponse\x12L\n\x0c\x64\x65vice_state\x18\x01 \x01(\x0e\x32\x36.minknow_api.device.GetDeviceStateResponse.DeviceState\x12\x46\n\x13\x66low_cell_connector\x18\x02 \x01(\x0e\x32).minknow_api.device.FlowCellConnectorType\"8\n\x0b\x44\x65viceState\x12\x17\n\x13\x44\x45VICE_DISCONNECTED\x10\x00\x12\x10\n\x0c\x44\x45VICE_READY\x10\x01\"\x1a\n\x18StreamDeviceStateRequest\"\x18\n\x16GetFlowCellInfoRequest\"\xb5\x03\n\x17GetFlowCellInfoResponse\x12\x15\n\rhas_flow_cell\x18\x01 \x01(\x08\x12\x15\n\rchannel_count\x18\x02 \x01(\r\x12\x19\n\x11wells_per_channel\x18\x03 \x01(\r\x12\x14\n\x0c\x66low_cell_id\x18\x04 \x01(\t\x12\x13\n\x0b\x61sic_id_str\x18\r \x01(\t\x12\x14\n\x0cproduct_code\x18\x06 \x01(\t\x12#\n\x1buser_specified_flow_cell_id\x18\x07 \x01(\t\x12#\n\x1buser_specified_product_code\x18\x08 \x01(\t\x12\x13\n\x0bhas_adapter\x18\t \x01(\x08\x12\x12\n\nadapter_id\x18\n \x01(\t\x12\x1c\n\x12temperature_offset\x18\x0b \x01(\x02H\x00\x12\x14\n\x0c\x61sic_version\x18\x0c \x01(\t\x12J\n\x17insertion_script_status\x18\x0e \x01(\x0e\x32).minknow_api.device.InsertionScriptStatusB\x1d\n\x1btemperature_offset_nullable\"\x1b\n\x19StreamFlowCellInfoRequest\"5\n!SetUserSpecifiedFlowCellIdRequest\x12\x10\n\x02id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\"$\n\"SetUserSpecifiedFlowCellIdResponse\"8\n\"SetUserSpecifiedProductCodeRequest\x12\x12\n\x04\x63ode\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\"%\n#SetUserSpecifiedProductCodeResponse\"\x1a\n\x18GetChannelsLayoutRequest\"W\n\x19GetChannelsLayoutResponse\x12:\n\x0f\x63hannel_records\x18\x01 \x03(\x0b\x32!.minknow_api.device.ChannelRecord\"\xa4\x01\n\rChannelRecord\x12\n\n\x02id\x18\x01 \x01(\r\x12\x0c\n\x04name\x18\x02 \x01(\t\x12@\n\x0bmux_records\x18\x03 \x03(\x0b\x32+.minknow_api.device.ChannelRecord.MuxRecord\x1a\x37\n\tMuxRecord\x12\n\n\x02id\x18\x01 \x01(\r\x12\x0e\n\x06phys_x\x18\x02 \x01(\r\x12\x0e\n\x06phys_y\x18\x03 \x01(\r\"\x1c\n\x1aResetDeviceSettingsRequest\"\x1d\n\x1bResetDeviceSettingsResponse\"\x80\x01\n\x15SetCalibrationRequest\x12\x1b\n\rfirst_channel\x18\x01 \x01(\rB\x04\x88\xb5\x18\x01\x12\x1a\n\x0clast_channel\x18\x02 \x01(\rB\x04\x88\xb5\x18\x01\x12\x15\n\x07offsets\x18\x03 \x03(\x02\x42\x04\x88\xb5\x18\x01\x12\x17\n\tpa_ranges\x18\x04 \x03(\x02\x42\x04\x88\xb5\x18\x01\"\x18\n\x16SetCalibrationResponse\"\x19\n\x17\x43learCalibrationRequest\"\x1a\n\x18\x43learCalibrationResponse\"P\n\x15GetCalibrationRequest\x12\x1b\n\rfirst_channel\x18\x01 \x01(\rB\x04\x88\xb5\x18\x01\x12\x1a\n\x0clast_channel\x18\x02 \x01(\rB\x04\x88\xb5\x18\x01\"k\n\x16GetCalibrationResponse\x12\x14\n\x0c\x64igitisation\x18\x01 \x01(\r\x12\x0f\n\x07offsets\x18\x02 \x03(\x02\x12\x11\n\tpa_ranges\x18\x03 \x03(\x02\x12\x17\n\x0fhas_calibration\x18\x04 \x01(\x08\"\xef\x01\n\x15SetTemperatureRequest\x12\x13\n\x0btemperature\x18\x01 \x01(\x02\x12\x62\n\x14wait_for_temperature\x18\x02 \x01(\x0b\x32\x44.minknow_api.device.SetTemperatureRequest.WaitForTemperatureSettings\x1a]\n\x1aWaitForTemperatureSettings\x12\x0f\n\x07timeout\x18\x01 \x01(\r\x12\x1b\n\x13min_stable_duration\x18\x03 \x01(\r\x12\x11\n\ttolerance\x18\x02 \x01(\x02\"C\n\x16SetTemperatureResponse\x12)\n!timed_out_waiting_for_temperature\x18\x01 \x01(\x08\"\x17\n\x15GetTemperatureRequest\"\x9f\x04\n\x16GetTemperatureResponse\x12N\n\x06minion\x18\x01 \x01(\x0b\x32<.minknow_api.device.GetTemperatureResponse.MinIONTemperatureH\x00\x12V\n\npromethion\x18\x02 \x01(\x0b\x32@.minknow_api.device.GetTemperatureResponse.PromethIONTemperatureH\x00\x12\x37\n\x12target_temperature\x18\x03 \x01(\x0b\x32\x1b.google.protobuf.FloatValue\x1a\x85\x01\n\x11MinIONTemperature\x12\x35\n\x10\x61sic_temperature\x18\x01 \x01(\x0b\x32\x1b.google.protobuf.FloatValue\x12\x39\n\x14heatsink_temperature\x18\x02 \x01(\x0b\x32\x1b.google.protobuf.FloatValue\x1a\x8c\x01\n\x15PromethIONTemperature\x12\x39\n\x14\x66lowcell_temperature\x18\x01 \x01(\x0b\x32\x1b.google.protobuf.FloatValue\x12\x38\n\x13\x63hamber_temperature\x18\x02 \x01(\x0b\x32\x1b.google.protobuf.FloatValueB\r\n\x0btemperature\"2\n\x18StreamTemperatureRequest\x12\x16\n\x0eperiod_seconds\x18\x01 \x01(\r\"q\n\x0eUnblockRequest\x12\x10\n\x08\x63hannels\x18\x01 \x03(\r\x12\x1d\n\x13\x64uration_in_seconds\x18\x02 \x01(\rH\x00\x12\"\n\x18\x64uration_in_milliseconds\x18\x03 \x01(\rH\x00\x42\n\n\x08\x64uration\"\x11\n\x0fUnblockResponse\"\x17\n\x15\x43\x61ncelUnblocksRequest\"4\n\x16\x43\x61ncelUnblocksResponse\x12\x1a\n\x12\x63\x61ncelled_unblocks\x18\x01 \x01(\r\"2\n\x1eGetChannelConfigurationRequest\x12\x10\n\x08\x63hannels\x18\x01 \x03(\r\"s\n\x1fGetChannelConfigurationResponse\x12P\n\x16\x63hannel_configurations\x18\x01 \x03(\x0b\x32\x30.minknow_api.device.ReturnedChannelConfiguration\"\xf7\x01\n\x1eSetChannelConfigurationRequest\x12m\n\x16\x63hannel_configurations\x18\x01 \x03(\x0b\x32M.minknow_api.device.SetChannelConfigurationRequest.ChannelConfigurationsEntry\x1a\x66\n\x1a\x43hannelConfigurationsEntry\x12\x0b\n\x03key\x18\x01 \x01(\r\x12\x37\n\x05value\x18\x02 \x01(\x0b\x32(.minknow_api.device.ChannelConfiguration:\x02\x38\x01\"!\n\x1fSetChannelConfigurationResponse\"r\n!SetChannelConfigurationAllRequest\x12M\n\x15\x63hannel_configuration\x18\x01 \x01(\x0b\x32(.minknow_api.device.ChannelConfigurationB\x04\x90\xb5\x18\x01\"$\n\"SetChannelConfigurationAllResponse\"\xc6\x06\n\x10SaturationConfig\x12\x43\n\nthresholds\x18\x01 \x01(\x0b\x32/.minknow_api.device.SaturationConfig.Thresholds\x12T\n\x13software_saturation\x18\x02 \x01(\x0b\x32\x37.minknow_api.device.SaturationConfig.SoftwareSaturation\x12_\n\x19user_threshold_saturation\x18\x03 \x01(\x0b\x32<.minknow_api.device.SaturationConfig.UserThresholdSaturation\x1a\xfa\x01\n\nThresholds\x12\x37\n\x11general_threshold\x18\x01 \x01(\x0b\x32\x1c.google.protobuf.UInt32Value\x12\x37\n\x11unblock_threshold\x18\x02 \x01(\x0b\x32\x1c.google.protobuf.UInt32Value\x12<\n\x16user_general_threshold\x18\x03 \x01(\x0b\x32\x1c.google.protobuf.UInt32Value\x12<\n\x16user_unblock_threshold\x18\x04 \x01(\x0b\x32\x1c.google.protobuf.UInt32Value\x1a\x93\x01\n\x12SoftwareSaturation\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12\x35\n\x10software_min_adc\x18\x02 \x01(\x0b\x32\x1b.google.protobuf.Int32Value\x12\x35\n\x10software_max_adc\x18\x03 \x01(\x0b\x32\x1b.google.protobuf.Int32Value\x1a\xa2\x01\n\x17UserThresholdSaturation\x12\x0f\n\x07\x65nabled\x18\x01 \x01(\x08\x12:\n\x15user_threshold_min_pa\x18\x02 \x01(\x0b\x32\x1b.google.protobuf.FloatValue\x12:\n\x15user_threshold_max_pa\x18\x03 \x01(\x0b\x32\x1b.google.protobuf.FloatValue\"Z\n\x1aSetSaturationConfigRequest\x12<\n\x08settings\x18\x01 \x01(\x0b\x32$.minknow_api.device.SaturationConfigB\x04\x90\xb5\x18\x01\"\x1d\n\x1bSetSaturationConfigResponse\"\x1c\n\x1aGetSaturationConfigRequest\"[\n\x1bGetSaturationConfigResponse\x12<\n\x08settings\x18\x01 \x01(\x0b\x32$.minknow_api.device.SaturationConfigB\x04\x90\xb5\x18\x01\"\x16\n\x14GetSampleRateRequest\",\n\x15GetSampleRateResponse\x12\x13\n\x0bsample_rate\x18\x01 \x01(\r\"1\n\x14SetSampleRateRequest\x12\x19\n\x0bsample_rate\x18\x01 \x01(\rB\x04\x88\xb5\x18\x01\"1\n\x15SetSampleRateResponse\x12\x18\n\x10real_sample_rate\x18\x01 \x01(\r\"\x17\n\x15GetBiasVoltageRequest\".\n\x16GetBiasVoltageResponse\x12\x14\n\x0c\x62ias_voltage\x18\x01 \x01(\x01\"3\n\x15SetBiasVoltageRequest\x12\x1a\n\x0c\x62ias_voltage\x18\x01 \x01(\x01\x42\x04\x88\xb5\x18\x01\"\x18\n\x16SetBiasVoltageResponse\"\x12\n\x10\x44umpStateRequest\"\x13\n\x11\x44umpStateResponse*i\n\x15\x46lowCellConnectorType\x12\x11\n\rFCCON_NOT_SET\x10\x00\x12\x14\n\x10\x46\x43\x43ON_PROMETHION\x10\x01\x12\x14\n\x10\x46\x43\x43ON_MINION_MK1\x10\x02\x12\x11\n\rFCCON_FLONGLE\x10\x03*?\n\x15InsertionScriptStatus\x12\x0b\n\x07NOT_RUN\x10\x00\x12\n\n\x06\x46\x41ILED\x10\x01\x12\r\n\tSUCCEEDED\x10\x02*]\n\x0cSelectedWell\x12\r\n\tWELL_NONE\x10\x00\x12\n\n\x06WELL_1\x10\x01\x12\n\n\x06WELL_2\x10\x02\x12\n\n\x06WELL_3\x10\x03\x12\n\n\x06WELL_4\x10\x04\x12\x0e\n\nWELL_OTHER\x10\x05\x32\xa8\x19\n\rDeviceService\x12k\n\x0fget_device_info\x12(.minknow_api.device.GetDeviceInfoRequest\x1a).minknow_api.device.GetDeviceInfoResponse\"\x03\x90\x02\x01\x12n\n\x10get_device_state\x12).minknow_api.device.GetDeviceStateRequest\x1a*.minknow_api.device.GetDeviceStateResponse\"\x03\x90\x02\x01\x12v\n\x13stream_device_state\x12,.minknow_api.device.StreamDeviceStateRequest\x1a*.minknow_api.device.GetDeviceStateResponse\"\x03\x90\x02\x01\x30\x01\x12r\n\x12get_flow_cell_info\x12*.minknow_api.device.GetFlowCellInfoRequest\x1a+.minknow_api.device.GetFlowCellInfoResponse\"\x03\x90\x02\x01\x12z\n\x15stream_flow_cell_info\x12-.minknow_api.device.StreamFlowCellInfoRequest\x1a+.minknow_api.device.GetFlowCellInfoResponse\"\x03\x90\x02\x01\x30\x01\x12\x95\x01\n\x1fset_user_specified_flow_cell_id\x12\x35.minknow_api.device.SetUserSpecifiedFlowCellIdRequest\x1a\x36.minknow_api.device.SetUserSpecifiedFlowCellIdResponse\"\x03\x90\x02\x02\x12\x97\x01\n\x1fset_user_specified_product_code\x12\x36.minknow_api.device.SetUserSpecifiedProductCodeRequest\x1a\x37.minknow_api.device.SetUserSpecifiedProductCodeResponse\"\x03\x90\x02\x02\x12w\n\x13get_channels_layout\x12,.minknow_api.device.GetChannelsLayoutRequest\x1a-.minknow_api.device.GetChannelsLayoutResponse\"\x03\x90\x02\x01\x12}\n\x15reset_device_settings\x12..minknow_api.device.ResetDeviceSettingsRequest\x1a/.minknow_api.device.ResetDeviceSettingsResponse\"\x03\x90\x02\x02\x12m\n\x0fset_calibration\x12).minknow_api.device.SetCalibrationRequest\x1a*.minknow_api.device.SetCalibrationResponse\"\x03\x90\x02\x02\x12s\n\x11\x63lear_calibration\x12+.minknow_api.device.ClearCalibrationRequest\x1a,.minknow_api.device.ClearCalibrationResponse\"\x03\x90\x02\x02\x12m\n\x0fget_calibration\x12).minknow_api.device.GetCalibrationRequest\x1a*.minknow_api.device.GetCalibrationResponse\"\x03\x90\x02\x01\x12m\n\x0fset_temperature\x12).minknow_api.device.SetTemperatureRequest\x1a*.minknow_api.device.SetTemperatureResponse\"\x03\x90\x02\x02\x12m\n\x0fget_temperature\x12).minknow_api.device.GetTemperatureRequest\x1a*.minknow_api.device.GetTemperatureResponse\"\x03\x90\x02\x01\x12u\n\x12stream_temperature\x12,.minknow_api.device.StreamTemperatureRequest\x1a*.minknow_api.device.GetTemperatureResponse\"\x03\x90\x02\x01\x30\x01\x12T\n\x07unblock\x12\".minknow_api.device.UnblockRequest\x1a#.minknow_api.device.UnblockResponse\"\x00\x12j\n\x0f\x63\x61ncel_unblocks\x12).minknow_api.device.CancelUnblocksRequest\x1a*.minknow_api.device.CancelUnblocksResponse\"\x00\x12\x89\x01\n\x19get_channel_configuration\x12\x32.minknow_api.device.GetChannelConfigurationRequest\x1a\x33.minknow_api.device.GetChannelConfigurationResponse\"\x03\x90\x02\x01\x12\x89\x01\n\x19set_channel_configuration\x12\x32.minknow_api.device.SetChannelConfigurationRequest\x1a\x33.minknow_api.device.SetChannelConfigurationResponse\"\x03\x90\x02\x02\x12\x93\x01\n\x1dset_channel_configuration_all\x12\x35.minknow_api.device.SetChannelConfigurationAllRequest\x1a\x36.minknow_api.device.SetChannelConfigurationAllResponse\"\x03\x90\x02\x02\x12z\n\x15set_saturation_config\x12..minknow_api.device.SetSaturationConfigRequest\x1a/.minknow_api.device.SetSaturationConfigResponse\"\x00\x12}\n\x15get_saturation_config\x12..minknow_api.device.GetSaturationConfigRequest\x1a/.minknow_api.device.GetSaturationConfigResponse\"\x03\x90\x02\x01\x12k\n\x0fget_sample_rate\x12(.minknow_api.device.GetSampleRateRequest\x1a).minknow_api.device.GetSampleRateResponse\"\x03\x90\x02\x01\x12k\n\x0fset_sample_rate\x12(.minknow_api.device.SetSampleRateRequest\x1a).minknow_api.device.SetSampleRateResponse\"\x03\x90\x02\x02\x12n\n\x10get_bias_voltage\x12).minknow_api.device.GetBiasVoltageRequest\x1a*.minknow_api.device.GetBiasVoltageResponse\"\x03\x90\x02\x01\x12n\n\x10set_bias_voltage\x12).minknow_api.device.SetBiasVoltageRequest\x1a*.minknow_api.device.SetBiasVoltageResponse\"\x03\x90\x02\x02\x12[\n\ndump_state\x12$.minknow_api.device.DumpStateRequest\x1a%.minknow_api.device.DumpStateResponse\"\x00\x42&\n\x1c\x63om.nanoporetech.minknow_api\xa2\x02\x05MKAPIb\x06proto3')

_FLOWCELLCONNECTORTYPE = DESCRIPTOR.enum_types_by_name['FlowCellConnectorType']
FlowCellConnectorType = enum_type_wrapper.EnumTypeWrapper(_FLOWCELLCONNECTORTYPE)
_INSERTIONSCRIPTSTATUS = DESCRIPTOR.enum_types_by_name['InsertionScriptStatus']
InsertionScriptStatus = enum_type_wrapper.EnumTypeWrapper(_INSERTIONSCRIPTSTATUS)
_SELECTEDWELL = DESCRIPTOR.enum_types_by_name['SelectedWell']
SelectedWell = enum_type_wrapper.EnumTypeWrapper(_SELECTEDWELL)
FCCON_NOT_SET = 0
FCCON_PROMETHION = 1
FCCON_MINION_MK1 = 2
FCCON_FLONGLE = 3
NOT_RUN = 0
FAILED = 1
SUCCEEDED = 2
WELL_NONE = 0
WELL_1 = 1
WELL_2 = 2
WELL_3 = 3
WELL_4 = 4
WELL_OTHER = 5


_CHANNELCONFIGURATION = DESCRIPTOR.message_types_by_name['ChannelConfiguration']
_RETURNEDCHANNELCONFIGURATION = DESCRIPTOR.message_types_by_name['ReturnedChannelConfiguration']
_GETDEVICEINFOREQUEST = DESCRIPTOR.message_types_by_name['GetDeviceInfoRequest']
_GETDEVICEINFORESPONSE = DESCRIPTOR.message_types_by_name['GetDeviceInfoResponse']
_GETDEVICEINFORESPONSE_COMPONENTVERSION = _GETDEVICEINFORESPONSE.nested_types_by_name['ComponentVersion']
_GETDEVICESTATEREQUEST = DESCRIPTOR.message_types_by_name['GetDeviceStateRequest']
_GETDEVICESTATERESPONSE = DESCRIPTOR.message_types_by_name['GetDeviceStateResponse']
_STREAMDEVICESTATEREQUEST = DESCRIPTOR.message_types_by_name['StreamDeviceStateRequest']
_GETFLOWCELLINFOREQUEST = DESCRIPTOR.message_types_by_name['GetFlowCellInfoRequest']
_GETFLOWCELLINFORESPONSE = DESCRIPTOR.message_types_by_name['GetFlowCellInfoResponse']
_STREAMFLOWCELLINFOREQUEST = DESCRIPTOR.message_types_by_name['StreamFlowCellInfoRequest']
_SETUSERSPECIFIEDFLOWCELLIDREQUEST = DESCRIPTOR.message_types_by_name['SetUserSpecifiedFlowCellIdRequest']
_SETUSERSPECIFIEDFLOWCELLIDRESPONSE = DESCRIPTOR.message_types_by_name['SetUserSpecifiedFlowCellIdResponse']
_SETUSERSPECIFIEDPRODUCTCODEREQUEST = DESCRIPTOR.message_types_by_name['SetUserSpecifiedProductCodeRequest']
_SETUSERSPECIFIEDPRODUCTCODERESPONSE = DESCRIPTOR.message_types_by_name['SetUserSpecifiedProductCodeResponse']
_GETCHANNELSLAYOUTREQUEST = DESCRIPTOR.message_types_by_name['GetChannelsLayoutRequest']
_GETCHANNELSLAYOUTRESPONSE = DESCRIPTOR.message_types_by_name['GetChannelsLayoutResponse']
_CHANNELRECORD = DESCRIPTOR.message_types_by_name['ChannelRecord']
_CHANNELRECORD_MUXRECORD = _CHANNELRECORD.nested_types_by_name['MuxRecord']
_RESETDEVICESETTINGSREQUEST = DESCRIPTOR.message_types_by_name['ResetDeviceSettingsRequest']
_RESETDEVICESETTINGSRESPONSE = DESCRIPTOR.message_types_by_name['ResetDeviceSettingsResponse']
_SETCALIBRATIONREQUEST = DESCRIPTOR.message_types_by_name['SetCalibrationRequest']
_SETCALIBRATIONRESPONSE = DESCRIPTOR.message_types_by_name['SetCalibrationResponse']
_CLEARCALIBRATIONREQUEST = DESCRIPTOR.message_types_by_name['ClearCalibrationRequest']
_CLEARCALIBRATIONRESPONSE = DESCRIPTOR.message_types_by_name['ClearCalibrationResponse']
_GETCALIBRATIONREQUEST = DESCRIPTOR.message_types_by_name['GetCalibrationRequest']
_GETCALIBRATIONRESPONSE = DESCRIPTOR.message_types_by_name['GetCalibrationResponse']
_SETTEMPERATUREREQUEST = DESCRIPTOR.message_types_by_name['SetTemperatureRequest']
_SETTEMPERATUREREQUEST_WAITFORTEMPERATURESETTINGS = _SETTEMPERATUREREQUEST.nested_types_by_name['WaitForTemperatureSettings']
_SETTEMPERATURERESPONSE = DESCRIPTOR.message_types_by_name['SetTemperatureResponse']
_GETTEMPERATUREREQUEST = DESCRIPTOR.message_types_by_name['GetTemperatureRequest']
_GETTEMPERATURERESPONSE = DESCRIPTOR.message_types_by_name['GetTemperatureResponse']
_GETTEMPERATURERESPONSE_MINIONTEMPERATURE = _GETTEMPERATURERESPONSE.nested_types_by_name['MinIONTemperature']
_GETTEMPERATURERESPONSE_PROMETHIONTEMPERATURE = _GETTEMPERATURERESPONSE.nested_types_by_name['PromethIONTemperature']
_STREAMTEMPERATUREREQUEST = DESCRIPTOR.message_types_by_name['StreamTemperatureRequest']
_UNBLOCKREQUEST = DESCRIPTOR.message_types_by_name['UnblockRequest']
_UNBLOCKRESPONSE = DESCRIPTOR.message_types_by_name['UnblockResponse']
_CANCELUNBLOCKSREQUEST = DESCRIPTOR.message_types_by_name['CancelUnblocksRequest']
_CANCELUNBLOCKSRESPONSE = DESCRIPTOR.message_types_by_name['CancelUnblocksResponse']
_GETCHANNELCONFIGURATIONREQUEST = DESCRIPTOR.message_types_by_name['GetChannelConfigurationRequest']
_GETCHANNELCONFIGURATIONRESPONSE = DESCRIPTOR.message_types_by_name['GetChannelConfigurationResponse']
_SETCHANNELCONFIGURATIONREQUEST = DESCRIPTOR.message_types_by_name['SetChannelConfigurationRequest']
_SETCHANNELCONFIGURATIONREQUEST_CHANNELCONFIGURATIONSENTRY = _SETCHANNELCONFIGURATIONREQUEST.nested_types_by_name['ChannelConfigurationsEntry']
_SETCHANNELCONFIGURATIONRESPONSE = DESCRIPTOR.message_types_by_name['SetChannelConfigurationResponse']
_SETCHANNELCONFIGURATIONALLREQUEST = DESCRIPTOR.message_types_by_name['SetChannelConfigurationAllRequest']
_SETCHANNELCONFIGURATIONALLRESPONSE = DESCRIPTOR.message_types_by_name['SetChannelConfigurationAllResponse']
_SATURATIONCONFIG = DESCRIPTOR.message_types_by_name['SaturationConfig']
_SATURATIONCONFIG_THRESHOLDS = _SATURATIONCONFIG.nested_types_by_name['Thresholds']
_SATURATIONCONFIG_SOFTWARESATURATION = _SATURATIONCONFIG.nested_types_by_name['SoftwareSaturation']
_SATURATIONCONFIG_USERTHRESHOLDSATURATION = _SATURATIONCONFIG.nested_types_by_name['UserThresholdSaturation']
_SETSATURATIONCONFIGREQUEST = DESCRIPTOR.message_types_by_name['SetSaturationConfigRequest']
_SETSATURATIONCONFIGRESPONSE = DESCRIPTOR.message_types_by_name['SetSaturationConfigResponse']
_GETSATURATIONCONFIGREQUEST = DESCRIPTOR.message_types_by_name['GetSaturationConfigRequest']
_GETSATURATIONCONFIGRESPONSE = DESCRIPTOR.message_types_by_name['GetSaturationConfigResponse']
_GETSAMPLERATEREQUEST = DESCRIPTOR.message_types_by_name['GetSampleRateRequest']
_GETSAMPLERATERESPONSE = DESCRIPTOR.message_types_by_name['GetSampleRateResponse']
_SETSAMPLERATEREQUEST = DESCRIPTOR.message_types_by_name['SetSampleRateRequest']
_SETSAMPLERATERESPONSE = DESCRIPTOR.message_types_by_name['SetSampleRateResponse']
_GETBIASVOLTAGEREQUEST = DESCRIPTOR.message_types_by_name['GetBiasVoltageRequest']
_GETBIASVOLTAGERESPONSE = DESCRIPTOR.message_types_by_name['GetBiasVoltageResponse']
_SETBIASVOLTAGEREQUEST = DESCRIPTOR.message_types_by_name['SetBiasVoltageRequest']
_SETBIASVOLTAGERESPONSE = DESCRIPTOR.message_types_by_name['SetBiasVoltageResponse']
_DUMPSTATEREQUEST = DESCRIPTOR.message_types_by_name['DumpStateRequest']
_DUMPSTATERESPONSE = DESCRIPTOR.message_types_by_name['DumpStateResponse']
_GETDEVICEINFORESPONSE_DEVICETYPE = _GETDEVICEINFORESPONSE.enum_types_by_name['DeviceType']
_GETDEVICESTATERESPONSE_DEVICESTATE = _GETDEVICESTATERESPONSE.enum_types_by_name['DeviceState']
ChannelConfiguration = _reflection.GeneratedProtocolMessageType('ChannelConfiguration', (_message.Message,), {
  'DESCRIPTOR' : _CHANNELCONFIGURATION,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Describes the configuration of a channel on the device.  Note that
  this is a lossy representation. The device-specific APIs provide more
  precise information. This only describes common configurations, and
  omits anything that doesn't impact the received signal.
  
  Attributes:
      well:
          The currently-connected well.  Wells are counted from 1. 0
          indicates that no well is connected. 5 indicates some non-
          generic configuration such as ground for a minion or
          connecting all wells on promethion  Note that MinKNOW can
          return channel configurations where the well number is larger
          than the ``max_well_count`` value returned by
          :meth:`DeviceService.get_device_info`. This indicates that
          some other connection has been made (for example, PromethIONs
          can simultaneously connect all wells, and MinIONs can connect
          to ground).
      test_current:
          Whether the test current is connected to the integrator
          (measurement circuit).  The signal will be a steady test
          current produced on the device. This can be used for
          calibration or to test the device integration circuits.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.ChannelConfiguration)
  })
_sym_db.RegisterMessage(ChannelConfiguration)

ReturnedChannelConfiguration = _reflection.GeneratedProtocolMessageType('ReturnedChannelConfiguration', (_message.Message,), {
  'DESCRIPTOR' : _RETURNEDCHANNELCONFIGURATION,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Describes the configuration of a channel on the device.  Note that
  this is a lossy representation. The device-specific APIs provide more
  precise information. This only describes common configurations, and
  omits anything that doesn't impact the received signal.
  
  Attributes:
      well:
          The currently-connected well.  Wells are counted from 1. 0
          indicates that no well is connected. 5 indicates some non-
          generic configuration such as ground for a minion or
          connecting all wells on promethion  Note that MinKNOW can
          return channel configurations where the well number is larger
          than the ``max_well_count`` value returned by
          :meth:`DeviceService.get_device_info`. This indicates that
          some other connection has been made (for example, PromethIONs
          can simultaneously connect all wells, and MinIONs can connect
          to ground).
      test_current:
          Whether the test current is connected to the integrator
          (measurement circuit).  The signal will be a steady test
          current produced on the device. This can be used for
          calibration or to test the device integration circuits.
      unblock:
          Whether the unblock voltage is connected to the integrator
          (measurement circuit).  Provides a reverse potential across
          the connected well. This can be used to drive molecules back
          out of the well.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.ReturnedChannelConfiguration)
  })
_sym_db.RegisterMessage(ReturnedChannelConfiguration)

GetDeviceInfoRequest = _reflection.GeneratedProtocolMessageType('GetDeviceInfoRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETDEVICEINFOREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetDeviceInfoRequest)
  })
_sym_db.RegisterMessage(GetDeviceInfoRequest)

GetDeviceInfoResponse = _reflection.GeneratedProtocolMessageType('GetDeviceInfoResponse', (_message.Message,), {

  'ComponentVersion' : _reflection.GeneratedProtocolMessageType('ComponentVersion', (_message.Message,), {
    'DESCRIPTOR' : _GETDEVICEINFORESPONSE_COMPONENTVERSION,
    '__module__' : 'minknow_api.device_pb2'
    ,
    '__doc__': """Firmware versions and serial-numbers of components associated with
    this device  Depending on the hardware, there may be several
    components associated with this device, each with their own firmware
    version and serial-number. Not all components have serial-numbers.
    
    Attributes:
        component:
            Description of the component that has firmware
        version:
            The firmware version, if this cannot be determined for a
            component where the firmware version would usually be
            available, this will contain "Unknown"
        serial_number:
            The serial-number of a component. If this in not applicable to
            the type of component or cannot be read at the current time,
            then this field will be blank.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.device.GetDeviceInfoResponse.ComponentVersion)
    })
  ,
  'DESCRIPTOR' : _GETDEVICEINFORESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      device_id:
          A unique identifier for the device.  This is the identifier of
          the device MinKNOW was started for. It will only communicate
          with this device.  Note that simulated device IDs are only
          unique for this host, not globally.  This value will be set
          even if the device is not currently connected (assuming
          MinKNOW was started by the manager service).
      device_type:
          The type of the device.
      is_simulated:
          Whether the device is simulated.  If this is true, there is no
          physical device - MinKNOW is simulating it. If it is false,
          MinKNOW will be acquiring data from a real device.
      max_channel_count:
          The maximum number of channels supported by the device.  Each
          channel provides a signal from the device. For example, a
          MinION supports up to 512 channels, and so can provide 512
          simultaneous streams of data.  This value is fixed for a given
          device type. Note, however, that a flow cell might be attached
          that has a smaller number of channels.
      max_wells_per_channel:
          The maximum number of wells connected to each channel.  A well
          is a discrete location on the device where sensing can take
          place. Normally, each well should have a single nanopore in
          it.  For example, a MinION supports up to 4 wells per channel,
          allowing for 2048 wells in total. So the value of this for a
          MinION will be 4.  This value is fixed for a given device
          type. Note, however, that a flow cell might be attached that
          has a smaller number of wells on each channel.
      can_set_temperature:
          Whether the set_temperature() method can be expected to work.
          On some systems, not all connected devices have the ability to
          control their own temperature, as temperature controls are
          managed in groups. If this field is true, this device can
          control its own temperature. If it it false, it cannot, and
          the temperature will be maintained at a pre-determined
          temperature.
      digitisation:
          The range of uncalibrated data values.  This is the number of
          distinct signal values that can be produced by the device's
          analog to digital converter (ADC).
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetDeviceInfoResponse)
  })
_sym_db.RegisterMessage(GetDeviceInfoResponse)
_sym_db.RegisterMessage(GetDeviceInfoResponse.ComponentVersion)

GetDeviceStateRequest = _reflection.GeneratedProtocolMessageType('GetDeviceStateRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETDEVICESTATEREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetDeviceStateRequest)
  })
_sym_db.RegisterMessage(GetDeviceStateRequest)

GetDeviceStateResponse = _reflection.GeneratedProtocolMessageType('GetDeviceStateResponse', (_message.Message,), {
  'DESCRIPTOR' : _GETDEVICESTATERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      device_state:
          Whether the physical hardware is present.  This is really only
          relevant to MinIONs, which could be unplugged by the user at
          any time.
      flow_cell_connector:
          Indicates what sort of flow cell can be inserted.  For
          example, if the user needs to set or override the flow cell
          product code, this can be used to limit the list of possible
          flow cell product codes to choose from.  Since 4.1
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetDeviceStateResponse)
  })
_sym_db.RegisterMessage(GetDeviceStateResponse)

StreamDeviceStateRequest = _reflection.GeneratedProtocolMessageType('StreamDeviceStateRequest', (_message.Message,), {
  'DESCRIPTOR' : _STREAMDEVICESTATEREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.StreamDeviceStateRequest)
  })
_sym_db.RegisterMessage(StreamDeviceStateRequest)

GetFlowCellInfoRequest = _reflection.GeneratedProtocolMessageType('GetFlowCellInfoRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETFLOWCELLINFOREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetFlowCellInfoRequest)
  })
_sym_db.RegisterMessage(GetFlowCellInfoRequest)

GetFlowCellInfoResponse = _reflection.GeneratedProtocolMessageType('GetFlowCellInfoResponse', (_message.Message,), {
  'DESCRIPTOR' : _GETFLOWCELLINFORESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      has_flow_cell:
          Whether there is a flow cell present.  If both this and
          has_adapter are false, none of the other fields will contain
          useful information.
      channel_count:
          The number of channels currently supported by the device.
          This may be smaller than the ``max_channel_count`` value
          returned by get_device_info(), depending on the attached flow
          cell.
      wells_per_channel:
          The number of wells currently supported by the device.  This
          may be smaller than the ``max_wells_per_channel`` value
          returned by get_device_info(), depending on the attached flow
          cell.
      flow_cell_id:
          The unique identifier for the flow cell.  This should be same
          as the value printed onto the flow cell casing. Not all flow
          cells will have the flow cell ID recorded in a way that
          MinKNOW can read. In those cases, this will be an empty
          string, even though the user may be able to see a printed
          identifier on the flow cell.
      asic_id_str:
          The unique identifier for the ASIC (formatted as string).
          This is a value uniquely identifying the ASIC embedded in the
          flow cell. It will always be set when a flow cell is present.
          The intended use for this is to track the identity of the asic
          in the flow cell, eg. for displaying to users during
          production of chips.  Caveats:  * This value will not mean
          anything to a customer. * There is no guarantee that this
          field will contain the same identifier across   MinKNOW
          versions, even with the same flow cell. * An ASIC can be
          recycled into a new flow cell, so this identifier may be re-
          used in the   future (although it can be considered unique for
          the duration of a protocol run).
      product_code:
          The product code for the flow cell.  This should be the code
          displayed in the shop where the flow cell was bought. Not all
          flow cells will have the product code recorded in a way that
          MinKNOW can read. In those cases, this will be an empty
          string.
      user_specified_flow_cell_id:
          A unique identifier for the flow cell, which the user can
          specify.  In the event a flow cell does not have an eeprom,
          this field contains data input by the user using
          set_flow_cell_info to record required data.  Only alpha-
          numeric, space, dash and underscore characters are allowed in
          this field.  Since 1.12
      user_specified_product_code:
          A product code for the flow cell, which the user can specify.
          This should be the code displayed in the shop where the flow
          cell was bought. Not all flow cells have an eeprom, in the
          event they don't, the user can specify using this id using
          set_flow_cell_info.  Since 1.12
      has_adapter:
          Whether there is a flongle adapter.  If this is true, the
          adapter_id, channel_count and wells_per_channel fields should
          all provide useful information, even if has_flow_cell is
          false.
      adapter_id:
          The unique identifier of an attached flongle adapter.  This
          should be same as the value printed onto the adapter casing.
      temperature_offset_nullable:
          Used to make the field nullable, since the null value is not
          protobuf's default.
      temperature_offset:
          The temperature offset for the flow cell, returned as an
          offset in degrees Celsius.  This offset specifies a correction
          to be applied to ASIC temperature. If multiple ASIC
          temperatures are available from the device, applies to the
          mean temperature.  Since 1.14
      asic_version:
          The version of the ASIC contained in the flow cell (if
          specified by the hardware).  This can be used to determine if
          the hardware should support certain features added to only
          newer ASICs.  Possible values include: "IA02C", "IA02D", or if
          the value is not readable on the current hardware an empty
          string is returned.  Since 1.14
      insertion_script_status:
          If the configuration specifies a script to run when a flow-
          cell is inserted, this shows if it completed successfully.
          Since 5.0
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetFlowCellInfoResponse)
  })
_sym_db.RegisterMessage(GetFlowCellInfoResponse)

StreamFlowCellInfoRequest = _reflection.GeneratedProtocolMessageType('StreamFlowCellInfoRequest', (_message.Message,), {
  'DESCRIPTOR' : _STREAMFLOWCELLINFOREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.StreamFlowCellInfoRequest)
  })
_sym_db.RegisterMessage(StreamFlowCellInfoRequest)

SetUserSpecifiedFlowCellIdRequest = _reflection.GeneratedProtocolMessageType('SetUserSpecifiedFlowCellIdRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETUSERSPECIFIEDFLOWCELLIDREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      id:
          A unique identifier for the flow cell, which the user can
          specify.  In the event a flow cell does not have an eeprom,
          this field can be used by the user to record their
          flow_cell_id.  Since 1.12
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetUserSpecifiedFlowCellIdRequest)
  })
_sym_db.RegisterMessage(SetUserSpecifiedFlowCellIdRequest)

SetUserSpecifiedFlowCellIdResponse = _reflection.GeneratedProtocolMessageType('SetUserSpecifiedFlowCellIdResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETUSERSPECIFIEDFLOWCELLIDRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetUserSpecifiedFlowCellIdResponse)
  })
_sym_db.RegisterMessage(SetUserSpecifiedFlowCellIdResponse)

SetUserSpecifiedProductCodeRequest = _reflection.GeneratedProtocolMessageType('SetUserSpecifiedProductCodeRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETUSERSPECIFIEDPRODUCTCODEREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      code:
          A product code for the flow cell, which the user can specify.
          In the event a flow cell does not have an eeprom, the user can
          specify product code here.  Since 1.12
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetUserSpecifiedProductCodeRequest)
  })
_sym_db.RegisterMessage(SetUserSpecifiedProductCodeRequest)

SetUserSpecifiedProductCodeResponse = _reflection.GeneratedProtocolMessageType('SetUserSpecifiedProductCodeResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETUSERSPECIFIEDPRODUCTCODERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetUserSpecifiedProductCodeResponse)
  })
_sym_db.RegisterMessage(SetUserSpecifiedProductCodeResponse)

GetChannelsLayoutRequest = _reflection.GeneratedProtocolMessageType('GetChannelsLayoutRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETCHANNELSLAYOUTREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetChannelsLayoutRequest)
  })
_sym_db.RegisterMessage(GetChannelsLayoutRequest)

GetChannelsLayoutResponse = _reflection.GeneratedProtocolMessageType('GetChannelsLayoutResponse', (_message.Message,), {
  'DESCRIPTOR' : _GETCHANNELSLAYOUTRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetChannelsLayoutResponse)
  })
_sym_db.RegisterMessage(GetChannelsLayoutResponse)

ChannelRecord = _reflection.GeneratedProtocolMessageType('ChannelRecord', (_message.Message,), {

  'MuxRecord' : _reflection.GeneratedProtocolMessageType('MuxRecord', (_message.Message,), {
    'DESCRIPTOR' : _CHANNELRECORD_MUXRECORD,
    '__module__' : 'minknow_api.device_pb2'
    # @@protoc_insertion_point(class_scope:minknow_api.device.ChannelRecord.MuxRecord)
    })
  ,
  'DESCRIPTOR' : _CHANNELRECORD,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.ChannelRecord)
  })
_sym_db.RegisterMessage(ChannelRecord)
_sym_db.RegisterMessage(ChannelRecord.MuxRecord)

ResetDeviceSettingsRequest = _reflection.GeneratedProtocolMessageType('ResetDeviceSettingsRequest', (_message.Message,), {
  'DESCRIPTOR' : _RESETDEVICESETTINGSREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.ResetDeviceSettingsRequest)
  })
_sym_db.RegisterMessage(ResetDeviceSettingsRequest)

ResetDeviceSettingsResponse = _reflection.GeneratedProtocolMessageType('ResetDeviceSettingsResponse', (_message.Message,), {
  'DESCRIPTOR' : _RESETDEVICESETTINGSRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.ResetDeviceSettingsResponse)
  })
_sym_db.RegisterMessage(ResetDeviceSettingsResponse)

SetCalibrationRequest = _reflection.GeneratedProtocolMessageType('SetCalibrationRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETCALIBRATIONREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      first_channel:
          The first channel included in calibration data.  This must
          always be 1. This is required in order to make sure the client
          and MinKNOW agree on what data is being provided.
      last_channel:
          The last channel included in calibration data.  This must
          always be the same as the channel count returned by
          :meth:`get_flow_cell_info`. This is required in order to make
          sure the client and MinKNOW agree on what data is being
          provided.
      offsets:
          The ADC value adjustment to reach 0pA on each channel.  This
          is ``-x``, where ``x`` is the (mean) ADC value at 0pA.
      pa_ranges:
          The range of possible pA values that can be produced by the
          device.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetCalibrationRequest)
  })
_sym_db.RegisterMessage(SetCalibrationRequest)

SetCalibrationResponse = _reflection.GeneratedProtocolMessageType('SetCalibrationResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETCALIBRATIONRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetCalibrationResponse)
  })
_sym_db.RegisterMessage(SetCalibrationResponse)

ClearCalibrationRequest = _reflection.GeneratedProtocolMessageType('ClearCalibrationRequest', (_message.Message,), {
  'DESCRIPTOR' : _CLEARCALIBRATIONREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.ClearCalibrationRequest)
  })
_sym_db.RegisterMessage(ClearCalibrationRequest)

ClearCalibrationResponse = _reflection.GeneratedProtocolMessageType('ClearCalibrationResponse', (_message.Message,), {
  'DESCRIPTOR' : _CLEARCALIBRATIONRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.ClearCalibrationResponse)
  })
_sym_db.RegisterMessage(ClearCalibrationResponse)

GetCalibrationRequest = _reflection.GeneratedProtocolMessageType('GetCalibrationRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETCALIBRATIONREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      first_channel:
          The first channel to get calibration data for.  This should
          normally be 1.
      last_channel:
          The last channel included in calibration data.  This should
          normally be the channel count returned by
          :meth:`get_flow_cell_info`.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetCalibrationRequest)
  })
_sym_db.RegisterMessage(GetCalibrationRequest)

GetCalibrationResponse = _reflection.GeneratedProtocolMessageType('GetCalibrationResponse', (_message.Message,), {
  'DESCRIPTOR' : _GETCALIBRATIONRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      digitisation:
          The range of possible ADC values that can be produced by the
          device.  This is the same as the digitisation value returned
          by the :meth:`DeviceService.get_device_info` RPC. It is
          included here for convenience.
      offsets:
          The ADC value adjustment to reach 0pA on each channel.  This
          is ``-x``, where ``x`` is the (mean) ADC value at 0pA.
      pa_ranges:
          The range of possible pA values that can be produced on each
          channel.  The change in pA represented by a change of 1 ADC
          can be calculated by dividing the digitisation by this value.
      has_calibration:
          Find if there is a stored calibration, or if the returned
          response is empty.  Since 1.12
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetCalibrationResponse)
  })
_sym_db.RegisterMessage(GetCalibrationResponse)

SetTemperatureRequest = _reflection.GeneratedProtocolMessageType('SetTemperatureRequest', (_message.Message,), {

  'WaitForTemperatureSettings' : _reflection.GeneratedProtocolMessageType('WaitForTemperatureSettings', (_message.Message,), {
    'DESCRIPTOR' : _SETTEMPERATUREREQUEST_WAITFORTEMPERATURESETTINGS,
    '__module__' : 'minknow_api.device_pb2'
    ,
    '__doc__': """Attributes:
        timeout:
            Maximum duration (in seconds) to wait for the device to reach
            temperature.  Not specifying a value will wait for a maximum
            of 5 minutes.
        min_stable_duration:
            Minimum duration (in seconds) that the reported temperature
            must be continually within the target temperature range,
            before the device is considered to have reached temperature.
            A value of zero means that the device will be considered to
            have reached temperature as soon as the reported temperature
            is equal to the target temperature.  Not specifying a value is
            equivalent to specifying a value of zero.  The
            min_stable_duration must be less than or equal to the timeout
            duration (if it were greater, then the temperature would never
            be read as 'stable' before the time-out occurred).  Since 3.4
        tolerance:
            Specify an optional tolerance to apply to the wait.  For
            example, if the target temperature is 35, and the tolerance is
            1 any temperature in the range 34 - 36 will cause the request
            to return.  Default is 0.5 degree tolerance.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.device.SetTemperatureRequest.WaitForTemperatureSettings)
    })
  ,
  'DESCRIPTOR' : _SETTEMPERATUREREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      temperature:
          The desired temperature in degrees Celsius.  If temperature
          control is supported and enabled, the device will attempt to
          keep its temperature at this value. See the
          ``can_set_temperature`` field returned by the
          DeviceService.get_device_info() RPC.
      wait_for_temperature:
          Settings which can be specified in order to wait for the
          temperature to be reached.  If this is not set at all, not
          waiting will be done. If it is set (even to an empty
          WaitForTemperatureSettings object), the call will not return
          until either the temperature was reached or the timeout was
          reached. In this case, on MinIONs and GridIONs, the ASIC power
          will be enabled if it was not already. See
          acquisition.StopRequest.keep_power_on for more details about
          the implications of this.  Since 1.15
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetTemperatureRequest)
  })
_sym_db.RegisterMessage(SetTemperatureRequest)
_sym_db.RegisterMessage(SetTemperatureRequest.WaitForTemperatureSettings)

SetTemperatureResponse = _reflection.GeneratedProtocolMessageType('SetTemperatureResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETTEMPERATURERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      timed_out_waiting_for_temperature:
          Find if we hit a timeout waiting for the temperature to be
          hit.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetTemperatureResponse)
  })
_sym_db.RegisterMessage(SetTemperatureResponse)

GetTemperatureRequest = _reflection.GeneratedProtocolMessageType('GetTemperatureRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETTEMPERATUREREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetTemperatureRequest)
  })
_sym_db.RegisterMessage(GetTemperatureRequest)

GetTemperatureResponse = _reflection.GeneratedProtocolMessageType('GetTemperatureResponse', (_message.Message,), {

  'MinIONTemperature' : _reflection.GeneratedProtocolMessageType('MinIONTemperature', (_message.Message,), {
    'DESCRIPTOR' : _GETTEMPERATURERESPONSE_MINIONTEMPERATURE,
    '__module__' : 'minknow_api.device_pb2'
    ,
    '__doc__': """Packet of temperatures appropriate for a MinION.
    
    Attributes:
        asic_temperature:
            Temperature as measured by the probe inside the asic.
        heatsink_temperature:
            Temperature as measured by the probe in the minion heatsink.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.device.GetTemperatureResponse.MinIONTemperature)
    })
  ,

  'PromethIONTemperature' : _reflection.GeneratedProtocolMessageType('PromethIONTemperature', (_message.Message,), {
    'DESCRIPTOR' : _GETTEMPERATURERESPONSE_PROMETHIONTEMPERATURE,
    '__module__' : 'minknow_api.device_pb2'
    ,
    '__doc__': """Packet of temperatures appropriate for a PromethION.
    
    Attributes:
        flowcell_temperature:
            Temperature as measured by thermistor TH2 on the P-Chip.
        chamber_temperature:
            Mean of 12 pixel-blocks temperatures measured with sensors in
            the ASIC.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.device.GetTemperatureResponse.PromethIONTemperature)
    })
  ,
  'DESCRIPTOR' : _GETTEMPERATURERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      target_temperature:
          Return the temperature target the device is aiming to reach.
          Since 1.15
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetTemperatureResponse)
  })
_sym_db.RegisterMessage(GetTemperatureResponse)
_sym_db.RegisterMessage(GetTemperatureResponse.MinIONTemperature)
_sym_db.RegisterMessage(GetTemperatureResponse.PromethIONTemperature)

StreamTemperatureRequest = _reflection.GeneratedProtocolMessageType('StreamTemperatureRequest', (_message.Message,), {
  'DESCRIPTOR' : _STREAMTEMPERATUREREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      period_seconds:
          How often temperature updates should be sent Defaults to a
          period of 1 second, if not specified, or set to 0
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.StreamTemperatureRequest)
  })
_sym_db.RegisterMessage(StreamTemperatureRequest)

UnblockRequest = _reflection.GeneratedProtocolMessageType('UnblockRequest', (_message.Message,), {
  'DESCRIPTOR' : _UNBLOCKREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      channels:
          List of channels indexed from 1.
      duration:
          How long should an unblock last.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.UnblockRequest)
  })
_sym_db.RegisterMessage(UnblockRequest)

UnblockResponse = _reflection.GeneratedProtocolMessageType('UnblockResponse', (_message.Message,), {
  'DESCRIPTOR' : _UNBLOCKRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.UnblockResponse)
  })
_sym_db.RegisterMessage(UnblockResponse)

CancelUnblocksRequest = _reflection.GeneratedProtocolMessageType('CancelUnblocksRequest', (_message.Message,), {
  'DESCRIPTOR' : _CANCELUNBLOCKSREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.CancelUnblocksRequest)
  })
_sym_db.RegisterMessage(CancelUnblocksRequest)

CancelUnblocksResponse = _reflection.GeneratedProtocolMessageType('CancelUnblocksResponse', (_message.Message,), {
  'DESCRIPTOR' : _CANCELUNBLOCKSRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      cancelled_unblocks:
          The number of unblocks which have been cancelled as part of
          this request.  Should return the total number of unblock
          operations which have been cancelled.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.CancelUnblocksResponse)
  })
_sym_db.RegisterMessage(CancelUnblocksResponse)

GetChannelConfigurationRequest = _reflection.GeneratedProtocolMessageType('GetChannelConfigurationRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETCHANNELCONFIGURATIONREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      channels:
          A list of channel names (1-indexed) to specify what channels
          to get channel configs for  Will return an error if any of the
          channel names are below 1, or above the channel count value
          returned from :meth:`get_flow_cell_info`
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetChannelConfigurationRequest)
  })
_sym_db.RegisterMessage(GetChannelConfigurationRequest)

GetChannelConfigurationResponse = _reflection.GeneratedProtocolMessageType('GetChannelConfigurationResponse', (_message.Message,), {
  'DESCRIPTOR' : _GETCHANNELCONFIGURATIONRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      channel_configurations:
          A list of channel configurations  The order of channel
          configurations matches the channel order specified by
          :attribute:`channels` in the request message
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetChannelConfigurationResponse)
  })
_sym_db.RegisterMessage(GetChannelConfigurationResponse)

SetChannelConfigurationRequest = _reflection.GeneratedProtocolMessageType('SetChannelConfigurationRequest', (_message.Message,), {

  'ChannelConfigurationsEntry' : _reflection.GeneratedProtocolMessageType('ChannelConfigurationsEntry', (_message.Message,), {
    'DESCRIPTOR' : _SETCHANNELCONFIGURATIONREQUEST_CHANNELCONFIGURATIONSENTRY,
    '__module__' : 'minknow_api.device_pb2'
    # @@protoc_insertion_point(class_scope:minknow_api.device.SetChannelConfigurationRequest.ChannelConfigurationsEntry)
    })
  ,
  'DESCRIPTOR' : _SETCHANNELCONFIGURATIONREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      channel_configurations:
          A map between <channel name, config to set>  Will return an
          error if any of the key values (representing channel names)
          are below 1, or above the channel count value returned from
          :meth:`get_flow_cell_info`  The selected well cannot be set to
          WELL_OTHER, and will error if it tries to do so  DEPRECATED:
          Note that the type to set may change from 4.0 to enforce the
          fact that unblock cannot be set through this call
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetChannelConfigurationRequest)
  })
_sym_db.RegisterMessage(SetChannelConfigurationRequest)
_sym_db.RegisterMessage(SetChannelConfigurationRequest.ChannelConfigurationsEntry)

SetChannelConfigurationResponse = _reflection.GeneratedProtocolMessageType('SetChannelConfigurationResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETCHANNELCONFIGURATIONRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetChannelConfigurationResponse)
  })
_sym_db.RegisterMessage(SetChannelConfigurationResponse)

SetChannelConfigurationAllRequest = _reflection.GeneratedProtocolMessageType('SetChannelConfigurationAllRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETCHANNELCONFIGURATIONALLREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetChannelConfigurationAllRequest)
  })
_sym_db.RegisterMessage(SetChannelConfigurationAllRequest)

SetChannelConfigurationAllResponse = _reflection.GeneratedProtocolMessageType('SetChannelConfigurationAllResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETCHANNELCONFIGURATIONALLRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetChannelConfigurationAllResponse)
  })
_sym_db.RegisterMessage(SetChannelConfigurationAllResponse)

SaturationConfig = _reflection.GeneratedProtocolMessageType('SaturationConfig', (_message.Message,), {

  'Thresholds' : _reflection.GeneratedProtocolMessageType('Thresholds', (_message.Message,), {
    'DESCRIPTOR' : _SATURATIONCONFIG_THRESHOLDS,
    '__module__' : 'minknow_api.device_pb2'
    ,
    '__doc__': """The thresholds define how many over limit samples are required to
    trigger saturation on the device.  Each packet of frames minknow
    receive is delivered to the saturation check (in approx 64 frame
    chunks), only the first frame of each packet is inspected. The
    thresholds control how many _packets_ must be outside the valid range.
    ie. if general_threshold is set to 10, at least 640 frames are
    required to trigger saturation.  It is also possible to not define the
    value to never trigger saturation in this config.  Note: Setting a
    saturation threshold to 0 will prevent the threshold from triggering.
    
    Attributes:
        general_threshold:
            Threshold for software saturation on all non-unblock muxes
        unblock_threshold:
            Threshold for software saturation on unblock muxes
        user_general_threshold:
            Threshold for user threshold  saturation on all non-unblock
            muxes
        user_unblock_threshold:
            Threshold for user threshold saturation on unblock muxes
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.device.SaturationConfig.Thresholds)
    })
  ,

  'SoftwareSaturation' : _reflection.GeneratedProtocolMessageType('SoftwareSaturation', (_message.Message,), {
    'DESCRIPTOR' : _SATURATIONCONFIG_SOFTWARESATURATION,
    '__module__' : 'minknow_api.device_pb2'
    ,
    '__doc__': """The ranges specify the actual pA or ADC ranges which will trigger
    saturation. This range is checked against the first sample in each
    delivered packet.  software saturation is specified in adc units
    
    Attributes:
        enabled:
            Set to enable or disable software saturation.
        software_min_adc:
            The minimum adc value that is not a saturation.  If this value
            is not specified, the previous value is kept.
        software_max_adc:
            The maximum adc value that is not a saturation.  If this value
            is not specified, the previous value is kept.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.device.SaturationConfig.SoftwareSaturation)
    })
  ,

  'UserThresholdSaturation' : _reflection.GeneratedProtocolMessageType('UserThresholdSaturation', (_message.Message,), {
    'DESCRIPTOR' : _SATURATIONCONFIG_USERTHRESHOLDSATURATION,
    '__module__' : 'minknow_api.device_pb2'
    ,
    '__doc__': """User threshold is specified in pico amps
    
    Attributes:
        enabled:
            Set to enable or disable software saturation.
        user_threshold_min_pa:
            The minimum pA value that is not a saturation.  If this value
            is not specified, the previous value is kept.
        user_threshold_max_pa:
            The maximum pA value that is not a saturation.  If this value
            is not specified, the previous value is kept.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.device.SaturationConfig.UserThresholdSaturation)
    })
  ,
  'DESCRIPTOR' : _SATURATIONCONFIG,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      thresholds:
          Settings for saturation count thresholds, this controls how
          long a saturated value must be over limit before the channel
          is turned off.  If not specified, the previous thresholds are
          kept.
      software_saturation:
          Settings for software saturation, specified in adc units of
          the device.  If not specified, the previous thresholds are
          kept.
      user_threshold_saturation:
          Settings for user threshold saturation, specified in pA.  If
          not specified, the previous thresholds are kept.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.SaturationConfig)
  })
_sym_db.RegisterMessage(SaturationConfig)
_sym_db.RegisterMessage(SaturationConfig.Thresholds)
_sym_db.RegisterMessage(SaturationConfig.SoftwareSaturation)
_sym_db.RegisterMessage(SaturationConfig.UserThresholdSaturation)

SetSaturationConfigRequest = _reflection.GeneratedProtocolMessageType('SetSaturationConfigRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETSATURATIONCONFIGREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetSaturationConfigRequest)
  })
_sym_db.RegisterMessage(SetSaturationConfigRequest)

SetSaturationConfigResponse = _reflection.GeneratedProtocolMessageType('SetSaturationConfigResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETSATURATIONCONFIGRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetSaturationConfigResponse)
  })
_sym_db.RegisterMessage(SetSaturationConfigResponse)

GetSaturationConfigRequest = _reflection.GeneratedProtocolMessageType('GetSaturationConfigRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETSATURATIONCONFIGREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetSaturationConfigRequest)
  })
_sym_db.RegisterMessage(GetSaturationConfigRequest)

GetSaturationConfigResponse = _reflection.GeneratedProtocolMessageType('GetSaturationConfigResponse', (_message.Message,), {
  'DESCRIPTOR' : _GETSATURATIONCONFIGRESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetSaturationConfigResponse)
  })
_sym_db.RegisterMessage(GetSaturationConfigResponse)

GetSampleRateRequest = _reflection.GeneratedProtocolMessageType('GetSampleRateRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETSAMPLERATEREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetSampleRateRequest)
  })
_sym_db.RegisterMessage(GetSampleRateRequest)

GetSampleRateResponse = _reflection.GeneratedProtocolMessageType('GetSampleRateResponse', (_message.Message,), {
  'DESCRIPTOR' : _GETSAMPLERATERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetSampleRateResponse)
  })
_sym_db.RegisterMessage(GetSampleRateResponse)

SetSampleRateRequest = _reflection.GeneratedProtocolMessageType('SetSampleRateRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETSAMPLERATEREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetSampleRateRequest)
  })
_sym_db.RegisterMessage(SetSampleRateRequest)

SetSampleRateResponse = _reflection.GeneratedProtocolMessageType('SetSampleRateResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETSAMPLERATERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  ,
  '__doc__': """Attributes:
      real_sample_rate:
          The real sample rate is the actual sample rate that is set on
          the device, which may be different from the actual value
          passed into the rpc.  For example on promethion, when it is
          given a sample rate, it will round to the nearest 1000. So
          1499 becomes 1000 and 1500 becomes 2000 real sample rate  For
          a minion, the actual sample rate is determined via 3 separate
          values; clock speed, integration time and clock divider, and
          so not all values are possible. e.g. setting 3000 will return
          3012 real sample rate. See 'sampling_frequency' in
          MinionDeviceService for a slightly more in depth explanation
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetSampleRateResponse)
  })
_sym_db.RegisterMessage(SetSampleRateResponse)

GetBiasVoltageRequest = _reflection.GeneratedProtocolMessageType('GetBiasVoltageRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETBIASVOLTAGEREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetBiasVoltageRequest)
  })
_sym_db.RegisterMessage(GetBiasVoltageRequest)

GetBiasVoltageResponse = _reflection.GeneratedProtocolMessageType('GetBiasVoltageResponse', (_message.Message,), {
  'DESCRIPTOR' : _GETBIASVOLTAGERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.GetBiasVoltageResponse)
  })
_sym_db.RegisterMessage(GetBiasVoltageResponse)

SetBiasVoltageRequest = _reflection.GeneratedProtocolMessageType('SetBiasVoltageRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETBIASVOLTAGEREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetBiasVoltageRequest)
  })
_sym_db.RegisterMessage(SetBiasVoltageRequest)

SetBiasVoltageResponse = _reflection.GeneratedProtocolMessageType('SetBiasVoltageResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETBIASVOLTAGERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.SetBiasVoltageResponse)
  })
_sym_db.RegisterMessage(SetBiasVoltageResponse)

DumpStateRequest = _reflection.GeneratedProtocolMessageType('DumpStateRequest', (_message.Message,), {
  'DESCRIPTOR' : _DUMPSTATEREQUEST,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.DumpStateRequest)
  })
_sym_db.RegisterMessage(DumpStateRequest)

DumpStateResponse = _reflection.GeneratedProtocolMessageType('DumpStateResponse', (_message.Message,), {
  'DESCRIPTOR' : _DUMPSTATERESPONSE,
  '__module__' : 'minknow_api.device_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.device.DumpStateResponse)
  })
_sym_db.RegisterMessage(DumpStateResponse)

_DEVICESERVICE = DESCRIPTOR.services_by_name['DeviceService']
if _descriptor._USE_C_DESCRIPTORS == False:

  DESCRIPTOR._options = None
  DESCRIPTOR._serialized_options = b'\n\034com.nanoporetech.minknow_api\242\002\005MKAPI'
  _SETUSERSPECIFIEDFLOWCELLIDREQUEST.fields_by_name['id']._options = None
  _SETUSERSPECIFIEDFLOWCELLIDREQUEST.fields_by_name['id']._serialized_options = b'\210\265\030\001'
  _SETUSERSPECIFIEDPRODUCTCODEREQUEST.fields_by_name['code']._options = None
  _SETUSERSPECIFIEDPRODUCTCODEREQUEST.fields_by_name['code']._serialized_options = b'\210\265\030\001'
  _SETCALIBRATIONREQUEST.fields_by_name['first_channel']._options = None
  _SETCALIBRATIONREQUEST.fields_by_name['first_channel']._serialized_options = b'\210\265\030\001'
  _SETCALIBRATIONREQUEST.fields_by_name['last_channel']._options = None
  _SETCALIBRATIONREQUEST.fields_by_name['last_channel']._serialized_options = b'\210\265\030\001'
  _SETCALIBRATIONREQUEST.fields_by_name['offsets']._options = None
  _SETCALIBRATIONREQUEST.fields_by_name['offsets']._serialized_options = b'\210\265\030\001'
  _SETCALIBRATIONREQUEST.fields_by_name['pa_ranges']._options = None
  _SETCALIBRATIONREQUEST.fields_by_name['pa_ranges']._serialized_options = b'\210\265\030\001'
  _GETCALIBRATIONREQUEST.fields_by_name['first_channel']._options = None
  _GETCALIBRATIONREQUEST.fields_by_name['first_channel']._serialized_options = b'\210\265\030\001'
  _GETCALIBRATIONREQUEST.fields_by_name['last_channel']._options = None
  _GETCALIBRATIONREQUEST.fields_by_name['last_channel']._serialized_options = b'\210\265\030\001'
  _SETCHANNELCONFIGURATIONREQUEST_CHANNELCONFIGURATIONSENTRY._options = None
  _SETCHANNELCONFIGURATIONREQUEST_CHANNELCONFIGURATIONSENTRY._serialized_options = b'8\001'
  _SETCHANNELCONFIGURATIONALLREQUEST.fields_by_name['channel_configuration']._options = None
  _SETCHANNELCONFIGURATIONALLREQUEST.fields_by_name['channel_configuration']._serialized_options = b'\220\265\030\001'
  _SETSATURATIONCONFIGREQUEST.fields_by_name['settings']._options = None
  _SETSATURATIONCONFIGREQUEST.fields_by_name['settings']._serialized_options = b'\220\265\030\001'
  _GETSATURATIONCONFIGRESPONSE.fields_by_name['settings']._options = None
  _GETSATURATIONCONFIGRESPONSE.fields_by_name['settings']._serialized_options = b'\220\265\030\001'
  _SETSAMPLERATEREQUEST.fields_by_name['sample_rate']._options = None
  _SETSAMPLERATEREQUEST.fields_by_name['sample_rate']._serialized_options = b'\210\265\030\001'
  _SETBIASVOLTAGEREQUEST.fields_by_name['bias_voltage']._options = None
  _SETBIASVOLTAGEREQUEST.fields_by_name['bias_voltage']._serialized_options = b'\210\265\030\001'
  _DEVICESERVICE.methods_by_name['get_device_info']._options = None
  _DEVICESERVICE.methods_by_name['get_device_info']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['get_device_state']._options = None
  _DEVICESERVICE.methods_by_name['get_device_state']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['stream_device_state']._options = None
  _DEVICESERVICE.methods_by_name['stream_device_state']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['get_flow_cell_info']._options = None
  _DEVICESERVICE.methods_by_name['get_flow_cell_info']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['stream_flow_cell_info']._options = None
  _DEVICESERVICE.methods_by_name['stream_flow_cell_info']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['set_user_specified_flow_cell_id']._options = None
  _DEVICESERVICE.methods_by_name['set_user_specified_flow_cell_id']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['set_user_specified_product_code']._options = None
  _DEVICESERVICE.methods_by_name['set_user_specified_product_code']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['get_channels_layout']._options = None
  _DEVICESERVICE.methods_by_name['get_channels_layout']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['reset_device_settings']._options = None
  _DEVICESERVICE.methods_by_name['reset_device_settings']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['set_calibration']._options = None
  _DEVICESERVICE.methods_by_name['set_calibration']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['clear_calibration']._options = None
  _DEVICESERVICE.methods_by_name['clear_calibration']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['get_calibration']._options = None
  _DEVICESERVICE.methods_by_name['get_calibration']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['set_temperature']._options = None
  _DEVICESERVICE.methods_by_name['set_temperature']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['get_temperature']._options = None
  _DEVICESERVICE.methods_by_name['get_temperature']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['stream_temperature']._options = None
  _DEVICESERVICE.methods_by_name['stream_temperature']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['get_channel_configuration']._options = None
  _DEVICESERVICE.methods_by_name['get_channel_configuration']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['set_channel_configuration']._options = None
  _DEVICESERVICE.methods_by_name['set_channel_configuration']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['set_channel_configuration_all']._options = None
  _DEVICESERVICE.methods_by_name['set_channel_configuration_all']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['get_saturation_config']._options = None
  _DEVICESERVICE.methods_by_name['get_saturation_config']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['get_sample_rate']._options = None
  _DEVICESERVICE.methods_by_name['get_sample_rate']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['set_sample_rate']._options = None
  _DEVICESERVICE.methods_by_name['set_sample_rate']._serialized_options = b'\220\002\002'
  _DEVICESERVICE.methods_by_name['get_bias_voltage']._options = None
  _DEVICESERVICE.methods_by_name['get_bias_voltage']._serialized_options = b'\220\002\001'
  _DEVICESERVICE.methods_by_name['set_bias_voltage']._options = None
  _DEVICESERVICE.methods_by_name['set_bias_voltage']._serialized_options = b'\220\002\002'
  _FLOWCELLCONNECTORTYPE._serialized_start=5709
  _FLOWCELLCONNECTORTYPE._serialized_end=5814
  _INSERTIONSCRIPTSTATUS._serialized_start=5816
  _INSERTIONSCRIPTSTATUS._serialized_end=5879
  _SELECTEDWELL._serialized_start=5881
  _SELECTEDWELL._serialized_end=5974
  _CHANNELCONFIGURATION._serialized_start=111
  _CHANNELCONFIGURATION._serialized_end=169
  _RETURNEDCHANNELCONFIGURATION._serialized_start=171
  _RETURNEDCHANNELCONFIGURATION._serialized_end=254
  _GETDEVICEINFOREQUEST._serialized_start=256
  _GETDEVICEINFOREQUEST._serialized_end=278
  _GETDEVICEINFORESPONSE._serialized_start=281
  _GETDEVICEINFORESPONSE._serialized_end=779
  _GETDEVICEINFORESPONSE_COMPONENTVERSION._serialized_start=617
  _GETDEVICEINFORESPONSE_COMPONENTVERSION._serialized_end=694
  _GETDEVICEINFORESPONSE_DEVICETYPE._serialized_start=696
  _GETDEVICEINFORESPONSE_DEVICETYPE._serialized_end=779
  _GETDEVICESTATEREQUEST._serialized_start=781
  _GETDEVICESTATEREQUEST._serialized_end=804
  _GETDEVICESTATERESPONSE._serialized_start=807
  _GETDEVICESTATERESPONSE._serialized_end=1039
  _GETDEVICESTATERESPONSE_DEVICESTATE._serialized_start=983
  _GETDEVICESTATERESPONSE_DEVICESTATE._serialized_end=1039
  _STREAMDEVICESTATEREQUEST._serialized_start=1041
  _STREAMDEVICESTATEREQUEST._serialized_end=1067
  _GETFLOWCELLINFOREQUEST._serialized_start=1069
  _GETFLOWCELLINFOREQUEST._serialized_end=1093
  _GETFLOWCELLINFORESPONSE._serialized_start=1096
  _GETFLOWCELLINFORESPONSE._serialized_end=1533
  _STREAMFLOWCELLINFOREQUEST._serialized_start=1535
  _STREAMFLOWCELLINFOREQUEST._serialized_end=1562
  _SETUSERSPECIFIEDFLOWCELLIDREQUEST._serialized_start=1564
  _SETUSERSPECIFIEDFLOWCELLIDREQUEST._serialized_end=1617
  _SETUSERSPECIFIEDFLOWCELLIDRESPONSE._serialized_start=1619
  _SETUSERSPECIFIEDFLOWCELLIDRESPONSE._serialized_end=1655
  _SETUSERSPECIFIEDPRODUCTCODEREQUEST._serialized_start=1657
  _SETUSERSPECIFIEDPRODUCTCODEREQUEST._serialized_end=1713
  _SETUSERSPECIFIEDPRODUCTCODERESPONSE._serialized_start=1715
  _SETUSERSPECIFIEDPRODUCTCODERESPONSE._serialized_end=1752
  _GETCHANNELSLAYOUTREQUEST._serialized_start=1754
  _GETCHANNELSLAYOUTREQUEST._serialized_end=1780
  _GETCHANNELSLAYOUTRESPONSE._serialized_start=1782
  _GETCHANNELSLAYOUTRESPONSE._serialized_end=1869
  _CHANNELRECORD._serialized_start=1872
  _CHANNELRECORD._serialized_end=2036
  _CHANNELRECORD_MUXRECORD._serialized_start=1981
  _CHANNELRECORD_MUXRECORD._serialized_end=2036
  _RESETDEVICESETTINGSREQUEST._serialized_start=2038
  _RESETDEVICESETTINGSREQUEST._serialized_end=2066
  _RESETDEVICESETTINGSRESPONSE._serialized_start=2068
  _RESETDEVICESETTINGSRESPONSE._serialized_end=2097
  _SETCALIBRATIONREQUEST._serialized_start=2100
  _SETCALIBRATIONREQUEST._serialized_end=2228
  _SETCALIBRATIONRESPONSE._serialized_start=2230
  _SETCALIBRATIONRESPONSE._serialized_end=2254
  _CLEARCALIBRATIONREQUEST._serialized_start=2256
  _CLEARCALIBRATIONREQUEST._serialized_end=2281
  _CLEARCALIBRATIONRESPONSE._serialized_start=2283
  _CLEARCALIBRATIONRESPONSE._serialized_end=2309
  _GETCALIBRATIONREQUEST._serialized_start=2311
  _GETCALIBRATIONREQUEST._serialized_end=2391
  _GETCALIBRATIONRESPONSE._serialized_start=2393
  _GETCALIBRATIONRESPONSE._serialized_end=2500
  _SETTEMPERATUREREQUEST._serialized_start=2503
  _SETTEMPERATUREREQUEST._serialized_end=2742
  _SETTEMPERATUREREQUEST_WAITFORTEMPERATURESETTINGS._serialized_start=2649
  _SETTEMPERATUREREQUEST_WAITFORTEMPERATURESETTINGS._serialized_end=2742
  _SETTEMPERATURERESPONSE._serialized_start=2744
  _SETTEMPERATURERESPONSE._serialized_end=2811
  _GETTEMPERATUREREQUEST._serialized_start=2813
  _GETTEMPERATUREREQUEST._serialized_end=2836
  _GETTEMPERATURERESPONSE._serialized_start=2839
  _GETTEMPERATURERESPONSE._serialized_end=3382
  _GETTEMPERATURERESPONSE_MINIONTEMPERATURE._serialized_start=3091
  _GETTEMPERATURERESPONSE_MINIONTEMPERATURE._serialized_end=3224
  _GETTEMPERATURERESPONSE_PROMETHIONTEMPERATURE._serialized_start=3227
  _GETTEMPERATURERESPONSE_PROMETHIONTEMPERATURE._serialized_end=3367
  _STREAMTEMPERATUREREQUEST._serialized_start=3384
  _STREAMTEMPERATUREREQUEST._serialized_end=3434
  _UNBLOCKREQUEST._serialized_start=3436
  _UNBLOCKREQUEST._serialized_end=3549
  _UNBLOCKRESPONSE._serialized_start=3551
  _UNBLOCKRESPONSE._serialized_end=3568
  _CANCELUNBLOCKSREQUEST._serialized_start=3570
  _CANCELUNBLOCKSREQUEST._serialized_end=3593
  _CANCELUNBLOCKSRESPONSE._serialized_start=3595
  _CANCELUNBLOCKSRESPONSE._serialized_end=3647
  _GETCHANNELCONFIGURATIONREQUEST._serialized_start=3649
  _GETCHANNELCONFIGURATIONREQUEST._serialized_end=3699
  _GETCHANNELCONFIGURATIONRESPONSE._serialized_start=3701
  _GETCHANNELCONFIGURATIONRESPONSE._serialized_end=3816
  _SETCHANNELCONFIGURATIONREQUEST._serialized_start=3819
  _SETCHANNELCONFIGURATIONREQUEST._serialized_end=4066
  _SETCHANNELCONFIGURATIONREQUEST_CHANNELCONFIGURATIONSENTRY._serialized_start=3964
  _SETCHANNELCONFIGURATIONREQUEST_CHANNELCONFIGURATIONSENTRY._serialized_end=4066
  _SETCHANNELCONFIGURATIONRESPONSE._serialized_start=4068
  _SETCHANNELCONFIGURATIONRESPONSE._serialized_end=4101
  _SETCHANNELCONFIGURATIONALLREQUEST._serialized_start=4103
  _SETCHANNELCONFIGURATIONALLREQUEST._serialized_end=4217
  _SETCHANNELCONFIGURATIONALLRESPONSE._serialized_start=4219
  _SETCHANNELCONFIGURATIONALLRESPONSE._serialized_end=4255
  _SATURATIONCONFIG._serialized_start=4258
  _SATURATIONCONFIG._serialized_end=5096
  _SATURATIONCONFIG_THRESHOLDS._serialized_start=4531
  _SATURATIONCONFIG_THRESHOLDS._serialized_end=4781
  _SATURATIONCONFIG_SOFTWARESATURATION._serialized_start=4784
  _SATURATIONCONFIG_SOFTWARESATURATION._serialized_end=4931
  _SATURATIONCONFIG_USERTHRESHOLDSATURATION._serialized_start=4934
  _SATURATIONCONFIG_USERTHRESHOLDSATURATION._serialized_end=5096
  _SETSATURATIONCONFIGREQUEST._serialized_start=5098
  _SETSATURATIONCONFIGREQUEST._serialized_end=5188
  _SETSATURATIONCONFIGRESPONSE._serialized_start=5190
  _SETSATURATIONCONFIGRESPONSE._serialized_end=5219
  _GETSATURATIONCONFIGREQUEST._serialized_start=5221
  _GETSATURATIONCONFIGREQUEST._serialized_end=5249
  _GETSATURATIONCONFIGRESPONSE._serialized_start=5251
  _GETSATURATIONCONFIGRESPONSE._serialized_end=5342
  _GETSAMPLERATEREQUEST._serialized_start=5344
  _GETSAMPLERATEREQUEST._serialized_end=5366
  _GETSAMPLERATERESPONSE._serialized_start=5368
  _GETSAMPLERATERESPONSE._serialized_end=5412
  _SETSAMPLERATEREQUEST._serialized_start=5414
  _SETSAMPLERATEREQUEST._serialized_end=5463
  _SETSAMPLERATERESPONSE._serialized_start=5465
  _SETSAMPLERATERESPONSE._serialized_end=5514
  _GETBIASVOLTAGEREQUEST._serialized_start=5516
  _GETBIASVOLTAGEREQUEST._serialized_end=5539
  _GETBIASVOLTAGERESPONSE._serialized_start=5541
  _GETBIASVOLTAGERESPONSE._serialized_end=5587
  _SETBIASVOLTAGEREQUEST._serialized_start=5589
  _SETBIASVOLTAGEREQUEST._serialized_end=5640
  _SETBIASVOLTAGERESPONSE._serialized_start=5642
  _SETBIASVOLTAGERESPONSE._serialized_end=5666
  _DUMPSTATEREQUEST._serialized_start=5668
  _DUMPSTATEREQUEST._serialized_end=5686
  _DUMPSTATERESPONSE._serialized_start=5688
  _DUMPSTATERESPONSE._serialized_end=5707
  _DEVICESERVICE._serialized_start=5977
  _DEVICESERVICE._serialized_end=9217
# @@protoc_insertion_point(module_scope)
