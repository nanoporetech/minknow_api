### THIS FILE IS AUTOGENERATED. DO NOT EDIT THIS FILE DIRECTLY ###
import minknow_api
from minknow_api.acquisition_pb2_grpc import *
import minknow_api.acquisition_pb2 as acquisition_pb2
from minknow_api.acquisition_pb2 import *
from minknow_api._support import MessageWrapper, ArgumentError
import time
import logging
import sys

__all__ = [
    "AcquisitionService",
    "StartRequest",
    "StartResponse",
    "StopRequest",
    "StopResponse",
    "WatchForStatusChangeRequest",
    "WatchForStatusChangeResponse",
    "CurrentStatusRequest",
    "CurrentStatusResponse",
    "GetProgressRequest",
    "GetProgressResponse",
    "GetAcquisitionRunInfoRequest",
    "AcquisitionYieldSummary",
    "AcquisitionWriterSummary",
    "ChannelStateInfo",
    "AcquisitionConfigSummary",
    "MuxScanMetadata",
    "MuxScanResult",
    "BreamInfo",
    "TargetRunUntilCriteria",
    "AcquisitionRunInfo",
    "ListAcquisitionRunsRequest",
    "ListAcquisitionRunsResponse",
    "GetCurrentAcquisitionRunRequest",
    "WatchCurrentAcquisitionRunRequest",
    "SetSignalReaderRequest",
    "SetSignalReaderResponse",
    "GetSignalReaderRequest",
    "GetSignalReaderResponse",
    "SetBreamInfoRequest",
    "SetBreamInfoResponse",
    "AppendMuxScanResultResponse",
    "MinknowStatus",
    "ERROR_STATUS",
    "READY",
    "STARTING",
    "PROCESSING",
    "FINISHING",
    "Option",
    "AUTO",
    "DISABLE",
    "FORCE",
    "Purpose",
    "OTHER_PURPOSE",
    "SEQUENCING",
    "CALIBRATION",
    "AcquisitionState",
    "ACQUISITION_STARTING",
    "ACQUISITION_RUNNING",
    "ACQUISITION_FINISHING",
    "ACQUISITION_COMPLETED",
    "ACQUISITION_PAUSED",
    "AcquisitionStopReason",
    "STOPPED_NOT_SET",
    "STOPPED_USER_REQUESTED",
    "STOPPED_NO_DISK_SPACE",
    "STOPPED_DEVICE_STOPPED_ACQUISITION",
    "STOPPED_STARTING_ANOTHER_RUN",
    "STOPPED_PROTOCOL_ENDED",
    "STOPPED_DEVICE_ERROR",
    "STOPPED_BAD_TEMPERATURE",
    "STOPPED_SHUTDOWN",
    "STOPPED_INTERNAL_ERROR",
    "StartupState",
    "STARTUP_UNKNOWN",
    "STARTUP_BUILDING_PIPELINE",
    "STARTUP_INITIALISING_BASECALLER",
    "STARTUP_INITIALISING_BASECALLER_ALIGNMENT",
    "STARTUP_INITIALISING_DATA_WRITERS",
    "STARTUP_INITIALISING_INTERMEDIATE_DATA_STORAGE",
    "STARTUP_INITIALISING_STATISTICS",
    "FinishingState",
    "FINISHING_UNKNOWN",
    "FINISHING_PROCESSING_DEVICE_SIGNAL",
    "FINISHING_BASECALLING_READS",
    "FINISHING_SAVING_DATA",
]

def run_with_retry(method, message, timeout, unwraps, full_name):
    retry_count = 20
    error = None
    for i in range(retry_count):
        try:
            result = MessageWrapper(method(message, timeout=timeout), unwraps=unwraps)
            return result
        except grpc.RpcError as e:
            # Retrying unidentified grpc errors to keep clients from crashing
            retryable_error = (e.code() == grpc.StatusCode.UNKNOWN and "Stream removed" in e.details() or \
                                (e.code() == grpc.StatusCode.INTERNAL and "RST_STREAM" in e.details()))
            if retryable_error:
                logging.info('Bypassed ({}: {}) error for grpc: {}. Attempt {}.'.format(e.code(), e.details(), full_name, i))
            else:
                raise
            error = e
        time.sleep(1)
    raise error


class AcquisitionService(object):
    def __init__(self, channel):
        self._stub = AcquisitionServiceStub(channel)
        self._pb = acquisition_pb2
    def start(self, _message=None, _timeout=None, **kwargs):
        """Starts reading data from the device

        Some setup calls will need to be made before starting data acquisition: particularly setting the analysis configuration,
        calibration, read writer and bulk writer config and some device calls such as setting the sampling frequency

        If acquisition is already running (even in the FINISHING state), this call will fail.

        On MinIONs and GridIONs, this will enable the ASIC power supply if it is not already enabled.
        See StopRequest.keep_power_on for more details about the implications of this.

        The rpc will return once `current_status` is "PROCESSING" or an error occurs and acquisition fails to start.

        

        Args:
            _message (minknow_api.acquisition_pb2.StartRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            dont_wait_for_device_ready (bool, optional): Prevent waiting until the device is ready before starting acquisition.

                Defaults to false.

                By default, MinKNOW will block in the start() call for the device and flow cell to be ready
                for acquisition (which may take several seconds after plugging in the flow cell on some
                devices). Setting this option will cause the call to return with an error if the device is
                not already prepared to acquire data.

                Since 1.14
            generate_report (minknow_api.acquisition_pb2.Option, optional): Generate duty time and throughput reports.

                Note that this setting will be ignored (and no reports will be generated) if no protocol is
                running at the time acquisition is started.

                The default setting (AUTO) will only generate reports if purpose is set to SEQUENCING.

                Since 3.0
            send_sequencing_read_metrics (minknow_api.acquisition_pb2.Option, optional): Whether sequencing read metrics should be reported to Oxford Nanopore.

                These are performance metrics that are used to improve the sequencing technology. They do not
                include any actual sequencing data, only statistics about read lengths, duty time and similar
                generic performance information.

                The default setting (AUTO) will only send metrics if purpose is set to SEQUENCING.

                Since 3.0
            send_basecalling_metrics (minknow_api.acquisition_pb2.Option, optional): Whether basecalling metrics should be reported to Oxford Nanopore.

                These are performance metrics that are used to improve the sequencing technology. They do not
                include any actual sequencing data, only statistics about basecalling performance.

                The default setting (AUTO) will only send metrics if purpose is set to SEQUENCING.

                NB: this setting is ignored if live basecalling is not enabled, since there will be no
                metrics to send.

                Since 3.2
            purpose (minknow_api.acquisition_pb2.Purpose, optional): Specify the purpose of this acquisition period.

                This affects various defaults (see the Purpose enum documentation for more details). It may
                also affect how the user interface presents the state of the protocol.

                Since 3.2
            analysis (minknow_api.acquisition_pb2.Option, optional): Perform analysis for this acquisition period.

                If this is disabled, no reads, no events, no channel states and no basecalls will be
                generated. Any RPCs that depend on any of these will fail. No reads-based files will be
                produced at all, regardless of any other settings.

                This is mostly useful for calibration (although you should normally use the purpose field
                rather than setting this explicitly).

                The default setting (AUTO) will use the persistent setting from the analysis_configuraiton
                service, unless the purpose is set to CALIBRATION.

                Since 3.2
            file_output (minknow_api.acquisition_pb2.Option, optional): Allow file output for this acquisition period.

                If this is disabled, the file output settings will be ignored for this acquisition period,
                and no data files will be produced. Note that reports are NOT managed by this setting.

                Note that setting this to FORCE will simply make file output respect the bulk and read writer
                configurations. If each file output type is disabled, you will still get no file output.

                This is mostly useful for calibration (although you should normally use the purpose field
                rather than setting this explicitly).

                The default setting (AUTO) will only suppress file output if purpose is set to CALIBRATION.

                Since 3.2
            generate_final_summary (minknow_api.acquisition_pb2.Option, optional): Write a final_summary.txt file.

                If file_output is disabled, the final_summary.txt file will not be written regardless of
                this setting.

                The default setting (AUTO) will only enable writing a final_summary.txt file if the purpose
                is set to SEQUENCING.

                Since 3.5 (NB: in 3.3 and 3.4, final_summary.txt was always written out if file_output was
                enabled).

        Returns:
            minknow_api.acquisition_pb2.StartResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.start,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = StartRequest()

        if "dont_wait_for_device_ready" in kwargs:
            unused_args.remove("dont_wait_for_device_ready")
            _message.dont_wait_for_device_ready = kwargs['dont_wait_for_device_ready']

        if "generate_report" in kwargs:
            unused_args.remove("generate_report")
            _message.generate_report = kwargs['generate_report']

        if "send_sequencing_read_metrics" in kwargs:
            unused_args.remove("send_sequencing_read_metrics")
            _message.send_sequencing_read_metrics = kwargs['send_sequencing_read_metrics']

        if "send_basecalling_metrics" in kwargs:
            unused_args.remove("send_basecalling_metrics")
            _message.send_basecalling_metrics = kwargs['send_basecalling_metrics']

        if "purpose" in kwargs:
            unused_args.remove("purpose")
            _message.purpose = kwargs['purpose']

        if "analysis" in kwargs:
            unused_args.remove("analysis")
            _message.analysis = kwargs['analysis']

        if "file_output" in kwargs:
            unused_args.remove("file_output")
            _message.file_output = kwargs['file_output']

        if "generate_final_summary" in kwargs:
            unused_args.remove("generate_final_summary")
            _message.generate_final_summary = kwargs['generate_final_summary']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to start: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.start,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def stop(self, _message=None, _timeout=None, **kwargs):
        """Stops data acquisition.

        Can specify a stop mode that handles what is done with the data when data acquisition is stopped. Refer to the enum
        description for documentation on what each mode does.

        Be aware that this command will return as soon as Minknow enters the FINISHING state and not the READY state.
        So if starting a new experiment then you will have to wait for the READY state separately

        

        Args:
            _message (minknow_api.acquisition_pb2.StopRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            data_action_on_stop (minknow_api.acquisition_pb2.StopRequest.DataAction, optional): 
            wait_until_ready (bool, optional): Defaults to false
                If false will return as soon as minknow enters the FINISHING state.
                If true then returns as soon as minknow enters the READY state.
            keep_power_on (bool, optional): Force the MinION/GridION ASIC power to be kept on after the current acquisition finishes

                Keeping the ASIC power on has two main effects:

                     - The flow-cell will remain at the correct operating temperature between acquisitions;
                       this allows following acquisition to be started more quickly.

                     - MinION/GridION flow cells may be damaged if they are removed or plugged in while the
                       ASIC power is turned on.

                Therefore, this option should be set to `true` if and only if another acquisition will be
                performed using the same flow-cell, soon after the acquisition that is being stopped.
                Otherwise it should be set to `false` (or left unset) to prevent potential damage to
                MinION/GridION flow-cells.

                If this option is set to `false` (or is left unset), then the application configuration
                determines whether the power will be left on when the acquisition finishes -- see the
                `powered_when_idle` and `flongle_powered_when_idle` configuration options for further
                details.

                This option has no effect on PromethIONs.

                Since 1.15.2

        Returns:
            minknow_api.acquisition_pb2.StopResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.stop,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = StopRequest()

        if "data_action_on_stop" in kwargs:
            unused_args.remove("data_action_on_stop")
            _message.data_action_on_stop = kwargs['data_action_on_stop']

        if "wait_until_ready" in kwargs:
            unused_args.remove("wait_until_ready")
            _message.wait_until_ready = kwargs['wait_until_ready']

        if "keep_power_on" in kwargs:
            unused_args.remove("keep_power_on")
            _message.keep_power_on = kwargs['keep_power_on']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to stop: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.stop,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def watch_for_status_change(self, iterator):
        """Watches for status changes within MinKNOW. Status states are defined from MinknowStatus enum.
        This is a bi-directional stream where the incoming response stream will return every time the status has changed
        and the request stream is used to stop the watcher. Refer to http://www.grpc.io/docs/tutorials/basic/python.html
        to see how bi-directional streaming works in grpc, but essentially when calling this function the user will have
        to pass in a generator that will eventually yield a WatchForStatusChangeRequest(stop=True) to the cpp side.
        A wrapper class for this is provided in the Python code.

        The function will first return with the current status that MinKNOW is in. Every response thereafter will be a
        change from one status to another.

        The ERROR_STATUS state includes errors during transition between states. If that happens, MinKNOW will
        try to revert to the READY state. It is up to the user to determine if they wish to try to wait for MinKNOW to
        correct itself or to try some other course of action

        This RPC has no side effects. Calling it will have no effect on the state of the
        system. It is safe to call repeatedly, or to retry on failure, although there is no
        guarantee it will return the same information each time.

        Args:
            iterator (iter of minknow_api.acquisition_pb2.WatchForStatusChangeRequest): An interable that
                yields the messages to send.

        Returns:
            iter of minknow_api.acquisition_pb2.WatchForStatusChangeResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        return self._stub.watch_for_status_change(iterator)
    def watch_current_acquisition_run(self, _message=None, _timeout=None, **kwargs):
        """Returns current acquisition run info and streams any changes to the current acquisition

        This call can be made even if acquisition is not running. In this case, the next streamed
        response will be the start of a new acquisition and you will receive updates for that acquisition
        until it finishes.

        If an acquisition finishes this stream will still continue to run and you will be notified when a new acquisition starts.

        Note if you begin this stream before any acquisition is started in minknow the state is `ACQUISITION_COMPLETED`.

        Since 1.13

        This RPC has no side effects. Calling it will have no effect on the state of the
        system. It is safe to call repeatedly, or to retry on failure, although there is no
        guarantee it will return the same information each time.

        Args:
            _message (minknow_api.acquisition_pb2.WatchCurrentAcquisitionRunRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
                Note that this is the time until the call ends, not the time between returned
                messages.

        Returns:
            iter of minknow_api.acquisition_pb2.AcquisitionRunInfo

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.watch_current_acquisition_run,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = WatchCurrentAcquisitionRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to watch_current_acquisition_run: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.watch_current_acquisition_run,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def current_status(self, _message=None, _timeout=None, **kwargs):
        """Check the current status of MinKNOW.

        This RPC has no side effects. Calling it will have no effect on the state of the
        system. It is safe to call repeatedly, or to retry on failure, although there is no
        guarantee it will return the same information each time.

        Args:
            _message (minknow_api.acquisition_pb2.CurrentStatusRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.

        Returns:
            minknow_api.acquisition_pb2.CurrentStatusResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.current_status,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = CurrentStatusRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to current_status: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.current_status,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def get_progress(self, _message=None, _timeout=None, **kwargs):
        """Information on how much data has been acquired, processed and written.

        This RPC has no side effects. Calling it will have no effect on the state of the
        system. It is safe to call repeatedly, or to retry on failure, although there is no
        guarantee it will return the same information each time.

        Args:
            _message (minknow_api.acquisition_pb2.GetProgressRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.

        Returns:
            minknow_api.acquisition_pb2.GetProgressResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.get_progress,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = GetProgressRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to get_progress: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.get_progress,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def get_acquisition_info(self, _message=None, _timeout=None, **kwargs):
        """Gets information about an acquisition run, run within this instance on MinKNOW.

        If no run ID is provided, information about the most recently started acquisition run is
        provided.

        Since 1.11

        This RPC has no side effects. Calling it will have no effect on the state of the
        system. It is safe to call repeatedly, or to retry on failure, although there is no
        guarantee it will return the same information each time.

        Args:
            _message (minknow_api.acquisition_pb2.GetAcquisitionRunInfoRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            run_id (str, optional): The acquisition period to get information about.

        Returns:
            minknow_api.acquisition_pb2.AcquisitionRunInfo

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.get_acquisition_info,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = GetAcquisitionRunInfoRequest()

        if "run_id" in kwargs:
            unused_args.remove("run_id")
            _message.run_id = kwargs['run_id']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to get_acquisition_info: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.get_acquisition_info,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def list_acquisition_runs(self, _message=None, _timeout=None, **kwargs):
        """Gets information about all previous acquisitions.

        Since 1.11

        This RPC has no side effects. Calling it will have no effect on the state of the
        system. It is safe to call repeatedly, or to retry on failure, although there is no
        guarantee it will return the same information each time.

        Args:
            _message (minknow_api.acquisition_pb2.ListAcquisitionRunsRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.

        Returns:
            minknow_api.acquisition_pb2.ListAcquisitionRunsResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.list_acquisition_runs,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = ListAcquisitionRunsRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to list_acquisition_runs: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.list_acquisition_runs,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def get_current_acquisition_run(self, _message=None, _timeout=None, **kwargs):
        """Returns the name and run id of the currently running acquisition.

        Will fail with FAILED_PRECONDITION if there is no acquisition running

        Since 1.11

        This RPC has no side effects. Calling it will have no effect on the state of the
        system. It is safe to call repeatedly, or to retry on failure, although there is no
        guarantee it will return the same information each time.

        Args:
            _message (minknow_api.acquisition_pb2.GetCurrentAcquisitionRunRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.

        Returns:
            minknow_api.acquisition_pb2.AcquisitionRunInfo

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.get_current_acquisition_run,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = GetCurrentAcquisitionRunRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to get_current_acquisition_run: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.get_current_acquisition_run,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def set_signal_reader(self, _message=None, _timeout=None, **kwargs):
        """Specify the signal reader to use

        Since 3.6

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.acquisition_pb2.SetSignalReaderRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            reader (minknow_api.acquisition_pb2.SetSignalReaderRequest.SignalReaderType): The type of signal reader to use
            hdf_source (str, optional): The following settings are optional, and only used when setting the reader to hdf5
            hdf_mode (minknow_api.acquisition_pb2.SetSignalReaderRequest.SourceFileMode, optional): 
            sample_rate_scale_factor (float, optional): 

        Returns:
            minknow_api.acquisition_pb2.SetSignalReaderResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.set_signal_reader,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = SetSignalReaderRequest()

        if "reader" in kwargs:
            unused_args.remove("reader")
            _message.reader = kwargs['reader']
        else:
            raise ArgumentError("set_signal_reader requires a 'reader' argument")

        if "hdf_source" in kwargs:
            unused_args.remove("hdf_source")
            _message.hdf_source = kwargs['hdf_source']

        if "hdf_mode" in kwargs:
            unused_args.remove("hdf_mode")
            _message.hdf_mode = kwargs['hdf_mode']

        if "sample_rate_scale_factor" in kwargs:
            unused_args.remove("sample_rate_scale_factor")
            _message.sample_rate_scale_factor = kwargs['sample_rate_scale_factor']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to set_signal_reader: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.set_signal_reader,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def get_signal_reader(self, _message=None, _timeout=None, **kwargs):
        """Find the signal reader in use. This may have been configured by MinKNOW prior to a protocol being begun.

        Since 6.2

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.acquisition_pb2.GetSignalReaderRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.

        Returns:
            minknow_api.acquisition_pb2.GetSignalReaderResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.get_signal_reader,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = GetSignalReaderRequest()

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to get_signal_reader: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.get_signal_reader,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def set_bream_info(self, _message=None, _timeout=None, **kwargs):
        """Set the bream information for the current acquisition.

        This should only be called by the protocol. It will only affect the last acquisition that was
        started in the current protocol.

        If no protocol is running, or no acquisition has been started during the current protocol, a
        FAILED_PRECONDITION error will be returned.

        Since 5.0

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.acquisition_pb2.SetBreamInfoRequest, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            info (minknow_api.acquisition_pb2.BreamInfo, optional): The information to set.

                Note that, other than treating the top-level fields independently (see the other flags on
                this request), MinKNOW Core will not do anything special to the data. In particular, the
                caller must fill in the `mux_scan_timestamp` field in `MuxScanResult` messages.
            overwrite_unset_fields (bool, optional): If any `BreamInfo` fields were set in a previous call, but are unset in the `info` field of
                this call, then use the old value for them.

                For example, to just update the mux_scan_metadata field, use a BreamInfo object with only the
                `mux_scan_metadata` field set, and leave this as False. To clear the entire BreamInfo
                structure, leave `info` empty and set this to True.

        Returns:
            minknow_api.acquisition_pb2.SetBreamInfoResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.set_bream_info,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = SetBreamInfoRequest()

        if "info" in kwargs:
            unused_args.remove("info")
            _message.info.CopyFrom(kwargs['info'])

        if "overwrite_unset_fields" in kwargs:
            unused_args.remove("overwrite_unset_fields")
            _message.overwrite_unset_fields = kwargs['overwrite_unset_fields']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to set_bream_info: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.set_bream_info,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
    def append_mux_scan_result(self, _message=None, _timeout=None, **kwargs):
        """Add a mux scan result to the bream information for the current acquisition.

        This should only be called by the protocol. It will only affect the last acquisition that was
        started in the current protocol.

        If no protocol is running, or no acquisition has been started during the current protocol, a
        FAILED_PRECONDITION error will be returned.

        Since 5.0

        This RPC is idempotent. It may change the state of the system, but if the requested
        change has already happened, it will not fail because of this, make any additional
        changes or return a different value.

        Args:
            _message (minknow_api.acquisition_pb2.MuxScanResult, optional): The message to send.
                This can be passed instead of the keyword arguments.
            _timeout (float, optional): The call will be cancelled after this number of seconds
                if it has not been completed.
            counts (minknow_api.acquisition_pb2.MuxScanResult.CountsEntry, optional): How many channel muxes are in each category.

                The sum of all the values in this map should be the number of channels multiplied by the
                number of muxes on each channel (eg: 512x4=2048 on a MinION Mk1B without a flongle adapter).

                eg. 'sequencing': 1500
            mux_scan_timestamp (int, optional): When this mux scan result was added (Seconds since the start of the acquisition).

        Returns:
            minknow_api.acquisition_pb2.AppendMuxScanResultResponse

        Note that the returned messages are actually wrapped in a type that collapses
        submessages for fields marked with ``[rpc_unwrap]``.
        """
        if _message is not None:
            if isinstance(_message, MessageWrapper):
                _message = _message._message
            return run_with_retry(self._stub.append_mux_scan_result,
                                  _message, _timeout,
                                  [],
                                  "minknow_api.acquisition.AcquisitionService")

        unused_args = set(kwargs.keys())

        _message = MuxScanResult()

        if "counts" in kwargs:
            unused_args.remove("counts")
            _message.counts.update(kwargs['counts'])
            

        if "mux_scan_timestamp" in kwargs:
            unused_args.remove("mux_scan_timestamp")
            _message.mux_scan_timestamp = kwargs['mux_scan_timestamp']

        if len(unused_args) > 0:
            raise ArgumentError("Unexpected keyword arguments to append_mux_scan_result: '{}'".format(", ".join(unused_args)))

        return run_with_retry(self._stub.append_mux_scan_result,
                              _message, _timeout,
                              [],
                              "minknow_api.acquisition.AcquisitionService")
