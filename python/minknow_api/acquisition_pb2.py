# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: minknow_api/acquisition.proto
"""Generated protocol buffer code."""
from google.protobuf.internal import enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from minknow_api import rpc_options_pb2 as minknow__api_dot_rpc__options__pb2
from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1dminknow_api/acquisition.proto\x12\x17minknow_api.acquisition\x1a\x1dminknow_api/rpc_options.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xd3\x03\n\x0cStartRequest\x12\"\n\x1a\x64ont_wait_for_device_ready\x18\x02 \x01(\x08\x12\x38\n\x0fgenerate_report\x18\x03 \x01(\x0e\x32\x1f.minknow_api.acquisition.Option\x12\x45\n\x1csend_sequencing_read_metrics\x18\x04 \x01(\x0e\x32\x1f.minknow_api.acquisition.Option\x12\x41\n\x18send_basecalling_metrics\x18\x05 \x01(\x0e\x32\x1f.minknow_api.acquisition.Option\x12\x31\n\x07purpose\x18\x06 \x01(\x0e\x32 .minknow_api.acquisition.Purpose\x12\x31\n\x08\x61nalysis\x18\x07 \x01(\x0e\x32\x1f.minknow_api.acquisition.Option\x12\x34\n\x0b\x66ile_output\x18\x08 \x01(\x0e\x32\x1f.minknow_api.acquisition.Option\x12?\n\x16generate_final_summary\x18\t \x01(\x0e\x32\x1f.minknow_api.acquisition.Option\"\x1f\n\rStartResponse\x12\x0e\n\x06run_id\x18\x01 \x01(\t\"\xe0\x01\n\x0bStopRequest\x12L\n\x13\x64\x61ta_action_on_stop\x18\x01 \x01(\x0e\x32/.minknow_api.acquisition.StopRequest.DataAction\x12\x18\n\x10wait_until_ready\x18\x02 \x01(\x08\x12\x15\n\rkeep_power_on\x18\x03 \x01(\x08\"R\n\nDataAction\x12\x10\n\x0cSTOP_DEFAULT\x10\x00\x12\x16\n\x12STOP_KEEP_ALL_DATA\x10\x01\x12\x1a\n\x16STOP_FINISH_PROCESSING\x10\x02\"\x0e\n\x0cStopResponse\"+\n\x1bWatchForStatusChangeRequest\x12\x0c\n\x04stop\x18\x01 \x01(\x08\"V\n\x1cWatchForStatusChangeResponse\x12\x36\n\x06status\x18\x01 \x01(\x0e\x32&.minknow_api.acquisition.MinknowStatus\"\x16\n\x14\x43urrentStatusRequest\"O\n\x15\x43urrentStatusResponse\x12\x36\n\x06status\x18\x01 \x01(\x0e\x32&.minknow_api.acquisition.MinknowStatus\"\x14\n\x12GetProgressRequest\"\xa0\x01\n\x13GetProgressResponse\x12S\n\x0fraw_per_channel\x18\x01 \x01(\x0b\x32:.minknow_api.acquisition.GetProgressResponse.RawPerChannel\x1a\x34\n\rRawPerChannel\x12\x10\n\x08\x61\x63quired\x18\x01 \x01(\x04\x12\x11\n\tprocessed\x18\x02 \x01(\x04\".\n\x1cGetAcquisitionRunInfoRequest\x12\x0e\n\x06run_id\x18\x01 \x01(\t\"\x96\x04\n\x17\x41\x63quisitionYieldSummary\x12\x12\n\nread_count\x18\x01 \x01(\x03\x12\x1b\n\x13\x66raction_basecalled\x18\x14 \x01(\x02\x12\x18\n\x10\x66raction_skipped\x18\x15 \x01(\x02\x12\"\n\x1a\x62\x61secalled_pass_read_count\x18\x03 \x01(\x03\x12\"\n\x1a\x62\x61secalled_fail_read_count\x18\x04 \x01(\x03\x12%\n\x1d\x62\x61secalled_skipped_read_count\x18\n \x01(\x03\x12\x1d\n\x15\x62\x61secalled_pass_bases\x18\x05 \x01(\x03\x12\x1d\n\x15\x62\x61secalled_fail_bases\x18\x12 \x01(\x03\x12\x1a\n\x12\x62\x61secalled_samples\x18\x06 \x01(\x03\x12\x1c\n\x14selected_raw_samples\x18\x07 \x01(\x03\x12\x17\n\x0fselected_events\x18\x08 \x01(\x03\x12 \n\x18\x65stimated_selected_bases\x18\t \x01(\x03\x12\x19\n\x11\x61lignment_matches\x18\x0e \x01(\x03\x12\x1c\n\x14\x61lignment_mismatches\x18\x0f \x01(\x03\x12\x1c\n\x14\x61lignment_insertions\x18\x10 \x01(\x03\x12\x1b\n\x13\x61lignment_deletions\x18\x11 \x01(\x03\x12\x1a\n\x12\x61lignment_coverage\x18\x13 \x01(\x02\"\x96\x01\n\x18\x41\x63quisitionWriterSummary\x12\x1f\n\x17\x62ytes_to_write_produced\x18\x02 \x01(\x03\x12\x1d\n\x15\x62ytes_to_write_failed\x18\x03 \x01(\x03\x12 \n\x18\x62ytes_to_write_completed\x18\x04 \x01(\x03J\x04\x08\x01\x10\x02R\x12written_read_count\"\xb0\x03\n\x10\x43hannelStateInfo\x12?\n\x06groups\x18\x01 \x03(\x0b\x32/.minknow_api.acquisition.ChannelStateInfo.Group\x1a;\n\x05Style\x12\r\n\x05label\x18\x01 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\x12\x0e\n\x06\x63olour\x18\x03 \x01(\t\x1a~\n\x0c\x43hannelState\x12\n\n\x02id\x18\x01 \x01(\r\x12\x0c\n\x04name\x18\x02 \x01(\t\x12>\n\x05style\x18\x03 \x01(\x0b\x32/.minknow_api.acquisition.ChannelStateInfo.Style\x12\x14\n\x0cglobal_order\x18\x04 \x01(\r\x1a\x9d\x01\n\x05Group\x12\x0c\n\x04name\x18\x01 \x01(\t\x12>\n\x05style\x18\x02 \x01(\x0b\x32/.minknow_api.acquisition.ChannelStateInfo.Style\x12\x46\n\x06states\x18\x03 \x03(\x0b\x32\x36.minknow_api.acquisition.ChannelStateInfo.ChannelState\"\x9f\x05\n\x18\x41\x63quisitionConfigSummary\x12\x31\n\x07purpose\x18\x15 \x01(\x0e\x32 .minknow_api.acquisition.Purpose\x12\x1b\n\x13\x62\x61secalling_enabled\x18\x01 \x01(\x08\x12#\n\x1b\x62\x61secalling_config_filename\x18\x10 \x01(\t\x12\x19\n\x11\x62\x61rcoding_enabled\x18\r \x01(\x08\x12\x16\n\x0e\x62\x61rcoding_kits\x18\x11 \x03(\t\x12\x19\n\x11\x61lignment_enabled\x18\x0e \x01(\x08\x12!\n\x19\x61lignment_reference_files\x18\x12 \x03(\t\x12\x1a\n\x12\x61lignment_bed_file\x18\x13 \x01(\t\x12\x14\n\x0clamp_enabled\x18\x0f \x01(\x08\x12\x10\n\x08lamp_kit\x18\x14 \x01(\t\x12\x17\n\x0freads_directory\x18\x02 \x01(\t\x12\"\n\x1areads_fallback_directories\x18\x03 \x03(\t\x12\x1b\n\x13\x66\x61st5_reads_enabled\x18\x04 \x01(\x08\x12\x1b\n\x13\x66\x61stq_reads_enabled\x18\x05 \x01(\x08\x12\x1e\n\x16protobuf_reads_enabled\x18\x06 \x01(\x08\x12\x16\n\x0e\x62ulk_file_path\x18\x07 \x01(\t\x12\x19\n\x11\x62ulk_file_enabled\x18\x08 \x01(\x08\x12\x45\n\x12\x63hannel_state_info\x18\t \x01(\x0b\x32).minknow_api.acquisition.ChannelStateInfo\x12\x1c\n\x14\x65vents_to_base_ratio\x18\n \x01(\x02\x12\x13\n\x0bsample_rate\x18\x0b \x01(\r\x12\x15\n\rchannel_count\x18\x0c \x01(\r\"\xd6\x03\n\x0fMuxScanMetadata\x12\"\n\x1a\x61uto_mux_scan_period_hours\x18\x01 \x01(\x02\x12O\n\x0f\x63\x61tegory_groups\x18\x02 \x03(\x0b\x32\x36.minknow_api.acquisition.MuxScanMetadata.CategoryGroup\x1a;\n\x05Style\x12\r\n\x05label\x18\x01 \x01(\t\x12\x13\n\x0b\x64\x65scription\x18\x02 \x01(\t\x12\x0e\n\x06\x63olour\x18\x03 \x01(\t\x1am\n\x08\x43\x61tegory\x12\x0c\n\x04name\x18\x01 \x01(\t\x12=\n\x05style\x18\x02 \x01(\x0b\x32..minknow_api.acquisition.MuxScanMetadata.Style\x12\x14\n\x0cglobal_order\x18\x03 \x01(\r\x1a\xa1\x01\n\rCategoryGroup\x12\x0c\n\x04name\x18\x01 \x01(\t\x12=\n\x05style\x18\x02 \x01(\x0b\x32..minknow_api.acquisition.MuxScanMetadata.Style\x12\x43\n\x08\x63\x61tegory\x18\x03 \x03(\x0b\x32\x31.minknow_api.acquisition.MuxScanMetadata.Category\"\x9e\x01\n\rMuxScanResult\x12\x42\n\x06\x63ounts\x18\x01 \x03(\x0b\x32\x32.minknow_api.acquisition.MuxScanResult.CountsEntry\x12\x1a\n\x12mux_scan_timestamp\x18\x02 \x01(\x04\x1a-\n\x0b\x43ountsEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\r:\x02\x38\x01\"\x93\x03\n\tBreamInfo\x12\x43\n\x11mux_scan_metadata\x18\x01 \x01(\x0b\x32(.minknow_api.acquisition.MuxScanMetadata\x12@\n\x10mux_scan_results\x18\x02 \x03(\x0b\x32&.minknow_api.acquisition.MuxScanResult\x12L\n\x1atarget_translocation_speed\x18\x03 \x01(\x0b\x32(.minknow_api.acquisition.BreamInfo.Range\x12@\n\x0etarget_q_score\x18\x04 \x01(\x0b\x32(.minknow_api.acquisition.BreamInfo.Range\x12\x44\n\x12target_temperature\x18\x05 \x01(\x0b\x32(.minknow_api.acquisition.BreamInfo.Range\x1a)\n\x05Range\x12\x0f\n\x07minimum\x18\x01 \x01(\x01\x12\x0f\n\x07maximum\x18\x02 \x01(\x01\"\xfd\x06\n\x12\x41\x63quisitionRunInfo\x12\x0e\n\x06run_id\x18\x01 \x01(\t\x12<\n\rstartup_state\x18\x0c \x01(\x0e\x32%.minknow_api.acquisition.StartupState\x12?\n\x1bstartup_state_estimated_end\x18\r \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x30\n(startup_state_estimated_percent_complete\x18\x0e \x01(\x02\x12\x38\n\x05state\x18\x02 \x01(\x0e\x32).minknow_api.acquisition.AcquisitionState\x12@\n\x0f\x66inishing_state\x18\n \x01(\x0e\x32\'.minknow_api.acquisition.FinishingState\x12\x43\n\x0bstop_reason\x18\x03 \x01(\x0e\x32..minknow_api.acquisition.AcquisitionStopReason\x12.\n\nstart_time\x18\x04 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x38\n\x14\x64\x61ta_read_start_time\x18\x05 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x36\n\x12\x64\x61ta_read_end_time\x18\x06 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12,\n\x08\x65nd_time\x18\x07 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12G\n\ryield_summary\x18\x08 \x01(\x0b\x32\x30.minknow_api.acquisition.AcquisitionYieldSummary\x12I\n\x0e\x63onfig_summary\x18\t \x01(\x0b\x32\x31.minknow_api.acquisition.AcquisitionConfigSummary\x12I\n\x0ewriter_summary\x18\x0b \x01(\x0b\x32\x31.minknow_api.acquisition.AcquisitionWriterSummary\x12\x36\n\nbream_info\x18\x0f \x01(\x0b\x32\".minknow_api.acquisition.BreamInfo\"\x1c\n\x1aListAcquisitionRunsRequest\".\n\x1bListAcquisitionRunsResponse\x12\x0f\n\x07run_ids\x18\x01 \x03(\t\"!\n\x1fGetCurrentAcquisitionRunRequest\"#\n!WatchCurrentAcquisitionRunRequest\"\xdf\x02\n\x16SetSignalReaderRequest\x12V\n\x06reader\x18\x01 \x01(\x0e\x32@.minknow_api.acquisition.SetSignalReaderRequest.SignalReaderTypeB\x04\x88\xb5\x18\x01\x12\x12\n\nhdf_source\x18\x02 \x01(\t\x12P\n\x08hdf_mode\x18\x03 \x01(\x0e\x32>.minknow_api.acquisition.SetSignalReaderRequest.SourceFileMode\x12 \n\x18sample_rate_scale_factor\x18\x04 \x01(\x02\"(\n\x10SignalReaderType\x12\x08\n\x04HDF5\x10\x00\x12\n\n\x06\x44\x45VICE\x10\x01\";\n\x0eSourceFileMode\x12\x0f\n\x0bUNSPECIFIED\x10\x00\x12\x0e\n\nSINGLE_RUN\x10\x01\x12\x08\n\x04LOOP\x10\x02\"\x19\n\x17SetSignalReaderResponse\"g\n\x13SetBreamInfoRequest\x12\x30\n\x04info\x18\x01 \x01(\x0b\x32\".minknow_api.acquisition.BreamInfo\x12\x1e\n\x16overwrite_unset_fields\x18\x02 \x01(\x08\"\x16\n\x14SetBreamInfoResponse\"\x1d\n\x1b\x41ppendMuxScanResultResponse*Y\n\rMinknowStatus\x12\x10\n\x0c\x45RROR_STATUS\x10\x00\x12\t\n\x05READY\x10\x01\x12\x0c\n\x08STARTING\x10\x02\x12\x0e\n\nPROCESSING\x10\x03\x12\r\n\tFINISHING\x10\x04**\n\x06Option\x12\x08\n\x04\x41UTO\x10\x00\x12\x0b\n\x07\x44ISABLE\x10\x01\x12\t\n\x05\x46ORCE\x10\x02*=\n\x07Purpose\x12\x11\n\rOTHER_PURPOSE\x10\x00\x12\x0e\n\nSEQUENCING\x10\x02\x12\x0f\n\x0b\x43\x41LIBRATION\x10\x03*{\n\x10\x41\x63quisitionState\x12\x18\n\x14\x41\x43QUISITION_STARTING\x10\x00\x12\x17\n\x13\x41\x43QUISITION_RUNNING\x10\x01\x12\x19\n\x15\x41\x43QUISITION_FINISHING\x10\x02\x12\x19\n\x15\x41\x43QUISITION_COMPLETED\x10\x03*\xb2\x02\n\x15\x41\x63quisitionStopReason\x12\x13\n\x0fSTOPPED_NOT_SET\x10\x00\x12\x1a\n\x16STOPPED_USER_REQUESTED\x10\x01\x12\x19\n\x15STOPPED_NO_DISK_SPACE\x10\x02\x12&\n\"STOPPED_DEVICE_STOPPED_ACQUISITION\x10\x03\x12 \n\x1cSTOPPED_STARTING_ANOTHER_RUN\x10\x04\x12\x1a\n\x16STOPPED_PROTOCOL_ENDED\x10\x05\x12\x18\n\x14STOPPED_DEVICE_ERROR\x10\x06\x12\x1b\n\x17STOPPED_BAD_TEMPERATURE\x10\x07\x12\x14\n\x10STOPPED_SHUTDOWN\x10\x08\x12\x1a\n\x16STOPPED_INTERNAL_ERROR\x10\t*\x96\x02\n\x0cStartupState\x12\x13\n\x0fSTARTUP_UNKNOWN\x10\x00\x12\x1d\n\x19STARTUP_BUILDING_PIPELINE\x10\x02\x12#\n\x1fSTARTUP_INITIALISING_BASECALLER\x10\x03\x12-\n)STARTUP_INITIALISING_BASECALLER_ALIGNMENT\x10\x04\x12%\n!STARTUP_INITIALISING_DATA_WRITERS\x10\x05\x12\x32\n.STARTUP_INITIALISING_INTERMEDIATE_DATA_STORAGE\x10\x06\x12#\n\x1fSTARTUP_INITIALISING_STATISTICS\x10\x07*\x8b\x01\n\x0e\x46inishingState\x12\x15\n\x11\x46INISHING_UNKNOWN\x10\x00\x12&\n\"FINISHING_PROCESSING_DEVICE_SIGNAL\x10\x01\x12\x1f\n\x1b\x46INISHING_BASECALLING_READS\x10\x02\x12\x19\n\x15\x46INISHING_SAVING_DATA\x10\x03\x32\xd4\x0b\n\x12\x41\x63quisitionService\x12X\n\x05start\x12%.minknow_api.acquisition.StartRequest\x1a&.minknow_api.acquisition.StartResponse\"\x00\x12U\n\x04stop\x12$.minknow_api.acquisition.StopRequest\x1a%.minknow_api.acquisition.StopResponse\"\x00\x12\x8f\x01\n\x17watch_for_status_change\x12\x34.minknow_api.acquisition.WatchForStatusChangeRequest\x1a\x35.minknow_api.acquisition.WatchForStatusChangeResponse\"\x03\x90\x02\x01(\x01\x30\x01\x12\x8f\x01\n\x1dwatch_current_acquisition_run\x12:.minknow_api.acquisition.WatchCurrentAcquisitionRunRequest\x1a+.minknow_api.acquisition.AcquisitionRunInfo\"\x03\x90\x02\x01\x30\x01\x12t\n\x0e\x63urrent_status\x12-.minknow_api.acquisition.CurrentStatusRequest\x1a..minknow_api.acquisition.CurrentStatusResponse\"\x03\x90\x02\x01\x12n\n\x0cget_progress\x12+.minknow_api.acquisition.GetProgressRequest\x1a,.minknow_api.acquisition.GetProgressResponse\"\x03\x90\x02\x01\x12\x7f\n\x14get_acquisition_info\x12\x35.minknow_api.acquisition.GetAcquisitionRunInfoRequest\x1a+.minknow_api.acquisition.AcquisitionRunInfo\"\x03\x90\x02\x01\x12\x87\x01\n\x15list_acquisition_runs\x12\x33.minknow_api.acquisition.ListAcquisitionRunsRequest\x1a\x34.minknow_api.acquisition.ListAcquisitionRunsResponse\"\x03\x90\x02\x01\x12\x89\x01\n\x1bget_current_acquisition_run\x12\x38.minknow_api.acquisition.GetCurrentAcquisitionRunRequest\x1a+.minknow_api.acquisition.AcquisitionRunInfo\"\x03\x90\x02\x01\x12{\n\x11set_signal_reader\x12/.minknow_api.acquisition.SetSignalReaderRequest\x1a\x30.minknow_api.acquisition.SetSignalReaderResponse\"\x03\x90\x02\x02\x12r\n\x0eset_bream_info\x12,.minknow_api.acquisition.SetBreamInfoRequest\x1a-.minknow_api.acquisition.SetBreamInfoResponse\"\x03\x90\x02\x02\x12{\n\x16\x61ppend_mux_scan_result\x12&.minknow_api.acquisition.MuxScanResult\x1a\x34.minknow_api.acquisition.AppendMuxScanResultResponse\"\x03\x90\x02\x02\x42&\n\x1c\x63om.nanoporetech.minknow_api\xa2\x02\x05MKAPIb\x06proto3')

_MINKNOWSTATUS = DESCRIPTOR.enum_types_by_name['MinknowStatus']
MinknowStatus = enum_type_wrapper.EnumTypeWrapper(_MINKNOWSTATUS)
_OPTION = DESCRIPTOR.enum_types_by_name['Option']
Option = enum_type_wrapper.EnumTypeWrapper(_OPTION)
_PURPOSE = DESCRIPTOR.enum_types_by_name['Purpose']
Purpose = enum_type_wrapper.EnumTypeWrapper(_PURPOSE)
_ACQUISITIONSTATE = DESCRIPTOR.enum_types_by_name['AcquisitionState']
AcquisitionState = enum_type_wrapper.EnumTypeWrapper(_ACQUISITIONSTATE)
_ACQUISITIONSTOPREASON = DESCRIPTOR.enum_types_by_name['AcquisitionStopReason']
AcquisitionStopReason = enum_type_wrapper.EnumTypeWrapper(_ACQUISITIONSTOPREASON)
_STARTUPSTATE = DESCRIPTOR.enum_types_by_name['StartupState']
StartupState = enum_type_wrapper.EnumTypeWrapper(_STARTUPSTATE)
_FINISHINGSTATE = DESCRIPTOR.enum_types_by_name['FinishingState']
FinishingState = enum_type_wrapper.EnumTypeWrapper(_FINISHINGSTATE)
ERROR_STATUS = 0
READY = 1
STARTING = 2
PROCESSING = 3
FINISHING = 4
AUTO = 0
DISABLE = 1
FORCE = 2
OTHER_PURPOSE = 0
SEQUENCING = 2
CALIBRATION = 3
ACQUISITION_STARTING = 0
ACQUISITION_RUNNING = 1
ACQUISITION_FINISHING = 2
ACQUISITION_COMPLETED = 3
STOPPED_NOT_SET = 0
STOPPED_USER_REQUESTED = 1
STOPPED_NO_DISK_SPACE = 2
STOPPED_DEVICE_STOPPED_ACQUISITION = 3
STOPPED_STARTING_ANOTHER_RUN = 4
STOPPED_PROTOCOL_ENDED = 5
STOPPED_DEVICE_ERROR = 6
STOPPED_BAD_TEMPERATURE = 7
STOPPED_SHUTDOWN = 8
STOPPED_INTERNAL_ERROR = 9
STARTUP_UNKNOWN = 0
STARTUP_BUILDING_PIPELINE = 2
STARTUP_INITIALISING_BASECALLER = 3
STARTUP_INITIALISING_BASECALLER_ALIGNMENT = 4
STARTUP_INITIALISING_DATA_WRITERS = 5
STARTUP_INITIALISING_INTERMEDIATE_DATA_STORAGE = 6
STARTUP_INITIALISING_STATISTICS = 7
FINISHING_UNKNOWN = 0
FINISHING_PROCESSING_DEVICE_SIGNAL = 1
FINISHING_BASECALLING_READS = 2
FINISHING_SAVING_DATA = 3


_STARTREQUEST = DESCRIPTOR.message_types_by_name['StartRequest']
_STARTRESPONSE = DESCRIPTOR.message_types_by_name['StartResponse']
_STOPREQUEST = DESCRIPTOR.message_types_by_name['StopRequest']
_STOPRESPONSE = DESCRIPTOR.message_types_by_name['StopResponse']
_WATCHFORSTATUSCHANGEREQUEST = DESCRIPTOR.message_types_by_name['WatchForStatusChangeRequest']
_WATCHFORSTATUSCHANGERESPONSE = DESCRIPTOR.message_types_by_name['WatchForStatusChangeResponse']
_CURRENTSTATUSREQUEST = DESCRIPTOR.message_types_by_name['CurrentStatusRequest']
_CURRENTSTATUSRESPONSE = DESCRIPTOR.message_types_by_name['CurrentStatusResponse']
_GETPROGRESSREQUEST = DESCRIPTOR.message_types_by_name['GetProgressRequest']
_GETPROGRESSRESPONSE = DESCRIPTOR.message_types_by_name['GetProgressResponse']
_GETPROGRESSRESPONSE_RAWPERCHANNEL = _GETPROGRESSRESPONSE.nested_types_by_name['RawPerChannel']
_GETACQUISITIONRUNINFOREQUEST = DESCRIPTOR.message_types_by_name['GetAcquisitionRunInfoRequest']
_ACQUISITIONYIELDSUMMARY = DESCRIPTOR.message_types_by_name['AcquisitionYieldSummary']
_ACQUISITIONWRITERSUMMARY = DESCRIPTOR.message_types_by_name['AcquisitionWriterSummary']
_CHANNELSTATEINFO = DESCRIPTOR.message_types_by_name['ChannelStateInfo']
_CHANNELSTATEINFO_STYLE = _CHANNELSTATEINFO.nested_types_by_name['Style']
_CHANNELSTATEINFO_CHANNELSTATE = _CHANNELSTATEINFO.nested_types_by_name['ChannelState']
_CHANNELSTATEINFO_GROUP = _CHANNELSTATEINFO.nested_types_by_name['Group']
_ACQUISITIONCONFIGSUMMARY = DESCRIPTOR.message_types_by_name['AcquisitionConfigSummary']
_MUXSCANMETADATA = DESCRIPTOR.message_types_by_name['MuxScanMetadata']
_MUXSCANMETADATA_STYLE = _MUXSCANMETADATA.nested_types_by_name['Style']
_MUXSCANMETADATA_CATEGORY = _MUXSCANMETADATA.nested_types_by_name['Category']
_MUXSCANMETADATA_CATEGORYGROUP = _MUXSCANMETADATA.nested_types_by_name['CategoryGroup']
_MUXSCANRESULT = DESCRIPTOR.message_types_by_name['MuxScanResult']
_MUXSCANRESULT_COUNTSENTRY = _MUXSCANRESULT.nested_types_by_name['CountsEntry']
_BREAMINFO = DESCRIPTOR.message_types_by_name['BreamInfo']
_BREAMINFO_RANGE = _BREAMINFO.nested_types_by_name['Range']
_ACQUISITIONRUNINFO = DESCRIPTOR.message_types_by_name['AcquisitionRunInfo']
_LISTACQUISITIONRUNSREQUEST = DESCRIPTOR.message_types_by_name['ListAcquisitionRunsRequest']
_LISTACQUISITIONRUNSRESPONSE = DESCRIPTOR.message_types_by_name['ListAcquisitionRunsResponse']
_GETCURRENTACQUISITIONRUNREQUEST = DESCRIPTOR.message_types_by_name['GetCurrentAcquisitionRunRequest']
_WATCHCURRENTACQUISITIONRUNREQUEST = DESCRIPTOR.message_types_by_name['WatchCurrentAcquisitionRunRequest']
_SETSIGNALREADERREQUEST = DESCRIPTOR.message_types_by_name['SetSignalReaderRequest']
_SETSIGNALREADERRESPONSE = DESCRIPTOR.message_types_by_name['SetSignalReaderResponse']
_SETBREAMINFOREQUEST = DESCRIPTOR.message_types_by_name['SetBreamInfoRequest']
_SETBREAMINFORESPONSE = DESCRIPTOR.message_types_by_name['SetBreamInfoResponse']
_APPENDMUXSCANRESULTRESPONSE = DESCRIPTOR.message_types_by_name['AppendMuxScanResultResponse']
_STOPREQUEST_DATAACTION = _STOPREQUEST.enum_types_by_name['DataAction']
_SETSIGNALREADERREQUEST_SIGNALREADERTYPE = _SETSIGNALREADERREQUEST.enum_types_by_name['SignalReaderType']
_SETSIGNALREADERREQUEST_SOURCEFILEMODE = _SETSIGNALREADERREQUEST.enum_types_by_name['SourceFileMode']
StartRequest = _reflection.GeneratedProtocolMessageType('StartRequest', (_message.Message,), {
  'DESCRIPTOR' : _STARTREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      dont_wait_for_device_ready:
          Prevent waiting until the device is ready before starting
          acquisition.  Defaults to false.  By default, MinKNOW will
          block in the start() call for the device and flow cell to be
          ready for acquisition (which may take several seconds after
          plugging in the flow cell on some devices). Setting this
          option will cause the call to return with an error if the
          device is not already prepared to acquire data.  Since 1.14
      generate_report:
          Generate duty time and throughput reports.  Note that this
          setting will be ignored (and no reports will be generated) if
          no protocol is running at the time acquisition is started.
          The default setting (AUTO) will only generate reports if
          purpose is set to SEQUENCING.  Since 3.0
      send_sequencing_read_metrics:
          Whether sequencing read metrics should be reported to Oxford
          Nanopore.  These are performance metrics that are used to
          improve the sequencing technology. They do not include any
          actual sequencing data, only statistics about read lengths,
          duty time and similar generic performance information.  The
          default setting (AUTO) will only send metrics if purpose is
          set to SEQUENCING.  Since 3.0
      send_basecalling_metrics:
          Whether basecalling metrics should be reported to Oxford
          Nanopore.  These are performance metrics that are used to
          improve the sequencing technology. They do not include any
          actual sequencing data, only statistics about basecalling
          performance.  The default setting (AUTO) will only send
          metrics if purpose is set to SEQUENCING.  NB: this setting is
          ignored if live basecalling is not enabled, since there will
          be no metrics to send.  Since 3.2
      purpose:
          Specify the purpose of this acquisition period.  This affects
          various defaults (see the Purpose enum documentation for more
          details). It may also affect how the user interface presents
          the state of the protocol.  Since 3.2
      analysis:
          Perform analysis for this acquisition period.  If this is
          disabled, no reads, no events, no channel states and no
          basecalls will be generated. Any RPCs that depend on any of
          these will fail. No reads-based files will be produced at all,
          regardless of any other settings.  This is mostly useful for
          calibration (although you should normally use the purpose
          field rather than setting this explicitly).  The default
          setting (AUTO) will use the persistent setting from the
          analysis_configuraiton service, unless the purpose is set to
          CALIBRATION.  Since 3.2
      file_output:
          Allow file output for this acquisition period.  If this is
          disabled, the file output settings will be ignored for this
          acquisition period, and no data files will be produced. Note
          that reports are NOT managed by this setting.  Note that
          setting this to FORCE will simply make file output respect the
          bulk and read writer configurations. If each file output type
          is disabled, you will still get no file output.  This is
          mostly useful for calibration (although you should normally
          use the purpose field rather than setting this explicitly).
          The default setting (AUTO) will only suppress file output if
          purpose is set to CALIBRATION.  Since 3.2
      generate_final_summary:
          Write a final_summary.txt file.  If file_output is disabled,
          the final_summary.txt file will not be written regardless of
          this setting.  The default setting (AUTO) will only enable
          writing a final_summary.txt file if the purpose is set to
          SEQUENCING.  Since 3.5 (NB: in 3.3 and 3.4, final_summary.txt
          was always written out if file_output was enabled).
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.StartRequest)
  })
_sym_db.RegisterMessage(StartRequest)

StartResponse = _reflection.GeneratedProtocolMessageType('StartResponse', (_message.Message,), {
  'DESCRIPTOR' : _STARTRESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      run_id:
          Globally-unique identifier generated when the acquisition is
          started.  This is guaranteed to unique, including aross
          sequencing devices.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.StartResponse)
  })
_sym_db.RegisterMessage(StartResponse)

StopRequest = _reflection.GeneratedProtocolMessageType('StopRequest', (_message.Message,), {
  'DESCRIPTOR' : _STOPREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      wait_until_ready:
          Defaults to false If false will return as soon as minknow
          enters the FINISHING state. If true then returns as soon as
          minknow enters the READY state.
      keep_power_on:
          Force the MinION/GridION ASIC power to be kept on after the
          current acquisition finishes  Keeping the ASIC power on has
          two main effects:       - The flow-cell will remain at the
          correct operating temperature between acquisitions;
          this allows following acquisition to be started more quickly.
          - MinION/GridION flow cells may be damaged if they are removed
          or plugged in while the        ASIC power is turned on.
          Therefore, this option should be set to `true` if and only if
          another acquisition will be performed using the same flow-
          cell, soon after the acquisition that is being stopped.
          Otherwise it should be set to `false` (or left unset) to
          prevent potential damage to MinION/GridION flow-cells.  If
          this option is set to `false` (or is left unset), then the
          application configuration determines whether the power will be
          left on when the acquisition finishes -- see the
          `powered_when_idle` and `flongle_powered_when_idle`
          configuration options for further details.  This option has no
          effect on PromethIONs.  Since 1.15.2
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.StopRequest)
  })
_sym_db.RegisterMessage(StopRequest)

StopResponse = _reflection.GeneratedProtocolMessageType('StopResponse', (_message.Message,), {
  'DESCRIPTOR' : _STOPRESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.StopResponse)
  })
_sym_db.RegisterMessage(StopResponse)

WatchForStatusChangeRequest = _reflection.GeneratedProtocolMessageType('WatchForStatusChangeRequest', (_message.Message,), {
  'DESCRIPTOR' : _WATCHFORSTATUSCHANGEREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.WatchForStatusChangeRequest)
  })
_sym_db.RegisterMessage(WatchForStatusChangeRequest)

WatchForStatusChangeResponse = _reflection.GeneratedProtocolMessageType('WatchForStatusChangeResponse', (_message.Message,), {
  'DESCRIPTOR' : _WATCHFORSTATUSCHANGERESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.WatchForStatusChangeResponse)
  })
_sym_db.RegisterMessage(WatchForStatusChangeResponse)

CurrentStatusRequest = _reflection.GeneratedProtocolMessageType('CurrentStatusRequest', (_message.Message,), {
  'DESCRIPTOR' : _CURRENTSTATUSREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.CurrentStatusRequest)
  })
_sym_db.RegisterMessage(CurrentStatusRequest)

CurrentStatusResponse = _reflection.GeneratedProtocolMessageType('CurrentStatusResponse', (_message.Message,), {
  'DESCRIPTOR' : _CURRENTSTATUSRESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.CurrentStatusResponse)
  })
_sym_db.RegisterMessage(CurrentStatusResponse)

GetProgressRequest = _reflection.GeneratedProtocolMessageType('GetProgressRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETPROGRESSREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.GetProgressRequest)
  })
_sym_db.RegisterMessage(GetProgressRequest)

GetProgressResponse = _reflection.GeneratedProtocolMessageType('GetProgressResponse', (_message.Message,), {

  'RawPerChannel' : _reflection.GeneratedProtocolMessageType('RawPerChannel', (_message.Message,), {
    'DESCRIPTOR' : _GETPROGRESSRESPONSE_RAWPERCHANNEL,
    '__module__' : 'minknow_api.acquisition_pb2'
    ,
    '__doc__': """Attributes:
        acquired:
            Number of samples (per channel) acquired from the device.
        processed:
            Number of samples (per channel) passed to the analysis
            pipeline for processing.  This can be compared to acquired to
            see how far behind the analysis is lagging.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.GetProgressResponse.RawPerChannel)
    })
  ,
  'DESCRIPTOR' : _GETPROGRESSRESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      raw_per_channel:
          The amount of raw data (per channel) that has been acquired
          and processed.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.GetProgressResponse)
  })
_sym_db.RegisterMessage(GetProgressResponse)
_sym_db.RegisterMessage(GetProgressResponse.RawPerChannel)

GetAcquisitionRunInfoRequest = _reflection.GeneratedProtocolMessageType('GetAcquisitionRunInfoRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETACQUISITIONRUNINFOREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      run_id:
          The acquisition period to get information about.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.GetAcquisitionRunInfoRequest)
  })
_sym_db.RegisterMessage(GetAcquisitionRunInfoRequest)

AcquisitionYieldSummary = _reflection.GeneratedProtocolMessageType('AcquisitionYieldSummary', (_message.Message,), {
  'DESCRIPTOR' : _ACQUISITIONYIELDSUMMARY,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      read_count:
          Number of reads selected by analysis as good reads.  The reads
          in this counter are completed, but not necessarily on disk
          yet.
      fraction_basecalled:
          This is the fraction of whole reads that the base-caller has
          finished with. The value should be in the range [0.0, 1.0]
          When base-calling is enabled, it can be added to
          fraction_skipped and multiplied by 100 to give the percentage
          of reads processed and by implication, the percentage of reads
          the user is waiting for the base-caller to process.  Since 5.0
      fraction_skipped:
          This is the fraction of whole reads that have been skipped.
          The value should be in the range [0.0, 1.0]  Since 5.0
      basecalled_pass_read_count:
          Number of reads successfully basecalled.
      basecalled_fail_read_count:
          Number of reads which have failed to basecall.
      basecalled_skipped_read_count:
          Number of reads which have been skipped
      basecalled_pass_bases:
          Number of bases which have been called and classed as pass.
      basecalled_fail_bases:
          Number of bases which have been called and were classed as
          fail.
      basecalled_samples:
          Number of raw samples which have been called.
      selected_raw_samples:
          Number of minknow raw samples which have been selected for
          writing to disk as reads.
      selected_events:
          Number of minknow events which have been selected for writing
          to disk as reads.
      estimated_selected_bases:
          Estimated number of bases MinKNOW has selected for writing.
          This is estimated based on already called bases and samples.
      alignment_matches:
          Number of bases which have matched target reference.  Only
          specified when running live alignment.  Since 4.0
      alignment_mismatches:
          Number of bases which have not matched target reference.  Only
          specified when running live alignment.  Since 4.0
      alignment_insertions:
          Number of bases which were inserted into alignments that
          matched the reference.  Only specified when running live
          alignment.  Since 4.0
      alignment_deletions:
          Number of bases which were deleted from alignments that
          matched the reference.  Only specified when running live
          alignment.  Since 4.0
      alignment_coverage:
          Number of bases that match the target reference(s) expressed
          as a fraction of the total size of the target reference(s).
          eg: For a specified alignment-targets with 2000 and 3000
          bases, if "alignment_matches" is 2500, then
          "alignment_coverage" will be 0.5  Since 4.3
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.AcquisitionYieldSummary)
  })
_sym_db.RegisterMessage(AcquisitionYieldSummary)

AcquisitionWriterSummary = _reflection.GeneratedProtocolMessageType('AcquisitionWriterSummary', (_message.Message,), {
  'DESCRIPTOR' : _ACQUISITIONWRITERSUMMARY,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      bytes_to_write_produced:
          Number of bytes which minknow needs to write in order to
          finish the experiment.
      bytes_to_write_failed:
          Number of bytes which minknow has failed to write to final
          location. These reads are instead contained in the
          fallback/tmp locations.
      bytes_to_write_completed:
          Number of bytes which minknow has written to final location.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.AcquisitionWriterSummary)
  })
_sym_db.RegisterMessage(AcquisitionWriterSummary)

ChannelStateInfo = _reflection.GeneratedProtocolMessageType('ChannelStateInfo', (_message.Message,), {

  'Style' : _reflection.GeneratedProtocolMessageType('Style', (_message.Message,), {
    'DESCRIPTOR' : _CHANNELSTATEINFO_STYLE,
    '__module__' : 'minknow_api.acquisition_pb2'
    ,
    '__doc__': """Attributes:
        label:
            The human-readable name to display when rendering this channel
            state or group.
        description:
            A sentence describing the meaning of the channel state or
            group.  This can be used as a tooltip, for example.
        colour:
            The colour to use when rendering this channel state or group.
            This is a six-digit hex string describing an RGB colour (eg:
            "ff00ff" for purple).
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.ChannelStateInfo.Style)
    })
  ,

  'ChannelState' : _reflection.GeneratedProtocolMessageType('ChannelState', (_message.Message,), {
    'DESCRIPTOR' : _CHANNELSTATEINFO_CHANNELSTATE,
    '__module__' : 'minknow_api.acquisition_pb2'
    ,
    '__doc__': """Attributes:
        id:
            The numeric identifier of the state.  This is what is reported
            in any other APIs that return a channel state ID.
        name:
            The internal name of the state.  This is what is reported in
            any other APIs that return a channel state name.
        style:
            How to render the channel state in a graphical user interface.
            Note that the style may be missing from some channel states
            (such as the ones that are built in to MinKNOW).
        global_order:
            An order ranking for the channel states when they are
            ungrouped.  This can be used to order the channel states after
            merging the groups.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.ChannelStateInfo.ChannelState)
    })
  ,

  'Group' : _reflection.GeneratedProtocolMessageType('Group', (_message.Message,), {
    'DESCRIPTOR' : _CHANNELSTATEINFO_GROUP,
    '__module__' : 'minknow_api.acquisition_pb2'
    ,
    '__doc__': """Attributes:
        name:
            The name of the group.
        style:
            How to render the group in a graphical user interface.  Note
            that the style may be missing from some groups (such as the
            ones that are built in to MinKNOW).
        states:
            The channel states contained in the group.  The groups are
            ordered according to the "order" attribute of the channel
            state style in the channel states configuration.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.ChannelStateInfo.Group)
    })
  ,
  'DESCRIPTOR' : _CHANNELSTATEINFO,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      groups:
          The groups of channel states.  The groups are ordered
          according to the "order" attribute of the group style in the
          channel states configuration.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.ChannelStateInfo)
  })
_sym_db.RegisterMessage(ChannelStateInfo)
_sym_db.RegisterMessage(ChannelStateInfo.Style)
_sym_db.RegisterMessage(ChannelStateInfo.ChannelState)
_sym_db.RegisterMessage(ChannelStateInfo.Group)

AcquisitionConfigSummary = _reflection.GeneratedProtocolMessageType('AcquisitionConfigSummary', (_message.Message,), {
  'DESCRIPTOR' : _ACQUISITIONCONFIGSUMMARY,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      purpose:
          The purpose, as supplied to `acquisition.start()`
      basecalling_enabled:
          Was basecalling enabled for the run.
      basecalling_config_filename:
          Basecalling configuration filename (if basecalling enabled)
      barcoding_enabled:
          Is barcoding enabled for the run
      barcoding_kits:
          / Barcoding kit(s) used (if barcoding enabled)
      alignment_enabled:
          Is alignment enabled for the run
      alignment_reference_files:
          Alignment reference file(s) used (if alignment enabled)
      alignment_bed_file:
          bed file used (if alignment enabled, and bed file specified)
      lamp_enabled:
          Is lamp enabled for the run
      lamp_kit:
          The LAMP kit used (if LAMP enabled)
      reads_directory:
          Root directory reads were written to for the run.  Empty if no
          reads were enabled.
      reads_fallback_directories:
          Directories reads are written to if the reads_directory is on
          the network and writes to it fail.  Empty if no reads were
          enabled.
      fast5_reads_enabled:
          Determine if fast5 reads were enabled for the run.
      fastq_reads_enabled:
          Determine if fastq reads were enabled for the run.
      protobuf_reads_enabled:
          Determine if protobuf reads were enabled for the run.
      bulk_file_path:
          The path of the bulk file for the run.  Empty if no reads were
          enabled.
      bulk_file_enabled:
          Find if the bulk writer was enabled for a run.
      channel_state_info:
          Channel state styling information
      events_to_base_ratio:
          Number of bases per event
      sample_rate:
          Sample rate for the acquisition.  Since 3.3
      channel_count:
          Channel count used in the acquisition.  Since 3.3
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.AcquisitionConfigSummary)
  })
_sym_db.RegisterMessage(AcquisitionConfigSummary)

MuxScanMetadata = _reflection.GeneratedProtocolMessageType('MuxScanMetadata', (_message.Message,), {

  'Style' : _reflection.GeneratedProtocolMessageType('Style', (_message.Message,), {
    'DESCRIPTOR' : _MUXSCANMETADATA_STYLE,
    '__module__' : 'minknow_api.acquisition_pb2'
    ,
    '__doc__': """Presentation information for a category or group.
    
    Attributes:
        label:
            The human-readable name to display when rendering this
            category or group.
        description:
            A sentence describing the meaning of the category or group.
            This can be used as a tooltip, for example.
        colour:
            The colour to use when rendering this category or group.  This
            is a six-digit hex string describing an RGB colour (eg:
            "ff0000" for red).
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.MuxScanMetadata.Style)
    })
  ,

  'Category' : _reflection.GeneratedProtocolMessageType('Category', (_message.Message,), {
    'DESCRIPTOR' : _MUXSCANMETADATA_CATEGORY,
    '__module__' : 'minknow_api.acquisition_pb2'
    ,
    '__doc__': """A category that a channel mux can be assigned.
    
    Attributes:
        name:
            Name of the category.  This is the value that will be in the
            `MuxScanResult.counts` field.  The user should not be shown
            this. Instead, `style.label` should be displayed.
        style:
            How to render the category in a graphical user interface.
        global_order:
            An order ranking for the category when displaying them without
            using groups.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.MuxScanMetadata.Category)
    })
  ,

  'CategoryGroup' : _reflection.GeneratedProtocolMessageType('CategoryGroup', (_message.Message,), {
    'DESCRIPTOR' : _MUXSCANMETADATA_CATEGORYGROUP,
    '__module__' : 'minknow_api.acquisition_pb2'
    ,
    '__doc__': """Attributes:
        name:
            The name of the group.
        style:
            How to render the group in a graphical user interface.
        category:
            The categories contained in the group.  Within this group,
            categories should be presented in the order of this list.
    """,
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.MuxScanMetadata.CategoryGroup)
    })
  ,
  'DESCRIPTOR' : _MUXSCANMETADATA,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Provides information about how mux scans are configured.  This
  primarily information to help present mux scan results to the user
  (see `MuxScanResult`).
  
  Attributes:
      auto_mux_scan_period_hours:
          How frequently automatic scans are scheduled to occur.
      category_groups:
          Presentation information for categories.  Describes the
          preferred way to present mux scan categories to users. Groups
          should be presented in the order of this list.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.MuxScanMetadata)
  })
_sym_db.RegisterMessage(MuxScanMetadata)
_sym_db.RegisterMessage(MuxScanMetadata.Style)
_sym_db.RegisterMessage(MuxScanMetadata.Category)
_sym_db.RegisterMessage(MuxScanMetadata.CategoryGroup)

MuxScanResult = _reflection.GeneratedProtocolMessageType('MuxScanResult', (_message.Message,), {

  'CountsEntry' : _reflection.GeneratedProtocolMessageType('CountsEntry', (_message.Message,), {
    'DESCRIPTOR' : _MUXSCANRESULT_COUNTSENTRY,
    '__module__' : 'minknow_api.acquisition_pb2'
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.MuxScanResult.CountsEntry)
    })
  ,
  'DESCRIPTOR' : _MUXSCANRESULT,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """A report of the states of channel muxes (wells) across the flow cell.
  Every channel mux (well) is assigned to a specific category describing
  its state (for example, is it expected to produce good results, and if
  not why not?). This is a report of how many channel muxes are in each
  category.
  
  Attributes:
      counts:
          How many channel muxes are in each category.  The sum of all
          the values in this map should be the number of channels
          multiplied by the number of muxes on each channel (eg:
          512x4=2048 on a MinION Mk1B without a flongle adapter).  eg.
          'sequencing': 1500
      mux_scan_timestamp:
          When this mux scan result was added (Seconds since the start
          of the acquisition).
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.MuxScanResult)
  })
_sym_db.RegisterMessage(MuxScanResult)
_sym_db.RegisterMessage(MuxScanResult.CountsEntry)

BreamInfo = _reflection.GeneratedProtocolMessageType('BreamInfo', (_message.Message,), {

  'Range' : _reflection.GeneratedProtocolMessageType('Range', (_message.Message,), {
    'DESCRIPTOR' : _BREAMINFO_RANGE,
    '__module__' : 'minknow_api.acquisition_pb2'
    ,
    '__doc__': """Represents a range of values.""",
    # @@protoc_insertion_point(class_scope:minknow_api.acquisition.BreamInfo.Range)
    })
  ,
  'DESCRIPTOR' : _BREAMINFO,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Information provided by Bream.  Note that this is provided by the
  protocol, and some protocols may choose not to provide this.
  
  Attributes:
      mux_scan_metadata:
          Presentation information for mux scan results.
      mux_scan_results:
          Mux scan results.
      target_translocation_speed:
          The ideal translocation speed range.  This can be used to
          provide context for speed graphs (see the statistics RPCs),
          showing what range is considered "good".
      target_q_score:
          The ideal quality (Q) score range.  This can be used to
          provide context for q-score graphs (see the statistics RPCs),
          showing what range is considered "good".
      target_temperature:
          The ideal temperature range.  This can be used to provide
          context for temperature (see the statistics RPCs), showing
          what range is considered "good".  Note that a protocol may
          request a different temperature range than this (eg: it might
          request a tighter range, or it may adjust the temperature it
          is requesting throughout the run). This intended only to
          provide context when presenting data to users.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.BreamInfo)
  })
_sym_db.RegisterMessage(BreamInfo)
_sym_db.RegisterMessage(BreamInfo.Range)

AcquisitionRunInfo = _reflection.GeneratedProtocolMessageType('AcquisitionRunInfo', (_message.Message,), {
  'DESCRIPTOR' : _ACQUISITIONRUNINFO,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      run_id:
          The unique identifier assigned to this acquisition run.  This
          is guaranteed to be made of ASCII characters, and at most 40
          characters. It is globally unique across all acquisitions on
          all MinKNOW instances.
      startup_state:
          Current startup task (or STARTUP_UNKNOWN if not starting up).
      startup_state_estimated_end:
          Estimated time for current startup state to end.  In some
          cases this field is left unset, to indicate no estimation.
      startup_state_estimated_percent_complete:
          Estimate startup state completion percent (0 - 1).  In some
          cases this field is left at 0, indicating no estimation.
      state:
          Indicates the current state of the acquisition.
      finishing_state:
          If the experiment is finishing, an extra piece of state
          describing the current finishing state.
      stop_reason:
          The reason the acquisition period was ended.
      start_time:
          When the acquisition period was started (UTC).
      data_read_start_time:
          When MinKNOW began acquiring data (UTC).  Unset if the
          acquisition is still starting up.
      data_read_end_time:
          When the MinKNOW stopped acquiring data (UTC).  Unset if the
          acquisition is still acquiring.
      end_time:
          When the acquisition terminated (UTC).  Unset if the
          acquisition period is still running.
      yield_summary:
          Summary of acquisition yields.  Since 1.12
      config_summary:
          Summary of the configuration settings for a run.  Since 1.14
      writer_summary:
          Summary of writer yields.  Since 4.0
      bream_info:
          Set information provided by the Bream toolkit.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.AcquisitionRunInfo)
  })
_sym_db.RegisterMessage(AcquisitionRunInfo)

ListAcquisitionRunsRequest = _reflection.GeneratedProtocolMessageType('ListAcquisitionRunsRequest', (_message.Message,), {
  'DESCRIPTOR' : _LISTACQUISITIONRUNSREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.ListAcquisitionRunsRequest)
  })
_sym_db.RegisterMessage(ListAcquisitionRunsRequest)

ListAcquisitionRunsResponse = _reflection.GeneratedProtocolMessageType('ListAcquisitionRunsResponse', (_message.Message,), {
  'DESCRIPTOR' : _LISTACQUISITIONRUNSRESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.ListAcquisitionRunsResponse)
  })
_sym_db.RegisterMessage(ListAcquisitionRunsResponse)

GetCurrentAcquisitionRunRequest = _reflection.GeneratedProtocolMessageType('GetCurrentAcquisitionRunRequest', (_message.Message,), {
  'DESCRIPTOR' : _GETCURRENTACQUISITIONRUNREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.GetCurrentAcquisitionRunRequest)
  })
_sym_db.RegisterMessage(GetCurrentAcquisitionRunRequest)

WatchCurrentAcquisitionRunRequest = _reflection.GeneratedProtocolMessageType('WatchCurrentAcquisitionRunRequest', (_message.Message,), {
  'DESCRIPTOR' : _WATCHCURRENTACQUISITIONRUNREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.WatchCurrentAcquisitionRunRequest)
  })
_sym_db.RegisterMessage(WatchCurrentAcquisitionRunRequest)

SetSignalReaderRequest = _reflection.GeneratedProtocolMessageType('SetSignalReaderRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETSIGNALREADERREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      reader:
          The type of signal reader to use
      hdf_source:
          The following settings are optional, and only used when
          setting the reader to hdf5
      hdf_mode:
           Defaults to UNSPECIFIED, since this setting is optional
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.SetSignalReaderRequest)
  })
_sym_db.RegisterMessage(SetSignalReaderRequest)

SetSignalReaderResponse = _reflection.GeneratedProtocolMessageType('SetSignalReaderResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETSIGNALREADERRESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.SetSignalReaderResponse)
  })
_sym_db.RegisterMessage(SetSignalReaderResponse)

SetBreamInfoRequest = _reflection.GeneratedProtocolMessageType('SetBreamInfoRequest', (_message.Message,), {
  'DESCRIPTOR' : _SETBREAMINFOREQUEST,
  '__module__' : 'minknow_api.acquisition_pb2'
  ,
  '__doc__': """Attributes:
      info:
          The information to set.  Note that, other than treating the
          top-level fields independently (see the other flags on this
          request), MinKNOW Core will not do anything special to the
          data. In particular, the caller must fill in the
          `mux_scan_timestamp` field in `MuxScanResult` messages.
      overwrite_unset_fields:
          If any `BreamInfo` fields were set in a previous call, but are
          unset in the `info` field of this call, then use the old value
          for them.  For example, to just update the mux_scan_metadata
          field, use a BreamInfo object with only the
          `mux_scan_metadata` field set, and leave this as False. To
          clear the entire BreamInfo structure, leave `info` empty and
          set this to True.
  """,
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.SetBreamInfoRequest)
  })
_sym_db.RegisterMessage(SetBreamInfoRequest)

SetBreamInfoResponse = _reflection.GeneratedProtocolMessageType('SetBreamInfoResponse', (_message.Message,), {
  'DESCRIPTOR' : _SETBREAMINFORESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.SetBreamInfoResponse)
  })
_sym_db.RegisterMessage(SetBreamInfoResponse)

AppendMuxScanResultResponse = _reflection.GeneratedProtocolMessageType('AppendMuxScanResultResponse', (_message.Message,), {
  'DESCRIPTOR' : _APPENDMUXSCANRESULTRESPONSE,
  '__module__' : 'minknow_api.acquisition_pb2'
  # @@protoc_insertion_point(class_scope:minknow_api.acquisition.AppendMuxScanResultResponse)
  })
_sym_db.RegisterMessage(AppendMuxScanResultResponse)

_ACQUISITIONSERVICE = DESCRIPTOR.services_by_name['AcquisitionService']
if _descriptor._USE_C_DESCRIPTORS == False:

  DESCRIPTOR._options = None
  DESCRIPTOR._serialized_options = b'\n\034com.nanoporetech.minknow_api\242\002\005MKAPI'
  _MUXSCANRESULT_COUNTSENTRY._options = None
  _MUXSCANRESULT_COUNTSENTRY._serialized_options = b'8\001'
  _SETSIGNALREADERREQUEST.fields_by_name['reader']._options = None
  _SETSIGNALREADERREQUEST.fields_by_name['reader']._serialized_options = b'\210\265\030\001'
  _ACQUISITIONSERVICE.methods_by_name['watch_for_status_change']._options = None
  _ACQUISITIONSERVICE.methods_by_name['watch_for_status_change']._serialized_options = b'\220\002\001'
  _ACQUISITIONSERVICE.methods_by_name['watch_current_acquisition_run']._options = None
  _ACQUISITIONSERVICE.methods_by_name['watch_current_acquisition_run']._serialized_options = b'\220\002\001'
  _ACQUISITIONSERVICE.methods_by_name['current_status']._options = None
  _ACQUISITIONSERVICE.methods_by_name['current_status']._serialized_options = b'\220\002\001'
  _ACQUISITIONSERVICE.methods_by_name['get_progress']._options = None
  _ACQUISITIONSERVICE.methods_by_name['get_progress']._serialized_options = b'\220\002\001'
  _ACQUISITIONSERVICE.methods_by_name['get_acquisition_info']._options = None
  _ACQUISITIONSERVICE.methods_by_name['get_acquisition_info']._serialized_options = b'\220\002\001'
  _ACQUISITIONSERVICE.methods_by_name['list_acquisition_runs']._options = None
  _ACQUISITIONSERVICE.methods_by_name['list_acquisition_runs']._serialized_options = b'\220\002\001'
  _ACQUISITIONSERVICE.methods_by_name['get_current_acquisition_run']._options = None
  _ACQUISITIONSERVICE.methods_by_name['get_current_acquisition_run']._serialized_options = b'\220\002\001'
  _ACQUISITIONSERVICE.methods_by_name['set_signal_reader']._options = None
  _ACQUISITIONSERVICE.methods_by_name['set_signal_reader']._serialized_options = b'\220\002\002'
  _ACQUISITIONSERVICE.methods_by_name['set_bream_info']._options = None
  _ACQUISITIONSERVICE.methods_by_name['set_bream_info']._serialized_options = b'\220\002\002'
  _ACQUISITIONSERVICE.methods_by_name['append_mux_scan_result']._options = None
  _ACQUISITIONSERVICE.methods_by_name['append_mux_scan_result']._serialized_options = b'\220\002\002'
  _MINKNOWSTATUS._serialized_start=5765
  _MINKNOWSTATUS._serialized_end=5854
  _OPTION._serialized_start=5856
  _OPTION._serialized_end=5898
  _PURPOSE._serialized_start=5900
  _PURPOSE._serialized_end=5961
  _ACQUISITIONSTATE._serialized_start=5963
  _ACQUISITIONSTATE._serialized_end=6086
  _ACQUISITIONSTOPREASON._serialized_start=6089
  _ACQUISITIONSTOPREASON._serialized_end=6395
  _STARTUPSTATE._serialized_start=6398
  _STARTUPSTATE._serialized_end=6676
  _FINISHINGSTATE._serialized_start=6679
  _FINISHINGSTATE._serialized_end=6818
  _STARTREQUEST._serialized_start=123
  _STARTREQUEST._serialized_end=590
  _STARTRESPONSE._serialized_start=592
  _STARTRESPONSE._serialized_end=623
  _STOPREQUEST._serialized_start=626
  _STOPREQUEST._serialized_end=850
  _STOPREQUEST_DATAACTION._serialized_start=768
  _STOPREQUEST_DATAACTION._serialized_end=850
  _STOPRESPONSE._serialized_start=852
  _STOPRESPONSE._serialized_end=866
  _WATCHFORSTATUSCHANGEREQUEST._serialized_start=868
  _WATCHFORSTATUSCHANGEREQUEST._serialized_end=911
  _WATCHFORSTATUSCHANGERESPONSE._serialized_start=913
  _WATCHFORSTATUSCHANGERESPONSE._serialized_end=999
  _CURRENTSTATUSREQUEST._serialized_start=1001
  _CURRENTSTATUSREQUEST._serialized_end=1023
  _CURRENTSTATUSRESPONSE._serialized_start=1025
  _CURRENTSTATUSRESPONSE._serialized_end=1104
  _GETPROGRESSREQUEST._serialized_start=1106
  _GETPROGRESSREQUEST._serialized_end=1126
  _GETPROGRESSRESPONSE._serialized_start=1129
  _GETPROGRESSRESPONSE._serialized_end=1289
  _GETPROGRESSRESPONSE_RAWPERCHANNEL._serialized_start=1237
  _GETPROGRESSRESPONSE_RAWPERCHANNEL._serialized_end=1289
  _GETACQUISITIONRUNINFOREQUEST._serialized_start=1291
  _GETACQUISITIONRUNINFOREQUEST._serialized_end=1337
  _ACQUISITIONYIELDSUMMARY._serialized_start=1340
  _ACQUISITIONYIELDSUMMARY._serialized_end=1874
  _ACQUISITIONWRITERSUMMARY._serialized_start=1877
  _ACQUISITIONWRITERSUMMARY._serialized_end=2027
  _CHANNELSTATEINFO._serialized_start=2030
  _CHANNELSTATEINFO._serialized_end=2462
  _CHANNELSTATEINFO_STYLE._serialized_start=2115
  _CHANNELSTATEINFO_STYLE._serialized_end=2174
  _CHANNELSTATEINFO_CHANNELSTATE._serialized_start=2176
  _CHANNELSTATEINFO_CHANNELSTATE._serialized_end=2302
  _CHANNELSTATEINFO_GROUP._serialized_start=2305
  _CHANNELSTATEINFO_GROUP._serialized_end=2462
  _ACQUISITIONCONFIGSUMMARY._serialized_start=2465
  _ACQUISITIONCONFIGSUMMARY._serialized_end=3136
  _MUXSCANMETADATA._serialized_start=3139
  _MUXSCANMETADATA._serialized_end=3609
  _MUXSCANMETADATA_STYLE._serialized_start=2115
  _MUXSCANMETADATA_STYLE._serialized_end=2174
  _MUXSCANMETADATA_CATEGORY._serialized_start=3336
  _MUXSCANMETADATA_CATEGORY._serialized_end=3445
  _MUXSCANMETADATA_CATEGORYGROUP._serialized_start=3448
  _MUXSCANMETADATA_CATEGORYGROUP._serialized_end=3609
  _MUXSCANRESULT._serialized_start=3612
  _MUXSCANRESULT._serialized_end=3770
  _MUXSCANRESULT_COUNTSENTRY._serialized_start=3725
  _MUXSCANRESULT_COUNTSENTRY._serialized_end=3770
  _BREAMINFO._serialized_start=3773
  _BREAMINFO._serialized_end=4176
  _BREAMINFO_RANGE._serialized_start=4135
  _BREAMINFO_RANGE._serialized_end=4176
  _ACQUISITIONRUNINFO._serialized_start=4179
  _ACQUISITIONRUNINFO._serialized_end=5072
  _LISTACQUISITIONRUNSREQUEST._serialized_start=5074
  _LISTACQUISITIONRUNSREQUEST._serialized_end=5102
  _LISTACQUISITIONRUNSRESPONSE._serialized_start=5104
  _LISTACQUISITIONRUNSRESPONSE._serialized_end=5150
  _GETCURRENTACQUISITIONRUNREQUEST._serialized_start=5152
  _GETCURRENTACQUISITIONRUNREQUEST._serialized_end=5185
  _WATCHCURRENTACQUISITIONRUNREQUEST._serialized_start=5187
  _WATCHCURRENTACQUISITIONRUNREQUEST._serialized_end=5222
  _SETSIGNALREADERREQUEST._serialized_start=5225
  _SETSIGNALREADERREQUEST._serialized_end=5576
  _SETSIGNALREADERREQUEST_SIGNALREADERTYPE._serialized_start=5475
  _SETSIGNALREADERREQUEST_SIGNALREADERTYPE._serialized_end=5515
  _SETSIGNALREADERREQUEST_SOURCEFILEMODE._serialized_start=5517
  _SETSIGNALREADERREQUEST_SOURCEFILEMODE._serialized_end=5576
  _SETSIGNALREADERRESPONSE._serialized_start=5578
  _SETSIGNALREADERRESPONSE._serialized_end=5603
  _SETBREAMINFOREQUEST._serialized_start=5605
  _SETBREAMINFOREQUEST._serialized_end=5708
  _SETBREAMINFORESPONSE._serialized_start=5710
  _SETBREAMINFORESPONSE._serialized_end=5732
  _APPENDMUXSCANRESULTRESPONSE._serialized_start=5734
  _APPENDMUXSCANRESULTRESPONSE._serialized_end=5763
  _ACQUISITIONSERVICE._serialized_start=6821
  _ACQUISITIONSERVICE._serialized_end=8313
# @@protoc_insertion_point(module_scope)
