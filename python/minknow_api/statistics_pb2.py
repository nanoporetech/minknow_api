# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: minknow_api/statistics.proto
# Protobuf Python Version: 4.25.0
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from minknow_api import acquisition_pb2 as minknow__api_dot_acquisition__pb2
from minknow_api import rpc_options_pb2 as minknow__api_dot_rpc__options__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1cminknow_api/statistics.proto\x12\x16minknow_api.statistics\x1a\x1dminknow_api/acquisition.proto\x1a\x1dminknow_api/rpc_options.proto\"9\n\rDataSelection\x12\r\n\x05start\x18\x01 \x01(\x03\x12\x0c\n\x04step\x18\x02 \x01(\x04\x12\x0b\n\x03\x65nd\x18\x03 \x01(\x03\"h\n\x12\x46loatDataSelection\x12\x12\n\x05start\x18\x01 \x01(\x02H\x00\x88\x01\x01\x12\x11\n\x04step\x18\x02 \x01(\x02H\x01\x88\x01\x01\x12\x10\n\x03\x65nd\x18\x03 \x01(\x02H\x02\x88\x01\x01\x42\x08\n\x06_startB\x07\n\x05_stepB\x06\n\x04_end\"x\n\x15StreamDutyTimeRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\x12=\n\x0e\x64\x61ta_selection\x18\x02 \x01(\x0b\x32%.minknow_api.statistics.DataSelection\"\x91\x03\n\x16StreamDutyTimeResponse\x12Q\n\rbucket_ranges\x18\x01 \x03(\x0b\x32:.minknow_api.statistics.StreamDutyTimeResponse.BucketRange\x12Y\n\x0e\x63hannel_states\x18\x02 \x03(\x0b\x32\x41.minknow_api.statistics.StreamDutyTimeResponse.ChannelStatesEntry\x1a)\n\x0b\x42ucketRange\x12\r\n\x05start\x18\x01 \x01(\r\x12\x0b\n\x03\x65nd\x18\x02 \x01(\r\x1a\'\n\x10\x43hannelStateData\x12\x13\n\x0bstate_times\x18\x01 \x03(\x04\x1au\n\x12\x43hannelStatesEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12N\n\x05value\x18\x02 \x01(\x0b\x32?.minknow_api.statistics.StreamDutyTimeResponse.ChannelStateData:\x02\x38\x01\"X\n\x16ReadLengthHistogramKey\x12>\n\x0fread_end_reason\x18\x01 \x01(\x0e\x32%.minknow_api.statistics.ReadEndReason\"3\n\x18ReadLengthHistogramSplit\x12\x17\n\x0fread_end_reason\x18\x01 \x01(\x08\"\xc9\x03\n StreamReadLengthHistogramRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\x12\x19\n\x11poll_time_seconds\x18\x02 \x01(\r\x12@\n\x10read_length_type\x18\x03 \x01(\x0e\x32&.minknow_api.statistics.ReadLengthType\x12=\n\x0e\x64\x61ta_selection\x18\x04 \x01(\x0b\x32%.minknow_api.statistics.DataSelection\x12\x42\n\x11\x62ucket_value_type\x18\x05 \x01(\x0e\x32\'.minknow_api.statistics.BucketValueType\x12\x1f\n\x17\x64iscard_outlier_percent\x18\x06 \x01(\x02\x12\x41\n\tfiltering\x18\x07 \x03(\x0b\x32..minknow_api.statistics.ReadLengthHistogramKey\x12?\n\x05split\x18\x08 \x01(\x0b\x32\x30.minknow_api.statistics.ReadLengthHistogramSplit\"\xb9\x04\n!StreamReadLengthHistogramResponse\x12@\n\x10read_length_type\x18\x01 \x01(\x0e\x32&.minknow_api.statistics.ReadLengthType\x12\\\n\rbucket_ranges\x18\x02 \x03(\x0b\x32\x45.minknow_api.statistics.StreamReadLengthHistogramResponse.BucketRange\x12\x17\n\x0fsource_data_end\x18\x05 \x01(\x04\x12\x42\n\x11\x62ucket_value_type\x18\x03 \x01(\x0e\x32\'.minknow_api.statistics.BucketValueType\x12i\n\x0ehistogram_data\x18\x04 \x03(\x0b\x32Q.minknow_api.statistics.StreamReadLengthHistogramResponse.ReadLengthHistogramData\x1a)\n\x0b\x42ucketRange\x12\r\n\x05start\x18\x01 \x01(\x04\x12\x0b\n\x03\x65nd\x18\x02 \x01(\x04\x1a\x80\x01\n\x17ReadLengthHistogramData\x12\x41\n\tfiltering\x18\x03 \x03(\x0b\x32..minknow_api.statistics.ReadLengthHistogramKey\x12\x15\n\rbucket_values\x18\x01 \x03(\x04\x12\x0b\n\x03n50\x18\x02 \x01(\x02\"8\n\x14ReadLengthN50Request\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\"\xa2\x01\n\x15ReadLengthN50Response\x12K\n\x08n50_data\x18\x01 \x01(\x0b\x32\x39.minknow_api.statistics.ReadLengthN50Response.ReadN50Data\x1a<\n\x0bReadN50Data\x12\x15\n\restimated_n50\x18\x01 \x01(\x02\x12\x16\n\x0e\x62\x61secalled_n50\x18\x02 \x01(\x02\"=\n\x19GetReadLengthTypesRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\"]\n\x1aGetReadLengthTypesResponse\x12?\n\x0f\x61vailable_types\x18\x01 \x03(\x0e\x32&.minknow_api.statistics.ReadLengthType\"\x9a\x02\n\x12QScoreHistogramKey\x12\x46\n\tread_type\x18\x01 \x01(\x0e\x32\x33.minknow_api.statistics.QScoreHistogramKey.ReadType\x12N\n\x0b\x63\x61ll_status\x18\x02 \x01(\x0e\x32\x39.minknow_api.statistics.QScoreHistogramKey.BasecallStatus\",\n\x08ReadType\x12\x07\n\x03\x41ll\x10\x00\x12\x0b\n\x07Simplex\x10\x01\x12\n\n\x06\x44uplex\x10\x02\">\n\x0e\x42\x61secallStatus\x12\x07\n\x03\x41ny\x10\x00\x12\x0b\n\x07Skipped\x10\x01\x12\n\n\x06\x46\x61iled\x10\x02\x12\n\n\x06Passed\x10\x03\"\xf2\x01\n\x1cStreamQScoreHistogramRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\x12\x19\n\x11poll_time_seconds\x18\x02 \x01(\r\x12\x42\n\x0e\x64\x61ta_selection\x18\x03 \x01(\x0b\x32*.minknow_api.statistics.FloatDataSelection\x12Q\n\x11\x62ucket_value_type\x18\x04 \x01(\x0e\x32\x36.minknow_api.statistics.QScoreHistogramBucketValueType\"\xbd\x04\n\x1dStreamQScoreHistogramResponse\x12Q\n\x11\x62ucket_value_type\x18\x01 \x01(\x0e\x32\x36.minknow_api.statistics.QScoreHistogramBucketValueType\x12X\n\rbucket_ranges\x18\x02 \x03(\x0b\x32\x41.minknow_api.statistics.StreamQScoreHistogramResponse.BucketRange\x12\\\n\x11source_data_range\x18\x03 \x01(\x0b\x32\x41.minknow_api.statistics.StreamQScoreHistogramResponse.BucketRange\x12\x61\n\x0ehistogram_data\x18\x04 \x03(\x0b\x32I.minknow_api.statistics.StreamQScoreHistogramResponse.QScoreHistogramData\x1a)\n\x0b\x42ucketRange\x12\r\n\x05start\x18\x01 \x01(\x02\x12\x0b\n\x03\x65nd\x18\x02 \x01(\x02\x1a\x82\x01\n\x13QScoreHistogramData\x12=\n\tfiltering\x18\x01 \x03(\x0b\x32*.minknow_api.statistics.QScoreHistogramKey\x12\x15\n\rbucket_values\x18\x02 \x03(\x04\x12\x15\n\rmodal_q_score\x18\x03 \x01(\x02\"\xa3\x02\n\x15QAccuracyHistogramKey\x12I\n\tread_type\x18\x01 \x01(\x0e\x32\x36.minknow_api.statistics.QAccuracyHistogramKey.ReadType\x12Q\n\x0b\x63\x61ll_status\x18\x02 \x01(\x0e\x32<.minknow_api.statistics.QAccuracyHistogramKey.BasecallStatus\",\n\x08ReadType\x12\x07\n\x03\x41ll\x10\x00\x12\x0b\n\x07Simplex\x10\x01\x12\n\n\x06\x44uplex\x10\x02\">\n\x0e\x42\x61secallStatus\x12\x07\n\x03\x41ny\x10\x00\x12\x0b\n\x07Skipped\x10\x01\x12\n\n\x06\x46\x61iled\x10\x02\x12\n\n\x06Passed\x10\x03\"\xf8\x01\n\x1fStreamQAccuracyHistogramRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\x12\x19\n\x11poll_time_seconds\x18\x02 \x01(\r\x12\x42\n\x0e\x64\x61ta_selection\x18\x03 \x01(\x0b\x32*.minknow_api.statistics.FloatDataSelection\x12T\n\x11\x62ucket_value_type\x18\x04 \x01(\x0e\x32\x39.minknow_api.statistics.QAccuracyHistogramBucketValueType\"\xd8\x04\n StreamQAccuracyHistogramResponse\x12T\n\x11\x62ucket_value_type\x18\x01 \x01(\x0e\x32\x39.minknow_api.statistics.QAccuracyHistogramBucketValueType\x12[\n\rbucket_ranges\x18\x02 \x03(\x0b\x32\x44.minknow_api.statistics.StreamQAccuracyHistogramResponse.BucketRange\x12_\n\x11source_data_range\x18\x03 \x01(\x0b\x32\x44.minknow_api.statistics.StreamQAccuracyHistogramResponse.BucketRange\x12g\n\x0ehistogram_data\x18\x04 \x03(\x0b\x32O.minknow_api.statistics.StreamQAccuracyHistogramResponse.QAccuracyHistogramData\x1a)\n\x0b\x42ucketRange\x12\r\n\x05start\x18\x01 \x01(\x02\x12\x0b\n\x03\x65nd\x18\x02 \x01(\x02\x1a\x8b\x01\n\x16QAccuracyHistogramData\x12@\n\tfiltering\x18\x01 \x03(\x0b\x32-.minknow_api.statistics.QAccuracyHistogramKey\x12\x15\n\rbucket_values\x18\x02 \x03(\x04\x12\x18\n\x10modal_q_accuracy\x18\x03 \x01(\x02\"\x9c\x02\n\x14\x41\x63quisitionOutputKey\x12\x14\n\x0c\x62\x61rcode_name\x18\x01 \x01(\t\x12\x1b\n\x13\x61lignment_reference\x18\x02 \x01(\t\x12!\n\x19\x61lignment_bed_file_region\x18\x03 \x01(\t\x12&\n\x1e\x61lignment_bed_file_region_name\x18\x08 \x01(\t\x12\x17\n\x0flamp_barcode_id\x18\x04 \x01(\t\x12\x16\n\x0elamp_target_id\x18\x05 \x01(\t\x12\x15\n\rbarcode_alias\x18\x06 \x01(\t\x12>\n\x0fread_end_reason\x18\x07 \x01(\x0e\x32%.minknow_api.statistics.ReadEndReason\"\xb8\x01\n\x16\x41\x63quisitionOutputSplit\x12\x14\n\x0c\x62\x61rcode_name\x18\x01 \x01(\x08\x12\x1b\n\x13\x61lignment_reference\x18\x02 \x01(\x08\x12!\n\x19\x61lignment_bed_file_region\x18\x03 \x01(\x08\x12\x17\n\x0flamp_barcode_id\x18\x04 \x01(\x08\x12\x16\n\x0elamp_target_id\x18\x05 \x01(\x08\x12\x17\n\x0fread_end_reason\x18\x06 \x01(\x08\"\x81\x02\n\x1eStreamAcquisitionOutputRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\x12=\n\x0e\x64\x61ta_selection\x18\x02 \x01(\x0b\x32%.minknow_api.statistics.DataSelection\x12?\n\tfiltering\x18\x03 \x03(\x0b\x32,.minknow_api.statistics.AcquisitionOutputKey\x12=\n\x05split\x18\x04 \x01(\x0b\x32..minknow_api.statistics.AcquisitionOutputSplit\"u\n\x19\x41\x63quisitionOutputSnapshot\x12\x0f\n\x07seconds\x18\x01 \x01(\r\x12G\n\ryield_summary\x18\x02 \x01(\x0b\x32\x30.minknow_api.acquisition.AcquisitionYieldSummary\"\x9c\x02\n\x1fStreamAcquisitionOutputResponse\x12\\\n\tsnapshots\x18\x01 \x03(\x0b\x32I.minknow_api.statistics.StreamAcquisitionOutputResponse.FilteredSnapshots\x1a\x9a\x01\n\x11\x46ilteredSnapshots\x12?\n\tfiltering\x18\x01 \x03(\x0b\x32,.minknow_api.statistics.AcquisitionOutputKey\x12\x44\n\tsnapshots\x18\x02 \x03(\x0b\x32\x31.minknow_api.statistics.AcquisitionOutputSnapshot\"|\n\x19StreamWriterOutputRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\x12=\n\x0e\x64\x61ta_selection\x18\x02 \x01(\x0b\x32%.minknow_api.statistics.DataSelection\"q\n\x14WriterOutputSnapshot\x12\x0f\n\x07seconds\x18\x01 \x01(\r\x12H\n\rwriter_output\x18\x02 \x01(\x0b\x32\x31.minknow_api.acquisition.AcquisitionWriterSummary\"]\n\x1aStreamWriterOutputResponse\x12?\n\tsnapshots\x18\x01 \x03(\x0b\x32,.minknow_api.statistics.WriterOutputSnapshot\"Q\n-StreamEncounteredAcquisitionOutputKeysRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\"\x7f\n.StreamEncounteredAcquisitionOutputKeysResponse\x12M\n\x17\x61\x63quisition_output_keys\x18\x01 \x03(\x0b\x32,.minknow_api.statistics.AcquisitionOutputKey\"{\n\x18StreamTemperatureRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\x12=\n\x0e\x64\x61ta_selection\x18\x02 \x01(\x0b\x32%.minknow_api.statistics.DataSelection\"\xff\x04\n\x11TemperaturePacket\x12M\n\x06minion\x18\x01 \x01(\x0b\x32;.minknow_api.statistics.TemperaturePacket.MinIONTemperatureH\x00\x12U\n\npromethion\x18\x02 \x01(\x0b\x32?.minknow_api.statistics.TemperaturePacket.PromethIONTemperatureH\x00\x12M\n\x06pebble\x18\x04 \x01(\x0b\x32;.minknow_api.statistics.TemperaturePacket.PebbleTemperatureH\x00\x12K\n\x12target_temperature\x18\x03 \x01(\x0b\x32/.minknow_api.statistics.TemperaturePacket.Range\x1a)\n\x05Range\x12\x0f\n\x07minimum\x18\x01 \x01(\x02\x12\x0f\n\x07maximum\x18\x02 \x01(\x02\x1aK\n\x11MinIONTemperature\x12\x18\n\x10\x61sic_temperature\x18\x01 \x01(\x01\x12\x1c\n\x14heatsink_temperature\x18\x02 \x01(\x01\x1aR\n\x15PromethIONTemperature\x12\x1c\n\x14\x66lowcell_temperature\x18\x01 \x01(\x01\x12\x1b\n\x13\x63hamber_temperature\x18\x02 \x01(\x01\x1aM\n\x11PebbleTemperature\x12\x18\n\x10\x61sic_temperature\x18\x01 \x01(\x01\x12\x1e\n\x16instrument_temperature\x18\x02 \x01(\x01\x42\r\n\x0btemperature\"\\\n\x19StreamTemperatureResponse\x12?\n\x0ctemperatures\x18\x01 \x03(\x0b\x32).minknow_api.statistics.TemperaturePacket\"Z\n\x11\x42iasVoltagePacket\x12\x19\n\x11\x61\x63quisition_index\x18\x01 \x01(\x04\x12\x14\n\x0c\x62ias_voltage\x18\x02 \x01(\x01\x12\x14\n\x0ctime_seconds\x18\x03 \x01(\x04\"=\n\x19StreamBiasVoltagesRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\"^\n\x1aStreamBiasVoltagesResponse\x12@\n\rbias_voltages\x18\x01 \x03(\x0b\x32).minknow_api.statistics.BiasVoltagePacket\"\xee\x01\n\x14StreamBoxplotRequest\x12 \n\x12\x61\x63quisition_run_id\x18\x01 \x01(\tB\x04\x88\xb5\x18\x01\x12K\n\tdata_type\x18\x02 \x01(\x0e\x32\x38.minknow_api.statistics.StreamBoxplotRequest.BoxplotType\x12\x15\n\rdataset_width\x18\x03 \x01(\r\x12\x11\n\tpoll_time\x18\x04 \x01(\r\"=\n\x0b\x42oxplotType\x12\n\n\x06QSCORE\x10\x00\x12\x14\n\x10\x42\x41SES_PER_SECOND\x10\x01\x12\x0c\n\x08\x41\x43\x43URACY\x10\x02\"\x9a\x02\n\x0f\x42oxplotResponse\x12H\n\x08\x64\x61tasets\x18\x01 \x03(\x0b\x32\x36.minknow_api.statistics.BoxplotResponse.BoxplotDataset\x1a\xbc\x01\n\x0e\x42oxplotDataset\x12\x0b\n\x03min\x18\x01 \x01(\x02\x12\x0b\n\x03q25\x18\x02 \x01(\x02\x12\x0b\n\x03q50\x18\x03 \x01(\x02\x12\x0b\n\x03q75\x18\x04 \x01(\x02\x12\x0b\n\x03max\x18\x05 \x01(\x02\x12\r\n\x05\x63ount\x18\x06 \x01(\x04\x12%\n\x1dlower_full_width_half_maximum\x18\x07 \x01(\x02\x12\x0c\n\x04mode\x18\x08 \x01(\x02\x12%\n\x1dupper_full_width_half_maximum\x18\t \x01(\x02*L\n\x0eReadLengthType\x12\x11\n\rMinknowEvents\x10\x00\x12\x12\n\x0e\x45stimatedBases\x10\x01\x12\x13\n\x0f\x42\x61secalledBases\x10\x02*2\n\x0f\x42ucketValueType\x12\x0e\n\nReadCounts\x10\x00\x12\x0f\n\x0bReadLengths\x10\x01*\xa0\x01\n\rReadEndReason\x12\x07\n\x03\x41ll\x10\x00\x12\x0b\n\x07Unknown\x10\x01\x12\x0b\n\x07Partial\x10\x02\x12\r\n\tMuxChange\x10\x03\x12\x14\n\x10UnblockMuxChange\x10\x04\x12\x12\n\x0eSignalPositive\x10\x05\x12\x12\n\x0eSignalNegative\x10\x06\x12\x1f\n\x1b\x44\x61taServiceUnblockMuxChange\x10\x07*S\n\x1eQScoreHistogramBucketValueType\x12\x15\n\x11QScore_ReadCounts\x10\x00\x12\x1a\n\x16QScore_BasecalledBases\x10\x01*\\\n!QAccuracyHistogramBucketValueType\x12\x18\n\x14QAccuracy_ReadCounts\x10\x00\x12\x1d\n\x19QAccuracy_BasecalledBases\x10\x01\x32\xb6\r\n\x11StatisticsService\x12x\n\x10stream_duty_time\x12-.minknow_api.statistics.StreamDutyTimeRequest\x1a..minknow_api.statistics.StreamDutyTimeResponse\"\x03\x90\x02\x01\x30\x01\x12\x93\x01\n\x19stream_acquisition_output\x12\x36.minknow_api.statistics.StreamAcquisitionOutputRequest\x1a\x37.minknow_api.statistics.StreamAcquisitionOutputResponse\"\x03\x90\x02\x01\x30\x01\x12\x84\x01\n\x14stream_writer_output\x12\x31.minknow_api.statistics.StreamWriterOutputRequest\x1a\x32.minknow_api.statistics.StreamWriterOutputResponse\"\x03\x90\x02\x01\x30\x01\x12\xc2\x01\n*stream_encountered_acquisition_output_keys\x12\x45.minknow_api.statistics.StreamEncounteredAcquisitionOutputKeysRequest\x1a\x46.minknow_api.statistics.StreamEncounteredAcquisitionOutputKeysResponse\"\x03\x90\x02\x01\x30\x01\x12\x80\x01\n\x12stream_temperature\x12\x30.minknow_api.statistics.StreamTemperatureRequest\x1a\x31.minknow_api.statistics.StreamTemperatureResponse\"\x03\x90\x02\x01\x30\x01\x12\x84\x01\n\x14stream_bias_voltages\x12\x31.minknow_api.statistics.StreamBiasVoltagesRequest\x1a\x32.minknow_api.statistics.StreamBiasVoltagesResponse\"\x03\x90\x02\x01\x30\x01\x12\x9a\x01\n\x1cstream_read_length_histogram\x12\x38.minknow_api.statistics.StreamReadLengthHistogramRequest\x1a\x39.minknow_api.statistics.StreamReadLengthHistogramResponse\"\x03\x90\x02\x01\x30\x01\x12s\n\x0fread_length_n50\x12,.minknow_api.statistics.ReadLengthN50Request\x1a-.minknow_api.statistics.ReadLengthN50Response\"\x03\x90\x02\x01\x12\x83\x01\n\x15get_read_length_types\x12\x31.minknow_api.statistics.GetReadLengthTypesRequest\x1a\x32.minknow_api.statistics.GetReadLengthTypesResponse\"\x03\x90\x02\x01\x12\x8e\x01\n\x18stream_q_score_histogram\x12\x34.minknow_api.statistics.StreamQScoreHistogramRequest\x1a\x35.minknow_api.statistics.StreamQScoreHistogramResponse\"\x03\x90\x02\x01\x30\x01\x12\x97\x01\n\x1bstream_q_accuracy_histogram\x12\x37.minknow_api.statistics.StreamQAccuracyHistogramRequest\x1a\x38.minknow_api.statistics.StreamQAccuracyHistogramResponse\"\x03\x90\x02\x01\x30\x01\x12x\n\x18stream_basecall_boxplots\x12,.minknow_api.statistics.StreamBoxplotRequest\x1a\'.minknow_api.statistics.BoxplotResponse\"\x03\x90\x02\x01\x30\x01\x42&\n\x1c\x63om.nanoporetech.minknow_api\xa2\x02\x05MKAPIb\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'minknow_api.statistics_pb2', _globals)
if _descriptor._USE_C_DESCRIPTORS == False:
  _globals['DESCRIPTOR']._options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.nanoporetech.minknow_api\242\002\005MKAPI'
  _globals['_STREAMDUTYTIMEREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMDUTYTIMEREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMDUTYTIMERESPONSE_CHANNELSTATESENTRY']._options = None
  _globals['_STREAMDUTYTIMERESPONSE_CHANNELSTATESENTRY']._serialized_options = b'8\001'
  _globals['_STREAMREADLENGTHHISTOGRAMREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMREADLENGTHHISTOGRAMREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_READLENGTHN50REQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_READLENGTHN50REQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_GETREADLENGTHTYPESREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_GETREADLENGTHTYPESREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMQSCOREHISTOGRAMREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMQSCOREHISTOGRAMREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMQACCURACYHISTOGRAMREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMQACCURACYHISTOGRAMREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMACQUISITIONOUTPUTREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMACQUISITIONOUTPUTREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMWRITEROUTPUTREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMWRITEROUTPUTREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMENCOUNTEREDACQUISITIONOUTPUTKEYSREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMENCOUNTEREDACQUISITIONOUTPUTKEYSREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMTEMPERATUREREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMTEMPERATUREREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMBIASVOLTAGESREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMBIASVOLTAGESREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STREAMBOXPLOTREQUEST'].fields_by_name['acquisition_run_id']._options = None
  _globals['_STREAMBOXPLOTREQUEST'].fields_by_name['acquisition_run_id']._serialized_options = b'\210\265\030\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_duty_time']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_duty_time']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_acquisition_output']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_acquisition_output']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_writer_output']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_writer_output']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_encountered_acquisition_output_keys']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_encountered_acquisition_output_keys']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_temperature']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_temperature']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_bias_voltages']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_bias_voltages']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_read_length_histogram']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_read_length_histogram']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['read_length_n50']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['read_length_n50']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['get_read_length_types']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['get_read_length_types']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_q_score_histogram']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_q_score_histogram']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_q_accuracy_histogram']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_q_accuracy_histogram']._serialized_options = b'\220\002\001'
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_basecall_boxplots']._options = None
  _globals['_STATISTICSSERVICE'].methods_by_name['stream_basecall_boxplots']._serialized_options = b'\220\002\001'
  _globals['_READLENGTHTYPE']._serialized_start=7945
  _globals['_READLENGTHTYPE']._serialized_end=8021
  _globals['_BUCKETVALUETYPE']._serialized_start=8023
  _globals['_BUCKETVALUETYPE']._serialized_end=8073
  _globals['_READENDREASON']._serialized_start=8076
  _globals['_READENDREASON']._serialized_end=8236
  _globals['_QSCOREHISTOGRAMBUCKETVALUETYPE']._serialized_start=8238
  _globals['_QSCOREHISTOGRAMBUCKETVALUETYPE']._serialized_end=8321
  _globals['_QACCURACYHISTOGRAMBUCKETVALUETYPE']._serialized_start=8323
  _globals['_QACCURACYHISTOGRAMBUCKETVALUETYPE']._serialized_end=8415
  _globals['_DATASELECTION']._serialized_start=118
  _globals['_DATASELECTION']._serialized_end=175
  _globals['_FLOATDATASELECTION']._serialized_start=177
  _globals['_FLOATDATASELECTION']._serialized_end=281
  _globals['_STREAMDUTYTIMEREQUEST']._serialized_start=283
  _globals['_STREAMDUTYTIMEREQUEST']._serialized_end=403
  _globals['_STREAMDUTYTIMERESPONSE']._serialized_start=406
  _globals['_STREAMDUTYTIMERESPONSE']._serialized_end=807
  _globals['_STREAMDUTYTIMERESPONSE_BUCKETRANGE']._serialized_start=606
  _globals['_STREAMDUTYTIMERESPONSE_BUCKETRANGE']._serialized_end=647
  _globals['_STREAMDUTYTIMERESPONSE_CHANNELSTATEDATA']._serialized_start=649
  _globals['_STREAMDUTYTIMERESPONSE_CHANNELSTATEDATA']._serialized_end=688
  _globals['_STREAMDUTYTIMERESPONSE_CHANNELSTATESENTRY']._serialized_start=690
  _globals['_STREAMDUTYTIMERESPONSE_CHANNELSTATESENTRY']._serialized_end=807
  _globals['_READLENGTHHISTOGRAMKEY']._serialized_start=809
  _globals['_READLENGTHHISTOGRAMKEY']._serialized_end=897
  _globals['_READLENGTHHISTOGRAMSPLIT']._serialized_start=899
  _globals['_READLENGTHHISTOGRAMSPLIT']._serialized_end=950
  _globals['_STREAMREADLENGTHHISTOGRAMREQUEST']._serialized_start=953
  _globals['_STREAMREADLENGTHHISTOGRAMREQUEST']._serialized_end=1410
  _globals['_STREAMREADLENGTHHISTOGRAMRESPONSE']._serialized_start=1413
  _globals['_STREAMREADLENGTHHISTOGRAMRESPONSE']._serialized_end=1982
  _globals['_STREAMREADLENGTHHISTOGRAMRESPONSE_BUCKETRANGE']._serialized_start=1810
  _globals['_STREAMREADLENGTHHISTOGRAMRESPONSE_BUCKETRANGE']._serialized_end=1851
  _globals['_STREAMREADLENGTHHISTOGRAMRESPONSE_READLENGTHHISTOGRAMDATA']._serialized_start=1854
  _globals['_STREAMREADLENGTHHISTOGRAMRESPONSE_READLENGTHHISTOGRAMDATA']._serialized_end=1982
  _globals['_READLENGTHN50REQUEST']._serialized_start=1984
  _globals['_READLENGTHN50REQUEST']._serialized_end=2040
  _globals['_READLENGTHN50RESPONSE']._serialized_start=2043
  _globals['_READLENGTHN50RESPONSE']._serialized_end=2205
  _globals['_READLENGTHN50RESPONSE_READN50DATA']._serialized_start=2145
  _globals['_READLENGTHN50RESPONSE_READN50DATA']._serialized_end=2205
  _globals['_GETREADLENGTHTYPESREQUEST']._serialized_start=2207
  _globals['_GETREADLENGTHTYPESREQUEST']._serialized_end=2268
  _globals['_GETREADLENGTHTYPESRESPONSE']._serialized_start=2270
  _globals['_GETREADLENGTHTYPESRESPONSE']._serialized_end=2363
  _globals['_QSCOREHISTOGRAMKEY']._serialized_start=2366
  _globals['_QSCOREHISTOGRAMKEY']._serialized_end=2648
  _globals['_QSCOREHISTOGRAMKEY_READTYPE']._serialized_start=2540
  _globals['_QSCOREHISTOGRAMKEY_READTYPE']._serialized_end=2584
  _globals['_QSCOREHISTOGRAMKEY_BASECALLSTATUS']._serialized_start=2586
  _globals['_QSCOREHISTOGRAMKEY_BASECALLSTATUS']._serialized_end=2648
  _globals['_STREAMQSCOREHISTOGRAMREQUEST']._serialized_start=2651
  _globals['_STREAMQSCOREHISTOGRAMREQUEST']._serialized_end=2893
  _globals['_STREAMQSCOREHISTOGRAMRESPONSE']._serialized_start=2896
  _globals['_STREAMQSCOREHISTOGRAMRESPONSE']._serialized_end=3469
  _globals['_STREAMQSCOREHISTOGRAMRESPONSE_BUCKETRANGE']._serialized_start=3295
  _globals['_STREAMQSCOREHISTOGRAMRESPONSE_BUCKETRANGE']._serialized_end=3336
  _globals['_STREAMQSCOREHISTOGRAMRESPONSE_QSCOREHISTOGRAMDATA']._serialized_start=3339
  _globals['_STREAMQSCOREHISTOGRAMRESPONSE_QSCOREHISTOGRAMDATA']._serialized_end=3469
  _globals['_QACCURACYHISTOGRAMKEY']._serialized_start=3472
  _globals['_QACCURACYHISTOGRAMKEY']._serialized_end=3763
  _globals['_QACCURACYHISTOGRAMKEY_READTYPE']._serialized_start=2540
  _globals['_QACCURACYHISTOGRAMKEY_READTYPE']._serialized_end=2584
  _globals['_QACCURACYHISTOGRAMKEY_BASECALLSTATUS']._serialized_start=2586
  _globals['_QACCURACYHISTOGRAMKEY_BASECALLSTATUS']._serialized_end=2648
  _globals['_STREAMQACCURACYHISTOGRAMREQUEST']._serialized_start=3766
  _globals['_STREAMQACCURACYHISTOGRAMREQUEST']._serialized_end=4014
  _globals['_STREAMQACCURACYHISTOGRAMRESPONSE']._serialized_start=4017
  _globals['_STREAMQACCURACYHISTOGRAMRESPONSE']._serialized_end=4617
  _globals['_STREAMQACCURACYHISTOGRAMRESPONSE_BUCKETRANGE']._serialized_start=3295
  _globals['_STREAMQACCURACYHISTOGRAMRESPONSE_BUCKETRANGE']._serialized_end=3336
  _globals['_STREAMQACCURACYHISTOGRAMRESPONSE_QACCURACYHISTOGRAMDATA']._serialized_start=4478
  _globals['_STREAMQACCURACYHISTOGRAMRESPONSE_QACCURACYHISTOGRAMDATA']._serialized_end=4617
  _globals['_ACQUISITIONOUTPUTKEY']._serialized_start=4620
  _globals['_ACQUISITIONOUTPUTKEY']._serialized_end=4904
  _globals['_ACQUISITIONOUTPUTSPLIT']._serialized_start=4907
  _globals['_ACQUISITIONOUTPUTSPLIT']._serialized_end=5091
  _globals['_STREAMACQUISITIONOUTPUTREQUEST']._serialized_start=5094
  _globals['_STREAMACQUISITIONOUTPUTREQUEST']._serialized_end=5351
  _globals['_ACQUISITIONOUTPUTSNAPSHOT']._serialized_start=5353
  _globals['_ACQUISITIONOUTPUTSNAPSHOT']._serialized_end=5470
  _globals['_STREAMACQUISITIONOUTPUTRESPONSE']._serialized_start=5473
  _globals['_STREAMACQUISITIONOUTPUTRESPONSE']._serialized_end=5757
  _globals['_STREAMACQUISITIONOUTPUTRESPONSE_FILTEREDSNAPSHOTS']._serialized_start=5603
  _globals['_STREAMACQUISITIONOUTPUTRESPONSE_FILTEREDSNAPSHOTS']._serialized_end=5757
  _globals['_STREAMWRITEROUTPUTREQUEST']._serialized_start=5759
  _globals['_STREAMWRITEROUTPUTREQUEST']._serialized_end=5883
  _globals['_WRITEROUTPUTSNAPSHOT']._serialized_start=5885
  _globals['_WRITEROUTPUTSNAPSHOT']._serialized_end=5998
  _globals['_STREAMWRITEROUTPUTRESPONSE']._serialized_start=6000
  _globals['_STREAMWRITEROUTPUTRESPONSE']._serialized_end=6093
  _globals['_STREAMENCOUNTEREDACQUISITIONOUTPUTKEYSREQUEST']._serialized_start=6095
  _globals['_STREAMENCOUNTEREDACQUISITIONOUTPUTKEYSREQUEST']._serialized_end=6176
  _globals['_STREAMENCOUNTEREDACQUISITIONOUTPUTKEYSRESPONSE']._serialized_start=6178
  _globals['_STREAMENCOUNTEREDACQUISITIONOUTPUTKEYSRESPONSE']._serialized_end=6305
  _globals['_STREAMTEMPERATUREREQUEST']._serialized_start=6307
  _globals['_STREAMTEMPERATUREREQUEST']._serialized_end=6430
  _globals['_TEMPERATUREPACKET']._serialized_start=6433
  _globals['_TEMPERATUREPACKET']._serialized_end=7072
  _globals['_TEMPERATUREPACKET_RANGE']._serialized_start=6776
  _globals['_TEMPERATUREPACKET_RANGE']._serialized_end=6817
  _globals['_TEMPERATUREPACKET_MINIONTEMPERATURE']._serialized_start=6819
  _globals['_TEMPERATUREPACKET_MINIONTEMPERATURE']._serialized_end=6894
  _globals['_TEMPERATUREPACKET_PROMETHIONTEMPERATURE']._serialized_start=6896
  _globals['_TEMPERATUREPACKET_PROMETHIONTEMPERATURE']._serialized_end=6978
  _globals['_TEMPERATUREPACKET_PEBBLETEMPERATURE']._serialized_start=6980
  _globals['_TEMPERATUREPACKET_PEBBLETEMPERATURE']._serialized_end=7057
  _globals['_STREAMTEMPERATURERESPONSE']._serialized_start=7074
  _globals['_STREAMTEMPERATURERESPONSE']._serialized_end=7166
  _globals['_BIASVOLTAGEPACKET']._serialized_start=7168
  _globals['_BIASVOLTAGEPACKET']._serialized_end=7258
  _globals['_STREAMBIASVOLTAGESREQUEST']._serialized_start=7260
  _globals['_STREAMBIASVOLTAGESREQUEST']._serialized_end=7321
  _globals['_STREAMBIASVOLTAGESRESPONSE']._serialized_start=7323
  _globals['_STREAMBIASVOLTAGESRESPONSE']._serialized_end=7417
  _globals['_STREAMBOXPLOTREQUEST']._serialized_start=7420
  _globals['_STREAMBOXPLOTREQUEST']._serialized_end=7658
  _globals['_STREAMBOXPLOTREQUEST_BOXPLOTTYPE']._serialized_start=7597
  _globals['_STREAMBOXPLOTREQUEST_BOXPLOTTYPE']._serialized_end=7658
  _globals['_BOXPLOTRESPONSE']._serialized_start=7661
  _globals['_BOXPLOTRESPONSE']._serialized_end=7943
  _globals['_BOXPLOTRESPONSE_BOXPLOTDATASET']._serialized_start=7755
  _globals['_BOXPLOTRESPONSE_BOXPLOTDATASET']._serialized_end=7943
  _globals['_STATISTICSSERVICE']._serialized_start=8418
  _globals['_STATISTICSSERVICE']._serialized_end=10136
GetReadLengthTypesResponse.__doc__ = """Attributes:
    available_types:
        Array of the types of bucket for which a histogram is
        currently available
"""
ReadLengthHistogramKey.__doc__ = """Attributes:
    read_end_reason:
        Only return data for the given ReadEndReason.  Special values:
        - Specify `ReadEndReason::All` to return data for all read end
        reasons  If unspecified all read end reasons are returned.
"""
StreamQAccuracyHistogramResponse.QAccuracyHistogramData.__doc__ = """Attributes:
    filtering:
        The filtering parameters which contributed to this bucket.
    bucket_values:
        Counts for each histogram bucket  Units and type of
        accumulated values are as specified in `bucket_value_type` The
        range covered by each bucket is as in `bucket_ranges`
    modal_q_accuracy:
        The modal q accuracy, calculated using the `bucket_value_type`
"""
StreamQScoreHistogramResponse.__doc__ = """Attributes:
    bucket_value_type:
        The data accumulated in the histogram buckets  See
        `QScoreHistogramBucketValueType` for further information about
        the possible options.
    bucket_ranges:
        The range covered by each bucket in the histogram data
    source_data_range:
        The range covered by non-empty buckets in the source data
    histogram_data:
        The histogram data  If duplex basecalling is not enabled, then
        Simplex histogram data will be returned If duplex basecalling
        is enabled, then Simplex, Duplex and "All" (i.e. overall)
        histogram data will be returned
"""
ReadLengthN50Request.__doc__ = """Attributes:
    acquisition_run_id:
        The `acquisition_run_id` of the acquisition to obtain data for
"""
StreamDutyTimeResponse.__doc__ = """Attributes:
    bucket_ranges:
        The range covered by each entry in state_times
    channel_states:
        Map between channel state names, and a list of bucketed duty
        time data
"""
AcquisitionOutputSplit.__doc__ = """Attributes:
    barcode_name:
        Split data for every individual barcode.
    alignment_reference:
        Split data for each individual alignment reference.
        References are defined in alignment references.
    alignment_bed_file_region:
        Split data for each target region.  Target regions are defined
        in bed files.
    lamp_barcode_id:
        Split data for each lamp barcode id.  Lamp barcodes are
        defined by the active lamp kit.  DEPRECATED 6.0: Lamp support
        has been removed and this option will always be ignored.
    lamp_target_id:
        Split data for each lamp targets id.  Lamp targets are defined
        by the active lamp kit.  DEPRECATED 6.0: Lamp support has been
        removed and this option will always be ignored.
    read_end_reason:
        Split returned data by read_end_reason
"""
AcquisitionOutputKey.__doc__ = """Attributes:
    barcode_name:
        Only return data for the given barcode.  Special values:   -
        Specify "unclassified" for data which does not have a barcode.
        - Specify "classified" for all data which has a barcode.  If
        unspecified all barcodes are returned.
    alignment_reference:
        Only return data for the given alignment reference.  Special
        values:   - Specify "unaligned" for data which does not align
        to a reference   - Specify "aligned" for all data which aligns
        to a reference  If unspecified all alignment targets are
        returned.
    alignment_bed_file_region:
        Only return data for the given target region.  Target regions
        are defined in bed files.  The region is a string which
        identifies an entry in the bed file.  Special values:   -
        Specify "offtarget" for data which does not have a bed region.
        - Specify "ontarget" for all data which has a bed region.  If
        unspecified all alignment regions are returned.
    alignment_bed_file_region_name:
        An alias to `alignment_bed_file_region`  An optional name can
        be used to identify a target region in the bed file
    lamp_barcode_id:
        Only return data for the given lamp barcode.  Special values:
        - Specify "unclassified" for data which does not have a lamp
        barcode.   - Specify "classified" for all data which has a
        lamp barcode.  If unspecified all lamp barcodes are returned.
        DEPRECATED 6.0: Lamp support has been removed and this option
        will always be ignored.
    lamp_target_id:
        Only return data for the given lamp target.  Special values:
        - Specify "unclassified" for data which does not have a lamp
        target.   - Specify "classified" for all data which has a lamp
        target. Using barcode terms here as lamp is part of barcoding
        pipeline  If unspecified all lamp target are returned.
        DEPRECATED 6.0: Lamp support has been removed and this option
        will always be ignored.
    barcode_alias:
        The barcode alias corresponding to the `barcode_name`
    read_end_reason:
        Only return data for the given ReadEndReason.  Special values:
        - Specify `ReadEndReason::All` to return data for all read end
        reasons  If unspecified all read end reasons are returned.
"""
AcquisitionOutputSnapshot.__doc__ = """A snapshot of acquisition output data, for a given set of filtering
criteria.

Attributes:
    seconds:
        The time the snapshot was collected, in seconds.  Represents
        the number of seconds since the start of the experiment Will
        usually stream in minute chunks, so will first see 60, then
        120 etc
    yield_summary:
        The yield summary data.
"""
StreamTemperatureRequest.__doc__ = """Attributes:
    period_seconds:
        How often temperature updates should be sent Defaults to a
        period of 1 second, if not specified, or set to 0
    acquisition_run_id:
        The acquisition id of the experiment.
    data_selection:
        The desired data selection.  The units for all values are
        `seconds since the start of the experiment`.
"""
FloatDataSelection.__doc__ = """Specify a desired data selection, using floating point values  The
actual data selection used may differ from the desired one.  They are
adjusted in the following sequence:   1. The selection is set equal to
the desired selection  2. Any selection value that is not set is
adjusted to its default value:      - `start` and `step` will be set
to the minimum valid value      - `end` will be set to the maximum
valid value  3. Values which are outside of the valid range are
clamped to the nearest valid value:      - Values less than minimum
valid value will be set equal to the minimum valid value      - Values
greater than the maximum valid value will be set equal to the maximum
valid value  4. Finally, all values are 'rounded' to a nearby valid
value      - `start` and `step` will be rounded down to the first
valid value less than or equal to        their current values      -
`end` will be rounded up to the first valid value that is greater than
or equal to its        current value      - This means that the range
that is specified after rounding includes the range that was
specified prior to rounding"""
StreamReadLengthHistogramResponse.BucketRange.__doc__ = """Attributes:
    start:
        The range covered by a bucket Units are as set in
        `read_length_type`, above  The range [start, end) is half open
        (i.e. the start value is included, the end value is not).
"""
StreamReadLengthHistogramRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The `acquisition_run_id` of the acquisition to obtain data for
        If this is set to the `acquisition_run_id` of an acquisition
        which is in-progress, then updates containing the latest
        histogram data for that acquisition will be streamed regularly
        until that acquisition finishes (see `poll_time_seconds`
        below)  Otherwise, if this is set to the `acquisition_run_id`
        of an acquisition which is finished, and for which final
        histogram data is available, then the final histogram data for
        that acquisition will be returned.  Final histogram data is
        available until it is cleared.  Otherwise, if this parameter
        is not set, or is set to a value which is neither the
        `acquisition_run_id` of an acquisition which is in-progress,
        nor the `acquisition_run_id` of an acquisition for which final
        histogram data is available, then this call will fail with the
        status `INVALID_ARGUMENT`.
    poll_time_seconds:
        How often to return new histogram data, in seconds  If not
        specified, or set to `0`, then the poll time will be set to 60
        seconds  If data is being returned for an acquisition which is
        in progress, then one update will be sent when the call is
        first performed, then subsequently every `poll_time` after
        that, and then finally once again when the acquisition
        finishes.  Otherwise, if final histogram data is being
        returned for an acquisition that has already finished, this
        parameter has no effect.  The final histogram data will be
        returned, and the call will complete.
    read_length_type:
        The source of the read lengths in the histogram  If MinKNOW is
        unable to supply data from the requested source (e.g. if the
        user requests BasecalledBases, but basecalling is not
        enabled), then this call will fail with the status
        `FAILED_PRECONDITION`.  See `ReadLengthType` for further
        information about the available options.
    data_selection:
        The desired read length range which histograms should cover.
        Units are as set in `read_length_type`, above.
    bucket_value_type:
        What data to accumulate in the read length histogram buckets
        See `BucketValueType` for further information about the
        available options.
    discard_outlier_percent:
        If set greater than zero then discard some percent of data at
        the upper end of the source data before producing histograms
        and N50 values.  This is intended to assist in the case where
        a small number of outliers with very long read lengths cause
        the histogram axes and N50 to be skewed.  Defaults to 0 - no
        data discarded. Values should be specified in percent - a
        value of 0.05 will cause the top 5% of the data to be
        discarded before producing outputs.  For histograms, the data
        discarded depends on the bucket_value_type.  If `ReadCounts`,
        then a percentage of the total number of reads reads will be
        discarded; if `ReadLengths` then a percentage of the total
        read lengths will be discarded.  For the N50 value,
        `discard_outlier_percent` always causes a percentage of the
        total read lengths to be discarded (since it is always
        calculated from read length data)
    filtering:
        Define filtering parameters for streamed data.
    split:
        Define how results are split for returned data.
"""
StreamQScoreHistogramResponse.QScoreHistogramData.__doc__ = """Attributes:
    filtering:
        The filtering parameters which contributed to this bucket.
    bucket_values:
        Counts for each histogram bucket  Units and type of
        accumulated values are as specified in `bucket_value_type` The
        range covered by each bucket is as in `bucket_ranges`
    modal_q_score:
        The modal q score, calculated using the `bucket_value_type`
"""
StreamReadLengthHistogramResponse.ReadLengthHistogramData.__doc__ = """Attributes:
    filtering:
        The filtering parameters which contributed to this bucket.
    bucket_values:
        Counts for each histogram bucket  Units are as specified in
        `read_length_type` The range covered by each bucket is as in
        `bucket_ranges` The type of data accumulated in each bucket is
        given by `bucket_value_type`
    n50:
        The N50 value for the read length data for the selected
        `read_length_type` and `read_end_reasons`.  Units are as
        specified by `read_length_type`.  Measured across all source
        data, after excluding the reads specified by
        `discard_outlier_percent` in the stream request.
"""
TemperaturePacket.PromethIONTemperature.__doc__ = """Packet of temperatures appropriate for a PromethION.

Attributes:
    flowcell_temperature:
        Temperature as measured by thermistor TH2 on the P-Chip.
    chamber_temperature:
        Mean of 12 pixel-blocks temperatures measured with sensors in
        the ASIC.
"""
TemperaturePacket.Range.__doc__ = """Represents a range of values."""
StreamQScoreHistogramRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The `acquisition_run_id` of the acquisition to obtain data for
        If this is set to the `acquisition_run_id` of an acquisition
        which is in-progress, then updates containing the latest
        histogram data for that acquisition will be streamed regularly
        until that acquisition finishes (see `poll_time_seconds`
        below)  Otherwise, if this is set to the `acquisition_run_id`
        of an acquisition which is finished, and for which final
        histogram data is available, then the final histogram data for
        that acquisition will be returned.  Final histogram data is
        available until it is cleared.  Otherwise, if this parameter
        is not set, or is set to a value which is neither the
        `acquisition_run_id` of an acquisition which is in-progress,
        nor the `acquisition_run_id` of an acquisition for which final
        histogram data is available, then this call will fail with the
        status `INVALID_ARGUMENT`.
    poll_time_seconds:
        How often to return new histogram data, in seconds  If not
        specified, or set to `0`, then the poll time will be set to 60
        seconds  If data is being returned for an acquisition which is
        in progress, then one update will be sent when the call is
        first performed, then subsequently every `poll_time` after
        that, and then finally once again when the acquisition
        finishes.  Otherwise, if final histogram data is being
        returned for an acquisition that has already finished, this
        parameter has no effect.  The final histogram data will be
        returned, and the call will complete.
    data_selection:
        The desired q score range which histograms should cover.
    bucket_value_type:
        What data to accumulate in the histogram buckets  See
        `QScoreHistogramBucketValueType` for further information about
        the available options.
"""
StreamQAccuracyHistogramResponse.BucketRange.__doc__ = """Attributes:
    start:
        The range covered by a bucket  The range [start, end) is half
        open (i.e. the start value is included, the end value is not).
"""
StreamAcquisitionOutputResponse.__doc__ = """Attributes:
    snapshots:
        Snapshots split by requested filtering parameters.
"""
BoxplotResponse.BoxplotDataset.__doc__ = """Attributes:
    min:
        Minimum value for any point in the dataset.
    q25:
        25th quartile value for all points in the dataset.
    q50:
        50th quartile or median value for all points in the dataset.
    q75:
        75th quartile value for all points in the dataset.
    max:
        Maximum value for any point in the dataset.
    count:
        Number of items in this box plot's stats.
    lower_full_width_half_maximum:
        Estimated lower value where there is half the data compared to
        the mode. provides some estimate on the sharpness of the mode
        peak.
    mode:
        Estimated mode for the dataset.
    upper_full_width_half_maximum:
        Estimated upper value where there is half the data compared to
        the mode. provides some estimate on the sharpness of the mode
        peak.
"""
StreamDutyTimeRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The acquisition id of the experiment.
    data_selection:
        The desired data selection.  The units for all values are
        `seconds since the start of the experiment`.
"""
TemperaturePacket.__doc__ = """Attributes:
    target_temperature:
        The range is based on the requested target temperature and
        tolerance.  For example, if the target temperature is 35, and
        the tolerance is 1 then target temperatures will return as
        34(min) and 36(max).
"""
StreamReadLengthHistogramResponse.__doc__ = """Attributes:
    read_length_type:
        The data source for the histograms  Also specifies the units
        for `data_selection` and `n50`  See `ReadLengthType` for
        further information about the possible options.
    bucket_ranges:
        The range covered by each bucket in the histogram data
    source_data_end:
        The right hand edge of the last source bucket which contains
        data  Measured across all source data, after excluding the
        reads specified by `discard_outlier_percent` in the stream
        request.
    bucket_value_type:
        The data accumulated in the read length histogram buckets  See
        `BucketValueType` for further information about the possible
        options.
    histogram_data:
        The histogram data
"""
StreamDutyTimeResponse.BucketRange.__doc__ = """Attributes:
    start:
        The range covered by a bucket Values are in seconds  The range
        [start, end) is half open (i.e. the start value is included,
        the end value is not).
"""
StreamBoxplotRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The acquisition id of the experiment.
    data_type:
        Type of boxplot data to return.
    dataset_width:
        Defines, in minutes, the width of each dataset. This is how
        much time should each dataset (boxplot) cover. Note that
        MinKNOW stores all stats at a default granularity (specified
        in the config file, i.e. 10 min in MinKNOW 3.2). This
        dataset_width HAS to be a multiple of the default granularity!
        Note: When multiple buckets are aggregated into a single
        dataset, the resulting dataset will contain the average of the
        aggregated quantiles (with the exception of min/max)! This is
        not the same as using a larger granularity in MinKNOW configs
        - the values that MinKNOW stores are the true quantiles.
        Averaging quantiles will give a rough approximation, but not a
        quantile. If the finest granularity is not required, we
        strongly suggest changing the time coverage in the config, not
        the dataset_width in the rpc.
    poll_time:
        How often to return messages in this stream, specified in
        seconds. Note that this stream will return results regardless
        of the stats updates (because it always returns all the
        datasets). poll_time should be larger than the basecalled
        stats update rate in MinKNOW - please see
        basecalled_stats_refresh_rate_seconds in the configs (set to 1
        second in MinKNOW 3.2).  If unspecified, defaults to 1 minute.
"""
StreamQAccuracyHistogramRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The `acquisition_run_id` of the acquisition to obtain data for
        If this is set to the `acquisition_run_id` of an acquisition
        which is in-progress, then updates containing the latest
        histogram data for that acquisition will be streamed regularly
        until that acquisition finishes (see `poll_time_seconds`
        below)  Otherwise, if this is set to the `acquisition_run_id`
        of an acquisition which is finished, and for which final
        histogram data is available, then the final histogram data for
        that acquisition will be returned.  Final histogram data is
        available until it is cleared.  Otherwise, if this parameter
        is not set, or is set to a value which is neither the
        `acquisition_run_id` of an acquisition which is in-progress,
        nor the `acquisition_run_id` of an acquisition for which final
        histogram data is available, then this call will fail with the
        status `INVALID_ARGUMENT`.
    poll_time_seconds:
        How often to return new histogram data, in seconds  If not
        specified, or set to `0`, then the poll time will be set to 60
        seconds  If data is being returned for an acquisition which is
        in progress, then one update will be sent when the call is
        first performed, then subsequently every `poll_time` after
        that, and then finally once again when the acquisition
        finishes.  Otherwise, if final histogram data is being
        returned for an acquisition that has already finished, this
        parameter has no effect.  The final histogram data will be
        returned, and the call will complete.
    data_selection:
        The desired q accuracy range which histograms should cover.
    bucket_value_type:
        What data to accumulate in the histogram buckets  See
        `QAccuracyHistogramBucketValueType` for further information
        about the available options.
"""
TemperaturePacket.PebbleTemperature.__doc__ = """Packet of temperatures appropriate for a Pebble.

Attributes:
    asic_temperature:
        Temperature as measured by probe inside the ASIC.
    instrument_temperature:
        Temperature as measured by thermistor on the instrument.
"""
StreamDutyTimeResponse.ChannelStateData.__doc__ = """Attributes:
    state_times:
        How much time (in samples) spent in this channel state, for
        each bucket
"""
StreamBiasVoltagesRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The acquisition id of the experiment.
"""
ReadLengthHistogramSplit.__doc__ = """Attributes:
    read_end_reason:
        Split returned data by read_end_reason
"""
StreamWriterOutputRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The acquisition id of the experiment.
    data_selection:
        The desired data selection.  The units for all values are
        `seconds since the start of the experiment`.
"""
ReadLengthN50Response.__doc__ = """Attributes:
    n50_data:
        The N50 return data
"""
BoxplotResponse.__doc__ = """Attributes:
    datasets:
        Result boxplots are stored in this array. This is an overview
        of the stored data from the START of the acquisition period.
        This includes ALL the basecalled stats from MinKNOW, not just
        updates since previous calls!
"""
ReadLengthN50Response.ReadN50Data.__doc__ = """Attributes:
    estimated_n50:
        The estimated N50 value in bases  This is always set
    basecalled_n50:
        The basecalled N50 value  If the acquisition did/does not have
        live basecalling enabled, this will be 0.0
"""
StreamQScoreHistogramResponse.BucketRange.__doc__ = """Attributes:
    start:
        The range covered by a bucket  The range [start, end) is half
        open (i.e. the start value is included, the end value is not).
"""
TemperaturePacket.MinIONTemperature.__doc__ = """Packet of temperatures appropriate for a MinION.

Attributes:
    asic_temperature:
        Temperature as measured by the probe inside the asic.
    heatsink_temperature:
        Temperature as measured by the probe in the minion heatsink.
"""
StreamQAccuracyHistogramResponse.__doc__ = """Attributes:
    bucket_value_type:
        The data accumulated in the histogram buckets  See
        `QAccuracyHistogramBucketValueType` for further information
        about the possible options.
    bucket_ranges:
        The range covered by each bucket in the histogram data
    source_data_range:
        The range covered by non-empty buckets in the source data
    histogram_data:
        The histogram data  If duplex basecalling is not enabled, then
        Simplex histogram data will be returned If duplex basecalling
        is enabled, then Simplex, Duplex and "All" (i.e. overall)
        histogram data will be returned
"""
StreamEncounteredAcquisitionOutputKeysRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The acquisition id of the experiment.
"""
DataSelection.__doc__ = """Specify a desired data selection.  Units for values are as specified
in the corresponding Request  The actual data selection used may
differ from the desired one.  They are adjusted in the following
sequence:   1. All values are set equal to the corresponding desired
value.  2. Negative `start` or `end` values are fixed up by adding the
current maximum value to the     specified value      - Negative start
and end values are only supported for certain requests; typically they
are        supported for time-series data      - If, after adding the
current bucket count, the `start` value is still negative, then the
start value is adjusted to `0`      - If, after adding the current
bucket count, the `end` value is still negative, or is zero,
then the data selection is empty      - If data collection is still
ongoing, then the current bucket count may change between rpc
calls as more data is collected.  3. Values which are not set, or
which are set at `0`, are then adjusted to a default value:      -
`start` and `step` will be set to the minimum valid value      - `end`
will be set to the maximum valid value  4. Values which are outside of
the valid range are clamped to the nearest valid value:      - Values
less than minimum valid value will be set equal to the minimum valid
value      - Values greater than the maximum valid value will be set
equal to the maximum valid value  5. Finally, all values are 'rounded'
to a nearby valid value      - `start` and `step` will be rounded down
to the first valid value less than or equal to        their current
values      - `end` will be rounded up to the first valid value that
is greater than or equal to its        current value      - This means
that the range that is specified after rounding includes the range
that was        specified prior to rounding  If (`end` - `start`) is
not an exact integer multiple of `step`, then the final bucket will
cover a smaller range than that specified by `step`.  Note also that
the maximum valid start and end value may not be known if data
collection is still ongoing -- for example, the maximum valid time for
time series data.  If this is the case, then the maximum valid value
will be determined when the experiment ends, and values in use will be
adjusted accordingly."""
StreamAcquisitionOutputResponse.FilteredSnapshots.__doc__ = """Attributes:
    filtering:
        The filtering parameters which contributed to this bucket.
"""
WriterOutputSnapshot.__doc__ = """A snapshot of writer data.

Attributes:
    seconds:
        The time the snapshot was collected, in seconds.  Represents
        the number of seconds since the start of the experiment Will
        usually stream in minute chunks, so will first see 60, then
        120 etc
    writer_output:
        The writer data for this bucket.
"""
StreamAcquisitionOutputRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The acquisition id of the experiment.
    data_selection:
        The desired data selection.  The units for all values are
        `seconds since the start of the experiment`.
    filtering:
        Define filtering parameters for streamed data.
    split:
        Define how results are split for returned data.
"""
GetReadLengthTypesRequest.__doc__ = """Attributes:
    acquisition_run_id:
        The acquisition id of the experiment.
"""
# @@protoc_insertion_point(module_scope)
