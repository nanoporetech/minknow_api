syntax="proto3";

package minknow_api.analysis_configuration;

option java_package = "com.nanoporetech.minknow_api";
option objc_class_prefix = "MKAPI";

import "google/protobuf/wrappers.proto";
import "minknow_api/rpc_options.proto";

service AnalysisConfigurationService {
    // Get the analysis configuration
    rpc get_analysis_configuration (GetAnalysisConfigurationRequest) returns (AnalysisConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    };

    // Sets the analysis configuration
    //
    // This sets the whole configuration as-is, so you have to specify the whole analysis configuration as any fields
    // there previously will be overwritten. To preserve the current analysis configuration, use a get-modify-set
    // approach. Use get_analysis_configuration to retrieve the current config and modify the fields on that copy.
    // Then use this call to set the modified version.
    //
    // The AnalysisConfiguration message is converted to/from json in Minknow, but this will be removed from later
    // versions of MinKNOW. The basecaller params are the first ones to move away from the jsn format. The old structure
    // has been kept for backwards compatibility, but it will be removed.
    //
    // The AnalysisConfiguration message is intended to be used to convert easily from protobuf to json and back again.
    // To convert from json to a protobuf message (assuming 'analysis_conf_json' holds the json data:
    //
    // >>> import minknow_api
    // >>> from google.protobuf import json_format
    // >>>
    // >>> analysis_conf_pb = minknow_api.analysis_configuration_service.AnalysisConfiguration()
    // >>> json_format.Parse(json.dumps(analysis_conf_json), analysis_conf_pb)
    //
    // To convert from a protobuf message to json:
    //
    // >>> json_data = json_format.MessageToJson(analysis_conf_resp, preserving_proto_field_name=True, including_default_value_fields=True)
    //
    // 'preserving_proto_field_name' is needed because json_format will try convert keys to json-standard(?) format, like converting
    // my_key to myKey, and the key names as seen in the protobuf file are important to minknow
    //
    // 'including_default_value_fields' is needed because in proto3, primitive values that are default initialised (like a uint32 with value 0)
    // will not be sent on the wire, so the value wouldn't appear when converting to json. In practice, most values are wrapper types and this
    // field won't have an affect in wrapper types, but it does affect enum types as the default initailised value is the 0th enum.
    //
    // NOTE: if the analysis configuration was set using the new parameters (with the filename for albacore config files), the old parameters
    // from jsn will be ignored. So set_analysis_configuration must be used with either the old protobuf message for the basecaller parameters,
    // or with the new one, but it cannot be used interleaved!
    rpc set_analysis_configuration (AnalysisConfiguration) returns (SetAnalysisConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    };

    // Reset the analysis configuration
    //
    // The configuration will be set to the initial default configuration that was set on boot
    //
    // Since 3.0
    rpc reset_analysis_configuration (ResetAnalysisConfigurationRequest) returns (ResetAnalysisConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    };

    // Enable or disable analysis entirely.
    rpc set_analysis_enabled_state (SetAnalysisEnabledStateRequest) returns (SetAnalysisEnabledStateResponse) {
        option idempotency_level = IDEMPOTENT;
    };

    // Get a description of the possible channel states.
    //
    // This is a subset of the information included in the channel states section of the analysis
    // configuration. It will change when the analysis configuration changes.
    rpc get_channel_states_desc (GetChannelStatesDescRequest) returns (GetChannelStatesDescResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    };

    // Get a brief summary of the analysis configuration.
    //
    // This is a high-level overview of what major parts of the analysis pipeline are enabled.
    rpc get_summary (GetSummaryRequest) returns (GetSummaryResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    };

    // Configure the basecaller which will run during acquisition.
    //
    // This rpc will result in an error if invoked during acquisition.
    //
    // By default no basecalling is performed (enable = false).
    //
    // Since 3.0
    rpc set_basecaller_configuration(SetBasecallerConfigurationRequest) returns (SetBasecallerConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    }

    // Inform MinKNOW the passed basecall configuration will be used at some point in the future, and could be loaded now
    // to reduce wait time in the future.
    //
    // This rpc will result in an error if invoked during acquisition.
    //
    // The call will block until any previous call to preload configs is complete, but does not block while the config
    // is loaded, no errors are reported to the caller if the config is invalid.
    //
    // Since 4.1
    rpc preload_basecaller_configuration(SetBasecallerConfigurationRequest) returns (SetBasecallerConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    }

    // Find the current basecaller configuration (see #set_basecaller_configuration)
    //
    // Since 3.0
    rpc get_basecaller_configuration(GetBasecallerConfigurationRequest) returns (BasecallerConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // Get the pore type configuration
    //
    // Since 3.2
    rpc get_pore_type_configuration(GetPoreTypeConfigurationRequest) returns (PoreTypeConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // Set the pore type configuration
    //
    // By default, the configuration for all wells is "not_set"
    // (global_pore_type set to "not_set")
    //
    // This rpc will result in an error if new pore types are defined during acquisition.
    // The pore type which is active on specific channel/well may be changed during acquisition.
    //
    // If an invalid PoreTypeConfiguration is supplied, an error will be returned
    // Invalid PoreTypeConfiguration include those where:
    //
    //  - No pore_type_config is set
    //  - A pore type is set to an empty string
    //  - A pore type is set to "invalid"
    //
    // If an error is returned, the pore type configuration is not updated.
    //
    // Since 3.2
    rpc set_pore_type_configuration(PoreTypeConfiguration) returns (SetPoreTypeConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    }

    // Set the writer configuration.
    //
    // Note: Calling this method overrides any previous settings stored for the writers.
    // In order to preserve settings, you should call #get_writer_configuration, mutate
    // the config, then call this method.
    //
    // Will fail with FAILED_PRECONDITION if acquisition is running.
    //
    // The default writer config is to write nothing to disk.
    //
    // Since 3.3
    rpc set_writer_configuration (WriterConfiguration) returns (SetWriterConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    }

    // Get the currently active writer configuration.
    //
    // Since 3.3
    rpc get_writer_configuration (GetWriterConfigurationRequest) returns (WriterConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // Get a map of read classifications mapped to id (used internally in analysis).
    //
    // This will change when the analysis configuration changes.
    rpc get_read_classifications (GetReadClassificationsRequest) returns (GetReadClassificationsResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    };

}

message EventDetection {
    // The window size that the tstats are calculated from
    uint32 window_size = 3;

    // The peak detection must be above this threshold at a minimum for it to be detected
    // as an event.
    double threshold = 5;

    // When analysing the tstat peaks, if the jump between one value and another is higher than
    // than 'peak_height', then it will "arm" the peak detector and move onto the next phase.
    //
    // And what goes up must come down.
    // Once it has detected a peak going up, it will also have to go down by 'peak_height'
    // in order for the peak to be classified as a found event
    double peak_height = 9;

    // Conversion factor used to convert from events to bases.
    //
    // This is used to estimate bases for various rpc feeds from minknow.
    google.protobuf.DoubleValue events_to_base_ratio = 16;

    // Whether to break events on mux changes.
    //
    // This will eliminate "mux_uncertain" events and reads. Note that this will cause starting or
    // stopping unblocking to break events as well (even though the mux does not normally change in
    // this case).
    bool break_on_mux_changes = 17;

    // Control the number of samples MinKNOW will shift mux changes back by in order to align mux changes
    // with event boundaries.
    //
    // When break on mux changes is enabled its possible that mux changes recorded from the device and
    // signal deltas caused by the config changes will not align exactly (the signal delta happen prior to the
    // mux change due to the recorded sample indicating the command is fully applied). Setting this value to > 0
    // will allow minknow to record the mux change as active up to this number of samples _before_ the device
    // recorded the change as active. Mux changes are never shifted forwards.
    //
    // A value of 0 will disable shifting of mux changes.
    uint32 max_mux_change_back_shift = 18;
}

message ReadDetectionParams {
    enum ReadDetectionMode {
        none = 0;
        transition = 1;
        lookback = 2;
        minmax = 3;
    }

    ReadDetectionMode mode = 1;
    double minimum_delta_mean = 2;
    uint32 look_back = 3;
    google.protobuf.UInt32Value break_reads_after_events = 4;
    google.protobuf.DoubleValue break_reads_after_seconds = 5;
    bool break_reads_on_mux_changes = 6;

    // The following parameters define a range of pA which a read must enter/leave in order
    // to trigger a read break.
    //
    // The defined range can either be statically defined, or track with open_pore classifications
    // (see ReadClassificationParams.open_pore_classifications)

    // The minimum level which is considered open pore (this value is relative to open_pore_default
    // or the tracked open_pore section, if tracking is being used.)
    //
    // This value must be <= 0.0 if tracking is being used.
    google.protobuf.DoubleValue open_pore_min = 7;

    // The maximum level which is considered open pore (this value is relative to open_pore_default
    // or the tracked open_pore section, if tracking is being used.)
    //
    // This value must be >= 0.0 if tracking is being used.
    google.protobuf.DoubleValue open_pore_max = 8;

    // The default value to use for open pore, either when tracking isn't being used, or when
    // open pore tracking has no value currently.
    google.protobuf.DoubleValue open_pore_default = 9;

    // Minimum number of seconds events must lie within the range of open pore in order to allow
    // a read to break.
    google.protobuf.DoubleValue open_pore_seconds_required = 10;
}

message ReadClassificationParams {
    enum Scheme {
        none = 0;
        parsed = 1;
    }

    message Parameters {
        // An execution rule has the following format:
        //
        // "pore = (median,gt,185)&(median,lt,260)&(median_sd,lt,40)"
        //
        // "median" and "median_sd" are apart of a small subset of variable values describing a read or read chunk,
        // that are exposed to execution rules. The full list of variable values and their descriptions are documented
        // here: https://minknow.git.oxfordnanolabs.local/minknow-core/analysis/reads.html
        //
        // "gt" and "lt" describe how data can be compared:
        // gt: greater than
        // lt: less than
        // eq: equal
        // ne: not equal
        //
        // Constant values like "185" or "260" can also be specified. These can be real numbers also.
        //
        // Note that variables dont always have to be on the left and const values on the right. The
        // following sub rules are also valid:
        //
        // (200,lt,median_sd)
        // (median_before,gt,median)
        // (5,lt,10)
        //
        repeated string rules_in_execution_order = 2;
    }

    Scheme scheme_module = 1;

    // This tells minknow the maximum number of means to store in memory before using a different strategy
    // to calculate medians. If the number of means goes over this size then the strategy used may
    // be less accurate, but will not use as much memory in minknow
    google.protobuf.UInt64Value max_sample_size = 2;

    // A list of classifications that are deemed interesting, and will be marked to be written out to file
    repeated string selected_classifications = 3;

    // A set of classifications whose level should be tracked as the level of open pore (fed back into
    // read detection analysis).
    //
    // Read chunks selected by this filter will be aggregated for use in read detection.
    repeated string open_pore_classifications = 6;

    // A weighting figure for the exponentially weighted moving average given to the newest data.
    // eg. 0.7 would weight new data with 0.3 and all previous data with 0.7.
    //
    // By default 0.5 is used.
    google.protobuf.DoubleValue open_pore_ewma_weight = 7;

    // Determine how to classify a whole read based on the strategy
    //
    // 'ultimate':      Chooses the last (ultimate) read chunk's classification
    // 'penultimate':   Chooses the second-to-last read chunk's clasification
    // 'modal':         Chooses the most common classification out of the all read chunks
    string classification_strategy = 4;
    Parameters parameters = 5;
}

message ChannelStates {
    message Logic {
        message Behaviour {
            // TODO: MinKNOW 5: replace int32 with bool for these options
            // these are ints but act like bools
            int32 reset_on_mux_change = 1;
            int32 reset_on_well_change = 2;

            // If the latch value is set to true, then when the criteria for this channel state
            // is active, then the latch will keep it active until the channel state is reset.
            int32 latch = 3;

            // An 'effective mux change' is any mux change apart from the one triggered
            // with the purpose of disconnecting a channel (turning a channel off). For example, if
            // a channel is in pore, and the user changes the channel configuration to 'disconnected',
            // that mux change will not be an effective mux change. Any other mux change is considered
            // an 'effective mux change'. So if a channel saturates,
            // the mux change to disconnected is an effective mux change. Similarly, a
            // change from disconnected to a pore is an effective mux change.
            //
            // Use this reset mode to make the channel state persist on non-effective mux changes.
            // For example, if a channel state is in 'multiple' and the user triggers a channel
            // configuration change to 'disconnected', the state will remain in multiple if it has
            // this option on. The multiple state will be reset at all other mux changes (i.e. effective
            // mux changes).
            int32 reset_on_effective_mux_change = 4;

            // An 'effective well change' is any well change apart from the one triggered
            // with the purpose of disconnecting a channel (turning a channel off). For example, if
            // a channel is in well_1, and the user changes the channel configuration to 'unblock_1',
            // that change will not be an effective well change. A change to disconnected is also
            // not considered an effective well change.
            //
            // Use this reset mode to make the channel state persist on non-effective well changes.
            // For example, if a channel state is in 'multiple' and the user triggers a channel
            // configuration change to 'disconnected', the state will remain in multiple if it has
            // this option on. The multiple state will be reset then when the mux is set to a different
            // setting.
            int32 reset_on_effective_well_change = 5;
        }

        // Dont really like this way of doing it, but it has to match the old way...
        message Ranges {
            message Range {
                int32 lower_pa = 1;
                int32 upper_pa = 2;
            }
            Range range = 1;
        }

        string criteria = 1;

        // Specifies the order in which channel state criteria will be evaluated; the
        // smaller the number, the earlier it will be evaluated. The first criteria to match
        // will be selected
        int32 rank = 3;

        // Note that this is a regex based pattern for describing a read classification
        // sequence. For example you can specify:
        //      "unavailableunavailable"
        // or:
        //      "(unavailable)(unavailable)"
        //
        // to recognise two consecutive read chunks classified as unavailable.
        //
        // You can also use "?" at the end of one of the classifications in the sequence
        // to indicate that it may or may not be present at that point. For example:
        //      "(pore)(transition)?(event)"
        //
        // This will match both of the sequences:
        //      pore, transition, event
        //      pore, event
        //
        // The technical documentation has more information on the range of regex patterns you can
        // apply. https://minknow.git.oxfordnanolabs.local/minknow-core/analysis/channel-states.html
        string pattern = 4;

        string classification = 5;

        // Range is [lower_pa, upper_pa)
        Ranges ranges = 6;
        Behaviour behaviour = 7;
    }

    message Style {
        google.protobuf.UInt32Value order = 1;
        string label = 2;
        string colour = 3;
    }

    message Group {
        string name = 1;
        Style style = 2;
    }

    Group group = 2;
    string description = 5;
    Logic logic = 3;
    Style style = 4;
}

message GetAnalysisConfigurationRequest {
}

message AnalysisConfiguration {
    EventDetection event_detection = 1;
    ReadDetectionParams read_detection = 2;

    ReadClassificationParams read_classification = 4;
    map<string, ChannelStates> channel_states = 7;
}

message SetAnalysisConfigurationResponse {
}


message ResetAnalysisConfigurationRequest {}
message ResetAnalysisConfigurationResponse {}

message SetAnalysisEnabledStateRequest {
    bool enable = 1 [(rpc_required) = true];
}

message SetAnalysisEnabledStateResponse {
}

message GetChannelStatesDescRequest {}
message GetChannelStatesDescResponse {
    message Style {
        // The human-readable name to display when rendering this channel state or group.
        string label = 1;
        // A sentence describing the meaning of the channel state or group.
        //
        // This can be used as a tooltip, for example.
        string description = 2;
        // The colour to use when rendering this channel state or group.
        //
        // This is a six-digit hex string describing an RGB colour (eg: "ff00ff" for purple).
        string colour = 3;
    }
    message ChannelState {
        // The numeric identifier of the state.
        //
        // This is what is reported in any other APIs that return a channel state ID.
        uint32 id = 1;
        // The internal name of the state.
        //
        // This is what is reported in any other APIs that return a channel state name.
        string name = 2;
        // How to render the channel state in a graphical user interface.
        //
        // Note that the style may be missing from some channel states (such as the ones that are
        // built in to MinKNOW).
        Style style = 3;
        // An order ranking for the channel states when they are ungrouped.
        //
        // This can be used to order the channel states after merging the groups.
        uint32 global_order = 4;
    }
    message Group {
        // The name of the group.
        string name = 1;
        // How to render the group in a graphical user interface.
        //
        // Note that the style may be missing from some groups (such as the ones that are built in
        // to MinKNOW).
        Style style = 2;
        // The channel states contained in the group.
        //
        // The groups are ordered according to the "order" attribute of the channel state style in
        // the channel states configuration.
        repeated ChannelState states = 3;
    }

    // The groups of channel states.
    //
    // The groups are ordered according to the "order" attribute of the group style in the channel
    // states configuration.
    repeated Group groups = 1;
}

message GetSummaryRequest {}
message GetSummaryResponse {
    // Whether any analysis is enabled.
    //
    // If this is false, everything else will be false as well.
    bool analysis_enabled = 1;

    // Whether basecalling is enabled.
    bool basecalling_enabled = 2;
}


// Since 3.5
message BarcodingConfiguration
{
    // The barcoding kits in use
    // One entry per kit
    // If no barcoding kits are supplied, barcoding is disabled.
    repeated string barcoding_kits = 1;

    // Whether Guppy should trim barcodes
    // If not specified, this value defaults to false (not triming barcodes)
    // If barcoding is not enabled (e.g., because no barcoding kits are specified),
    // this parameter has no effect.
    bool trim_barcodes = 2;

    // Barcode is only classified if a barcode above `min_score` is present at both ends of the basecalled read.
    bool require_barcodes_both_ends = 3;

    // Search for barcodes through the entire length of the read.
    //
    // If a barcode is found in the middle of a read the read is marked as unclassified.
    bool detect_mid_strand_barcodes = 4;

    // Minimum alignment score to consider a valid barcode.
    //
    // Maximum value is 100, defaults to 60.
    google.protobuf.FloatValue min_score = 5;

    // Minimum score to consider a valid barcode (overrides min_score for rear barcodes).
    //
    // Maximum value is 100, defaults to min_score if not specified.
    google.protobuf.FloatValue min_score_rear = 6;

    // Minimum score to consider a valid mid barcode (only valid if detect_mid_strand_barcodes is specified).
    //
    // Maximum value is 100, defaults to 60.
    google.protobuf.FloatValue min_score_mid = 7;

    // The minimum score required for the barcode mask to be detected.
    //
    // Maximum value is 100, defaults to 40. 
    google.protobuf.FloatValue min_score_mask = 8;
}

// Since 4.0
message AlignmentConfiguration
{
    // Provide an index to align reads against once basecalled.
    //
    // Any acceptable referece format to guppy can be passed here:
    //   - fasta reference file
    //   - minimap index file
    repeated string reference_files = 1;

    // Provide a bed file for use indicating areas of interest in alignment results.
    //
    // Note: alignment_index must be provided for this argument to be valid.
    string bed_file = 2;

    // Minimum coverage for guppy to accept an alignment.
    //
    // If not specified a default value is used.
    //
    // Note: this option cannot be used during live basecalling.
    google.protobuf.FloatValue minimum_coverage = 3;

    // Control how statistics for bed results are aggregated.
    //
    // If set to false only the bed hit with the highest overlap is
    // used when computing heatmap/throughput graphs with bed hits.
    //
    // If set to true each bed hit is considered and bases for all hits are counted.
    // This may give more honest representation of individual bed hit results
    // but will skew read count statistics - as each hit will be counted for every
    // bed hit.
    //
    // Note: this option has no effect in offline basecalling.
    bool aggregate_statistics_for_multiple_bed_hits = 4;
}

// Since 4.1
message LampConfiguration
{
    // Set the lamp kit being used.
    string lamp_kit = 1;

    // Optionally specify a min score to detect a valid lamp barcode.
    google.protobuf.FloatValue min_score_barcodes = 2;

    // Optionally set the minimimum valid score for a lamp mask.
    google.protobuf.FloatValue min_score_masks = 3;

    // Optionally specify a minimum score for lamp targets.
    google.protobuf.FloatValue min_score_targets = 4;
}

// Since 3.0
message BasecallerConfiguration
{
    message ReadFiltering {
        google.protobuf.DoubleValue min_qscore = 1;
        google.protobuf.UInt64Value min_samples = 2;
        google.protobuf.UInt64Value max_samples = 3;
        google.protobuf.UInt64Value min_bases = 4;
        google.protobuf.UInt64Value max_bases = 5;
        google.protobuf.UInt64Value max_failed_chunks = 6;
    }

    // Since 3.7
    message TargetFiltering {
        google.protobuf.DoubleValue min_qscore = 1;
        google.protobuf.UInt64Value min_bases = 2;
        google.protobuf.UInt64Value max_bases = 3;
    }

    // Choose if guppy is enabled or disabled.
    //
    // If set to false then no basecalling will take place, and the rest of the config is ignored.
    bool enable = 2;

    // The Guppy cfg file with all the settings.
    //
    // Filename can be absolute, or a basename (eg dna_r9.4_450bps.cfg)
    // which guppy should locate (see guppy application config entry: "data_path")
    string config_filename = 1;

    // Control how read filtering is applied to output of basecaller.
    //
    // If no filtering parameters are provided then reads will not
    // be filtered.
    ReadFiltering read_filtering = 3;

    // Control the barcoding configuration.
    // If no barcoding configuration is supplied, barcoding is disabled.
    //
    // Since 3.5
    BarcodingConfiguration barcoding_configuration = 4;

    // Control how target filtering is applied to output of basecaller.
    //
    // If no filtering parameters are provided then reads will not
    // be target-filtered.
    //
    // Since 3.7
    TargetFiltering target_filtering = 5;

    // Alignment configuration parameters.
    // If no configuration is specified alignment is disabled.
    //
    // Since 4.0
    AlignmentConfiguration alignment_configuration = 6;

    // Lamp configuration parameters.
    // If no configuration is specified lamp is disabled.
    //
    // Since 4.1
    LampConfiguration lamp_configuration = 7;
}

message SetBasecallerConfigurationRequest
{
    BasecallerConfiguration configs = 1 [(rpc_unwrap) = true];
}

message SetBasecallerConfigurationResponse{}

message GetBasecallerConfigurationRequest{}

message GetPoreTypeConfigurationRequest {}

// The pore type configuration
//
// The ways of specifying a configuration are as follows:
// - global_pore_type: all wells have a pore type of global_pore_type.
// - channel_well_pore_types: channels are allowed different values per channel/well
//   (allows a subset of channels to be set).
message PoreTypeConfiguration {
    message ChannelWell {
        // Channel number to control pore type for.
        //
        // Must be less than channel count for the current platform
        uint32 channel = 1;

        // Well to control pore type for.
        //
        // Wells outside the available wells on the flowcell are ignored.
        uint32 well = 2;
    }

    message ChannelWellPoreTypeConfigurations {
        message ChannelWellList {
            repeated ChannelWell channel_well = 1;
        }

        // Map with pore type as key, mapped to the list of wells to set for.
        //
        // It is undefined what will happen if one call sets the pore type of
        // a channel and well to two pore types.
        map<string, ChannelWellList> pore_types = 1;
    }


    oneof pore_type_config {
        // Set all channel/wells to one pore type.
        string global_pore_type = 1;

        // Set channel/wells to different pore types.
        //
        // Pore types can be created without being used by adding an empty
        // entry.
        ChannelWellPoreTypeConfigurations channel_well_pore_types = 2;
    }
}

message SetPoreTypeConfigurationResponse {}

// Configuration for the output writers for MinKNOWs
// analysis pipeline.
//
// Each writer has its own section in this message, where individual data elements
// can be enabled or disabled.
//
// File pattern attributes
// -----------------------
// Writers have a 'file_pattern' field which controls where individual files will be
// written to. The pattern is expanded for each individual read, and then the read
// placed in the required file.
// The tokens used to expand depend on the file type:
//
// Read centric files (fastq, (multi-)fast5, protobuf):
//  - read_classification:  The classification applied to the completed read (eg. strand).
//  - batch_number:         The batch number of this read, evaluated based on the destination file.
//  - read_id:              Unique read id for each read, formatted as a hash.
//  - read_number:          The read number (unique per channel, incrementing number assigned to each read by MinKNOW).
//  - channel_name:         The name of the channel which produced the read.
//  - read_start_time:      Read start time formatted in rfc3339 format.
//  - basecall_status:      Basecalling output status (derived from WriterDefaults section in analysis config).
//  - pore_type:            Type of pore (as specified by #set_pore_type_configuration).
//
// General attributes:
//  - daq_start_time:       Data acquisition start time formatted as YYYYMMDD_hhmm.
//  - protocol_start_time:  Time the current protocol was started.
//  - run_id:               Acquisition run id formatted as hash.
//  - short_run_id:         Shortened version of acquisition run id formatted as hash.
//  - protocol_run_id:      Protocol run id formatted as hash.
//  - short_protocol_run_id: Shortened protocol run id formatted as hash.
//  - asic_id:              Integer id assigned to the asic in the connected flow cell.
//  - flow_cell_id:         Flow cell integer as read from eeprom.
//  - machine_id:           Name of the machine (hostname or machine identifier depending on the sequencer type).
//  - device_id:            Name of the connected sequencing device (eg. MN12345).
//  - sample_id:            Sample id entered by the user when starting a protocol.
//  - version_string:       Version string of the running MinKNOW instance
//  - protocol_group_id:    Protocol group entered by user when starting a protocol.
//  - protocol_purpose:     Prupose of protocol (see protocol.set_protocol_purpose())
message WriterConfiguration {
    // Control the type of compression applied to the read data.
    //
    // By default the vbz compressor is used (except in the single read case).
    enum CompressionType {
        DefaultCompression = 0;
        ZlibCompression = 1;
        VbzCompression = 2;
    }

    // Used to control which channels for a specific
    // data type emit data
    message ChannelConfiguration {
        message ChannelList
        {
            // List of channel names (one based)
            // which should be enabled for writing.
            repeated int32 channels = 1;
        }

        message ChannelRanges
        {
            message ChannelRange
            {
                int32 start = 1;
                int32 end = 2;
            }
            // List of start/end paired channel numbers
            // which should be enabled for writing.
            //
            // All channels in inclusive ranges should be enabled.
            repeated ChannelRange ranges = 1;
        }

        // Control the way channels are enabled for this data type.
        oneof channels {
            bool all_channels = 1;
            ChannelList specific_channels = 2;
            ChannelRanges channel_ranges = 3;
        }
    }

    message ReadFast5Configuration {
        // Control the level of compression applied to read data.
        //
        // 0:   No compression will be applied to data.
        // 1-9: Passed to zlib compression, 1 is the fastest
        //      compression, 9 is the smallest possible output.
        int32 compression_level = 1;

        // Control the type of compression applied to the read data.
        //
        // By default the vbz compressor is used (except in the single read case).
        CompressionType compression_type = 14;

        // Raw data, stored with calibration data, and read attributes.
        //
        // Stored under /Raw/Reads_*/Signal
        ChannelConfiguration raw = 2;

        // Fastq data, stored as a string.
        //
        // Stored under /Analyses/Basecall_1D_*/BaseCalled_(template|complement)/Fastq
        ChannelConfiguration fastq = 3;

        // Trace table received from Guppy
        //
        // Stored under /Analyses/Basecall_1D_*/BaseCalled_template/Trace
        ChannelConfiguration trace_table = 11;

        // Move table received from Guppy
        //
        // Stored under /Analyses/Basecall_1D_*/BaseCalled_template/Move
        ChannelConfiguration move_table = 12;

        // Base modification probability table
        //
        // Store under /Analyses/Basecall_1D_*/BaseCalled_template/ModBaseProbs
        ChannelConfiguration modifications_table = 13;

        // Prevent reads which have successfully basecalled being written to fast5.
        bool disable_writing_passed_reads = 5;
        // Prevent reads which have failed basecalling being written to fast5.
        bool disable_writing_failed_reads = 6;
        // disable writing reads which have been force skipped by the basecaller.
        bool disable_writing_force_skipped_reads = 7;

        // The pattern used to find a fast5 files name.
        //
        // default: fast5{basecall_status}/{flow_cell_id}_{run_id}_{batch_number}.fast5
        // Where each {xxx} section is replaced with an attribute from the minknow state
        // when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 8;

        // The pattern used to find a fastq header.
        //
        // default: {read_id} runid={run_id} read={read_number} ch={channel_name} start_time={read_start_time}
        // Where each {xxx} section is replaced with an attribute from the minknow state
        // when the fastq is generated.
        string fastq_header_pattern = 9;

        // How many reads are placed in each file (after batch_count files {batch_number}
        // is increased in the filename).
        uint32 batch_count = 10;
    }

    message ReadFastqConfiguration {
        // Control if a fastq file should be generated per channel.
        ChannelConfiguration enable = 1;

        // The pattern used to find a fastq files name.
        //
        // default: fastq{basecall_status}/{flow_cell_id}_{run_id}_{batch_number}.fastq
        // Where each {xxx} section is replaced with an attribute from the minknow state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 2;

        // The pattern used to find a fastq header.
        //
        // default: {read_id} runid={run_id} read={read_number} ch={channel_name} start_time={read_start_time}
        // Where each {xxx} section is replaced with an attribute from the minknow state
        // when the fastq is generated.
        string header_pattern = 3;

        // How many files are placed in each batch (after batch_count files {batch_number} is increased in the filename).
        uint32 batch_count = 4;

        // Compress fastq files with gzip compression.
        // default: false
        bool compression = 5;
    }

    message ReadBamConfiguration {
        // Control if a BAM file should be generated per channel.
        ChannelConfiguration enable = 1;

        // The pattern used to find a BAM files name.
        //
        // default: bam{basecall_status}/{flow_cell_id}_{run_id}_{batch_number}.bam
        // Where each {xxx} section is replaced with an attribute from the minknow state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 2;

        // How many files are placed in each batch (after batch_count files {batch_number} is increased in the filename).
        uint32 batch_count = 3;
    }

    message ReadProtobufConfiguration {
        // Control if a protobuf file should be generated per channel.
        ChannelConfiguration enable = 1;

        // The pattern used to find a protobuf files name.
        //
        // default: pbread{basecall_status}/{batch_number}/{flow_cell_id}_{run_id}_ch_{channel_name}_read_{read_number}.pbread
        // Where each {xxx} section is replaced with an attribute from the minknow state
        // when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 2;

        // How many files are placed in each batch (after batch_count files {batch_number} is increased in the filename).
        uint32 batch_count = 3;
    }

    message SequencingSummaryConfiguration {
        // Should a sequencing summary file be generated
        ChannelConfiguration enable = 1;

        // The pattern used to find a summary files name.
        //
        // default: sequencing_summary_{flow_cell_id}_{short_run_id}.txt
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 2;
    }

    // Control settings for the bulk writer
    message BulkConfiguration {
        // Control the level of compression applied to read data.
        //
        // 0:   No compression will be applied to data.
        // 1-9: Passed to zlib compression, 1 is the fastest
        //      compression, 9 is the smallest possible output.
        int32 compression_level = 2;

        // Control the type of compression applied to the read data.
        //
        // By default the vbz compressor is used (except in the single read case).
        CompressionType compression_type = 13;

        // The pattern used to find a bulk files name. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: {data_set}.fast5
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 14;

        // Raw data, stored with channel calibration data
        //
        // Stored under /Raw/Channel_*/Signal
        ChannelConfiguration raw = 3;

        // Minknow event data
        //
        // Stored under /IntermediateData/Channel_*/Events
        ChannelConfiguration events = 4;

        // Minknow read data
        //
        // Stored under /IntermediateData/Channel_*/Reads
        ChannelConfiguration reads = 5;

        // Device multiplex data
        //
        // Stored under /MultiplexData/Channel_*/Multiplex
        ChannelConfiguration multiplex = 6;

        // Channel state data
        //
        // Stored under /StateData/Channel_*/States
        ChannelConfiguration channel_states = 7;

        // Device metadata (bias and temperature information)
        //
        // Stored in a per frame sequence in /Device/MetaData
        bool device_metadata = 11;

        // Device commands
        //
        // Stored with the frame commands take effect sequence in /Device/AsicCommands
        bool device_commands = 12;
    }

    // Control settings for the report writer
    message ReportConfiguration {
        // The pattern used to find the pdf report filename. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: report_{flow_cell_id}_{daq_start_time}_{short_protocol_run_id}.pdf
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string pdf_report_file_pattern = 1;

        // The pattern used to find the markdown report filename. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: report_{flow_cell_id}_{daq_start_time}_{short_protocol_run_id}.md
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string markdown_report_file_pattern = 2;

        // The pattern used to find the duty time csv report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: duty_time_{flow_cell_id}_{short_run_id}.csv
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string duty_time_report_file_pattern = 3;

        // The pattern used to find the throughput csv report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: throughput_{flow_cell_id}_{short_run_id}.csv
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string throughput_report_file_pattern = 4;

        // The pattern used to find the final summary report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: final_summary_{flow_cell_id}_{short_run_id}.txt
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string final_summary_report_file_pattern = 5;

        // The pattern used to name the barcode-alignment report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: barcode_alignment_{flow_cell_id}_{short_run_id}.tsv
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string barcode_alignment_report_file_pattern = 6;

        // The pattern used to suffix custom reports.
        //
        // default: "_{flow_cell_id}_{short_run_id}"
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // Custom reports use this to build filenames:
        //   - "custom_report{suffix}.txt"
        //
        // See file pattern attributes above.
        string custom_report_suffix_pattern = 7;
    }

    // Configuration for the fast5 writer.
    //
    // If not specified, no multi fast5 outputs are generated.
    ReadFast5Configuration read_fast5 = 2;

    // Configuration for the fastq writer.
    //
    // If not specified, no fastq outputs are generated.
    ReadFastqConfiguration read_fastq = 3;

    // Configuration for the BAM writer.
    //
    // If not specified, no BAM outputs are generated.
    ReadBamConfiguration read_bam = 8;

    // Configuration for the protobuf writer.
    //
    // If not specified, no protobuf outputs are generated.
    ReadProtobufConfiguration read_protobuf = 4;

    // Configuration for Sequencing Summary file
    //
    // If not specified, no summary file is generated.
    SequencingSummaryConfiguration sequencing_summary = 5;

    // Configuration for the bulk writer.
    //
    // If not specified, a basic bulk output is generated.
    BulkConfiguration bulk = 6;

    // Configuration for the report writer
    //
    // If acquisition.StartRequest.generate_report is set for the
    // acquisition period, and empty paths (or no report config) are supplied
    // for reports default paths are used.
    ReportConfiguration report = 7;
}

message SetWriterConfigurationResponse {
}

message GetWriterConfigurationRequest {
}

message GetReadClassificationsRequest {}

message GetReadClassificationsResponse {
    map<int32, string> read_classifications = 1;
}
