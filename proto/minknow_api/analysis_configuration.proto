syntax="proto3";

package minknow_api.analysis_configuration;

option go_package ="github.com/nanoporetech/minknow_api/go/gen/analysis_configuration";
option java_package = "com.nanoporetech.minknow_api";
option objc_class_prefix = "MKAPI";

import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";
import "minknow_api/read_end_reason.proto";
import "minknow_api/rpc_options.proto";

service AnalysisConfigurationService {
    // Get the analysis configuration
    rpc get_analysis_configuration (GetAnalysisConfigurationRequest) returns (AnalysisConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    };

    // Sets the analysis configuration
    //
    // This sets the whole configuration as-is, so you have to specify the whole analysis configuration as any fields
    // there previously will be overwritten. To preserve the current analysis configuration, use a get-modify-set
    // approach. Use get_analysis_configuration to retrieve the current config and modify the fields on that copy.
    // Then use this call to set the modified version.
    //
    // The AnalysisConfiguration message is converted to/from json in Minknow, but this will be removed from later
    // versions of MinKNOW. The basecaller params are the first ones to move away from the jsn format. The old structure
    // has been kept for backwards compatibility, but it will be removed.
    //
    // The AnalysisConfiguration message is intended to be used to convert easily from protobuf to json and back again.
    // To convert from json to a protobuf message (assuming 'analysis_conf_json' holds the json data:
    //
    // >>> import minknow_api
    // >>> from google.protobuf import json_format
    // >>>
    // >>> analysis_conf_pb = minknow_api.analysis_configuration_service.AnalysisConfiguration()
    // >>> json_format.Parse(json.dumps(analysis_conf_json), analysis_conf_pb)
    //
    // To convert from a protobuf message to json:
    //
    // >>> json_data = json_format.MessageToJson(analysis_conf_resp, preserving_proto_field_name=True, including_default_value_fields=True)
    //
    // 'preserving_proto_field_name' is needed because json_format will try convert keys to json-standard(?) format, like converting
    // my_key to myKey, and the key names as seen in the protobuf file are important to minknow
    //
    // 'including_default_value_fields' is needed because in proto3, primitive values that are default initialised (like a uint32 with value 0)
    // will not be sent on the wire, so the value wouldn't appear when converting to json. In practice, most values are wrapper types and this
    // field won't have an affect in wrapper types, but it does affect enum types as the default initialised value is the 0th enum.
    //
    // NOTE: if the analysis configuration was set using the new parameters (with the filename for basecalling config files), the old parameters
    // from jsn will be ignored. So set_analysis_configuration must be used with either the old protobuf message for the basecaller parameters,
    // or with the new one, but it cannot be used interleaved!
    rpc set_analysis_configuration (AnalysisConfiguration) returns (SetAnalysisConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    };

    // Reset the analysis configuration
    //
    // The configuration will be set to the initial default configuration that was set on boot
    //
    // Since 3.0
    rpc reset_analysis_configuration (ResetAnalysisConfigurationRequest) returns (ResetAnalysisConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    };

    // Enable or disable analysis entirely.
    rpc set_analysis_enabled_state (SetAnalysisEnabledStateRequest) returns (SetAnalysisEnabledStateResponse) {
        option idempotency_level = IDEMPOTENT;
    };

    // Get a description of the possible channel states.
    //
    // This is a subset of the information included in the channel states section of the analysis
    // configuration. It will change when the analysis configuration changes.
    rpc get_channel_states_desc (GetChannelStatesDescRequest) returns (GetChannelStatesDescResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    };

    // Get a brief summary of the analysis configuration.
    //
    // This is a high-level overview of what major parts of the analysis pipeline are enabled.
    rpc get_summary (GetSummaryRequest) returns (GetSummaryResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    };

    // Configure the basecaller which will run during acquisition.
    //
    // This rpc will result in an error if invoked during acquisition.
    //
    // By default no basecalling is performed (enable = false).
    //
    // Since 3.0
    rpc set_basecaller_configuration(SetBasecallerConfigurationRequest) returns (SetBasecallerConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    }

    // Inform MinKNOW the passed basecall configuration will be used at some point in the future, and could be loaded now
    // to reduce wait time in the future.
    //
    // This rpc will result in an error if invoked during acquisition.
    //
    // The call will block until any previous call to preload configs is complete, but does not block while the config
    // is loaded, no errors are reported to the caller if the config is invalid.
    //
    // Since 4.1
    rpc preload_basecaller_configuration(SetBasecallerConfigurationRequest) returns (SetBasecallerConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    }

    // Find the current basecaller configuration (see #set_basecaller_configuration)
    //
    // Since 3.0
    rpc get_basecaller_configuration(GetBasecallerConfigurationRequest) returns (BasecallerConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // Get the pore type configuration
    //
    // Since 3.2
    rpc get_pore_type_configuration(GetPoreTypeConfigurationRequest) returns (PoreTypeConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // Set the pore type configuration
    //
    // By default, the configuration for all wells is "not_set"
    // (global_pore_type set to "not_set")
    //
    // This rpc will result in an error if new pore types are defined during acquisition.
    // The pore type which is active on specific channel/well may be changed during acquisition.
    //
    // If an invalid PoreTypeConfiguration is supplied, an error will be returned
    // Invalid PoreTypeConfiguration include those where:
    //
    //  - No pore_type_config is set
    //  - A pore type is set to an empty string
    //  - A pore type is set to "invalid"
    //
    // If an error is returned, the pore type configuration is not updated.
    //
    // Since 3.2
    rpc set_pore_type_configuration(PoreTypeConfiguration) returns (SetPoreTypeConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    }

    // Set the writer configuration.
    //
    // Note: Calling this method overrides any previous settings stored for the writers.
    // In order to preserve settings, you should call #get_writer_configuration, mutate
    // the config, then call this method.
    //
    // Will fail with FAILED_PRECONDITION if acquisition is running.
    //
    // The default writer config is to write nothing to disk.
    //
    // Since 3.3
    rpc set_writer_configuration (WriterConfiguration) returns (SetWriterConfigurationResponse) {
        option idempotency_level = IDEMPOTENT;
    }

    // Get the currently active writer configuration.
    //
    // Since 3.3
    rpc get_writer_configuration (GetWriterConfigurationRequest) returns (WriterConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // Get a map of read classifications mapped to id (used internally in analysis).
    //
    // This will change when the analysis configuration changes.
    rpc get_read_classifications (GetReadClassificationsRequest) returns (GetReadClassificationsResponse) {
        option idempotency_level = NO_SIDE_EFFECTS;
    }

    // Get the dynamic analysis configuration - this configuration can be changed during acquisition periods,
    // and is reset at the start of acquisition.
    rpc get_dynamic_analysis_configuration (GetDynamicAnalysisConfigurationRequest) returns (DynamicAnalysisConfiguration) {
        option idempotency_level = NO_SIDE_EFFECTS;
    };

    // Set the dynamic analysis configuration, used during
    //
    // This can be changed during an acquisition period, and should be called as new values become appropriate.
    // The new analysis parameters will be used after any data already received has been processe.
    rpc set_dynamic_analysis_configuration(DynamicAnalysisConfiguration) returns (SetDynamicAnalysisConfigurationResponse) { }

    // Basecall configuration defaults
    //
    // These defaults will be based on the connected flow cell type and the selected base calling substrate.
    //
    // Since 6.3
    rpc find_basecall_configuration_defaults(FindBasecallConfigurationDefaultsRequest) returns (FindBasecallConfigurationDefaultsResponse) {
        option (experimental) = true;
    }
}

message EventDetection {
    enum DetectionType {
        MULTITTEST = 0; // Default and older style detector.
        DMEAN = 1; // New, faster detector.
    }

    DetectionType type = 19;

    // The window size that the tstats are calculated from
    uint32 window_size = 3;

    // The peak detection must be above this threshold at a minimum for it to be detected
    // as an event.
    double threshold = 5;

    // When analysing the tstat peaks, if the jump between one value and another is higher than
    // than 'peak_height', then it will "arm" the peak detector and move onto the next phase.
    //
    // And what goes up must come down.
    // Once it has detected a peak going up, it will also have to go down by 'peak_height'
    // in order for the peak to be classified as a found event
    //
    // Note: only used for MULTITTEST detector.
    double peak_height = 9;

    // Conversion factor used to convert from events to bases.
    //
    // This is used to estimate bases for various rpc feeds from minknow.
    google.protobuf.DoubleValue events_to_base_ratio = 16;

    // Whether to break events on mux changes.
    //
    // This will eliminate "mux_uncertain" events and reads. Note that this will cause starting or
    // stopping unblocking to break events as well (even though the mux does not normally change in
    // this case).
    //
    // Note: no longer used.
    bool break_on_mux_changes = 17;

    // Control the number of samples MinKNOW will shift mux changes back by in order to align mux changes
    // with event boundaries.
    //
    // When break on mux changes is enabled its possible that mux changes recorded from the device and
    // signal deltas caused by the config changes will not align exactly (the signal delta happen prior to the
    // mux change due to the recorded sample indicating the command is fully applied). Setting this value to > 0
    // will allow minknow to record the mux change as active up to this number of samples _before_ the device
    // recorded the change as active. Mux changes are never shifted forwards.
    //
    // A value of 0 will disable shifting of mux changes.
    //
    // Note: no longer used.
    uint32 max_mux_change_back_shift = 18;

    // Force minknow to detect events even when channels are disconnected
    //
    // If set to false (the default) events are not detected when channels are set outside well 1-4.
    //
    // If set to true events are always detected.
    bool force_detect_events_when_disconnected = 20;
}

message ReadDetectionParams {
    enum ReadDetectionMode {
        none = 0;
        transition = 1;
        lookback = 2;
        minmax = 3;
    }

    ReadDetectionMode mode = 1;
    double minimum_delta_mean = 2;
    uint32 look_back = 3;
    google.protobuf.UInt32Value break_reads_after_events = 4;
    google.protobuf.DoubleValue break_reads_after_seconds = 5;
    bool break_reads_on_mux_changes = 6;

    // The following parameters define a range of pA which a read must enter/leave in order
    // to trigger a read break.
    //
    // The defined range can either be statically defined, or track with open_pore classifications
    // (see ReadClassificationParams.open_pore_classifications)

    // The minimum level which is considered open pore (this value is relative to open_pore_default
    // or the tracked open_pore section, if tracking is being used.)
    //
    // This value must be <= 0.0 if tracking is being used.
    google.protobuf.DoubleValue open_pore_min = 7;

    // The maximum level which is considered open pore (this value is relative to open_pore_default
    // or the tracked open_pore section, if tracking is being used.)
    //
    // This value must be >= 0.0 if tracking is being used.
    google.protobuf.DoubleValue open_pore_max = 8;

    // The default value to use for open pore, either when tracking isn't being used, or when
    // open pore tracking has no value currently.
    google.protobuf.DoubleValue open_pore_default = 9;

    // Minimum number of seconds events must lie within the range of open pore in order to allow
    // a read to break.
    google.protobuf.DoubleValue open_pore_seconds_required = 10;
}

// Parameters for filtering out reads from being written.
//
// The tests are combined using a logical AND: if any given test fails, the read will not be
// written. Only reads that pass all (non-zero) tests will be written out.
//
// Currently, it is only possible to filter on read length. This can be given in samples or MinKNOW
// events.
message ReadFilters {
    // Only write reads that contain at least this many samples.
    //
    // The default zero value will not exclude any reads.
    uint32 read_length_min = 1;

    // Only write reads that contain at most this many samples.
    //
    // If set to zero (the default), this test is not applied (as though it had been set to a value
    // longer than any possible read).
    uint32 read_length_max = 2;

    // Only write reads that contain at least this many MinKNOW events.
    //
    // The default zero value will not exclude any reads.
    uint32 event_count_min = 3;

    // Only write reads that contain at most this many MinKNOW events.
    //
    // If set to zero (the default), this test is not applied (as though it had been set to a value
    // longer than any possible read).
    uint32 event_count_max = 4;

    // Control whether reads unblocked using from `DataService::get_live_reads()` should be filtered.
    //
    // When set to true, reads which are unblocked by `get_live_reads` are filtered and therefore not basecalled.
    // When set to false, reads that are unblocked by `get_live_reads` will not be filtered and therefore will be basecalled.
    bool skip_rejected_reads = 5;
}

message ReadClassificationParams {
    enum Scheme {
        none = 0;
        parsed = 1;
    }

    message Parameters {
        // An execution rule has the following format:
        //
        // "pore = (median,gt,185)&(median,lt,260)&(median_sd,lt,40)"
        //
        // "median" and "median_sd" are apart of a small subset of variable values describing a read or read chunk,
        // that are exposed to execution rules. The full list of variable values and their descriptions are documented
        // here: https://minknow.git.oxfordnanolabs.local/minknow-core/analysis/reads.html
        //
        // "gt" and "lt" describe how data can be compared:
        // gt: greater than
        // lt: less than
        // eq: equal
        // ne: not equal
        //
        // Constant values like "185" or "260" can also be specified. These can be real numbers also.
        //
        // Note that variables dont always have to be on the left and const values on the right. The
        // following sub rules are also valid:
        //
        // (200,lt,median_sd)
        // (median_before,gt,median)
        // (5,lt,10)
        //
        repeated string rules_in_execution_order = 2;
    }

    message MetricsEwma {
        google.protobuf.FloatValue median = 1;
        google.protobuf.FloatValue median_sd = 2;
        google.protobuf.FloatValue range = 3;
        google.protobuf.FloatValue median_dwell = 4;
        google.protobuf.FloatValue dwell_sd = 5;

        // How many read chunks are required before an ewma is calculated.
        //
        // If we don't use ewma, a straight mean of all samples so far is used instead.
        //
        // Default value is 0: Always use ewma.
        google.protobuf.Int32Value read_chunks_required_for_ewma = 6;
    }

    Scheme scheme_module = 1;

    // This tells minknow the maximum number of means to store in memory before using a different strategy
    // to calculate medians. If the number of means goes over this size then the strategy used may
    // be less accurate, but will not use as much memory in minknow
    google.protobuf.UInt64Value max_sample_size = 2;

    // A list of classifications that are deemed interesting, and will be marked to be written out to file
    repeated string selected_classifications = 3;

    // A set of classifications whose level should be tracked as the level of open pore (fed back into
    // read detection analysis).
    //
    // Read chunks selected by this filter will be aggregated for use in read detection.
    repeated string open_pore_classifications = 6;

    // A weighting figure for the exponentially weighted moving average given to the newest data.
    // eg. 0.7 would weight new data with 0.3 and all previous data with 0.7.
    //
    // By default 0.5 is used.
    google.protobuf.DoubleValue open_pore_ewma_weight = 7;

    // A number of seconds to ignore new chunks for after a reset occurs on a channel
    // this allows analysis to ignore spikes or bad data on the channel for a small section of time.
    //
    // By default 0.0 is used - and chunks are accepted immediately.
    google.protobuf.DoubleValue open_pore_ignore_after_reset_seconds = 8;

    // Determine how to classify a whole read based on the strategy
    //
    // 'ultimate':      Chooses the last (ultimate) read chunk's classification
    // 'penultimate':   Chooses the second-to-last read chunk's classification
    // 'modal':         Chooses the most common classification out of all read chunks
    // 'threshold':     Chooses a classification based on the combination of threshold parameters.
    //                  If selected, values for the "selected_classifications_fraction_required"
    //                  and "selected_chunks_required" fields will be used to determine the
    //                  read classification (see below).
    //
    string classification_strategy = 4;
    Parameters parameters = 5;

    // For the "threshold" classification strategy, specify the minimum fraction (in duration) of a completed read
    // that needs to be in any of the "selected_classifications".
    // For example, using 0 means that all reads will written out unless further constrained by the
    // "selected_classifications_chunk_required" field.
    //
    // Note that this option only applies to the 'threshold' classification strategy and will be ignored
    // for other classification strategies.
    //
    google.protobuf.DoubleValue selected_classifications_fraction_required = 9;

    // For the "threshold" classification strategy, specify the minimum number of chunks of a completed read
    // that needs to be in any of the "selected_classifications".
    // For example, using 1 means that the entire read will be written if ANY chunk has a classification in
    // "selected_classifications" unless further constrained by the "selected_classifications_fraction_required" field.
    //
    // Note that this option only applies to the 'threshold' classification strategy and will be ignored
    // for other classification strategies.
    //
    google.protobuf.UInt32Value selected_classifications_chunks_required = 10;

    // this parameter controls whether (or not)  we merge data for all selected classifications into a single
    // data point before deciding whether to output a read.
    // For instance, if 2 classifications are selected and classification A is 20% of the read, and classification B
    // is 20% of the read then:
    // When merge_selected_classifications is set to true, the overall selected classification proportion would amount
    // to 40% of the read and that value would used when deciding whether or not to output the read.
    // When merge_selected_classifications is set to false, each selected classification would be considered
    // separately at the decision stage. Defaults to false.
    // Note that when multiple classifications are selected by the user and the threshold criteria are met, then the
    // most recent classification (of all selected classifications) will be used as the read overall classification.
    //
    google.protobuf.BoolValue merge_selected_classifications = 11;

    // Limit on how long a read may be in seconds before minknow forces the selected decision and either
    // selects or vetoes the complete read.
    //
    // If unspecified a default value is used.
    google.protobuf.UInt64Value max_read_length_before_selected_decision_seconds = 12;

    // Configuration for Exponentially weighted moving averages over read metrics.
    // These values configure how sensitive the complete read metrics are to per chunk changes in value;
    // higher values in the config here cause an increase in sensitivity in the metrics to per chunk changes.
    //
    // The values provided here are biased based on the length of each chunk, so short chunks will have less
    // effect on the computed metric than longer chunks.
    //
    // A value of 1.0 will take as much of the local chunk value as possible, while values closer to zero will
    // make the computed metric slower moving.
    //
    // The default weight if unspecified is 0.1.
    MetricsEwma metrics_ewma = 13;
}

message ChannelStates {
    message Logic {
        message Behaviour {
            // TODO: MinKNOW 5: replace int32 with bool for these options
            // these are ints but act like bools
            int32 reset_on_mux_change = 1;
            int32 reset_on_well_change = 2;

            // If the latch value is set to true, then when the criteria for this channel state
            // is active, then the latch will keep it active until the channel state is reset.
            int32 latch = 3;

            // An 'effective mux change' is any mux change apart from the one triggered
            // with the purpose of disconnecting a channel (turning a channel off). For example, if
            // a channel is in pore, and the user changes the channel configuration to 'disconnected',
            // that mux change will not be an effective mux change. Any other mux change is considered
            // an 'effective mux change'. So if a channel saturates,
            // the mux change to disconnected is an effective mux change. Similarly, a
            // change from disconnected to a pore is an effective mux change.
            //
            // Use this reset mode to make the channel state persist on non-effective mux changes.
            // For example, if a channel state is in 'multiple' and the user triggers a channel
            // configuration change to 'disconnected', the state will remain in multiple if it has
            // this option on. The multiple state will be reset at all other mux changes (i.e. effective
            // mux changes).
            int32 reset_on_effective_mux_change = 4;

            // An 'effective well change' is any well change apart from the one triggered
            // with the purpose of disconnecting a channel (turning a channel off). For example, if
            // a channel is in well_1, and the user changes the channel configuration to 'unblock_1',
            // that change will not be an effective well change. A change to disconnected is also
            // not considered an effective well change.
            //
            // Use this reset mode to make the channel state persist on non-effective well changes.
            // For example, if a channel state is in 'multiple' and the user triggers a channel
            // configuration change to 'disconnected', the state will remain in multiple if it has
            // this option on. The multiple state will be reset then when the mux is set to a different
            // setting.
            int32 reset_on_effective_well_change = 5;
        }

        // Dont really like this way of doing it, but it has to match the old way...
        message Ranges {
            message Range {
                int32 lower_pa = 1;
                int32 upper_pa = 2;
            }
            Range range = 1;
        }

        string criteria = 1;

        // Specifies the order in which channel state criteria will be evaluated; the
        // smaller the number, the earlier it will be evaluated. The first criteria to match
        // will be selected
        int32 rank = 3;

        // Note that this is a regex based pattern for describing a read classification
        // sequence. For example you can specify:
        //      "unavailableunavailable"
        // or:
        //      "(unavailable)(unavailable)"
        //
        // to recognise two consecutive read chunks classified as unavailable.
        //
        // You can also use "?" at the end of one of the classifications in the sequence
        // to indicate that it may or may not be present at that point. For example:
        //      "(pore)(transition)?(event)"
        //
        // This will match both of the sequences:
        //      pore, transition, event
        //      pore, event
        //
        // The technical documentation has more information on the range of regex patterns you can
        // apply. https://minknow.git.oxfordnanolabs.local/minknow-core/analysis/channel-states.html
        string pattern = 4;

        string classification = 5;

        // Range is [lower_pa, upper_pa)
        Ranges ranges = 6;
        Behaviour behaviour = 7;
    }

    message Style {
        google.protobuf.UInt32Value order = 1;
        string label = 2;
        string colour = 3;
    }

    message Group {
        // TODO: group styling and description should not be defined here, as this
        // allows channel states to declare themselves as being part of the same group
        // but specify different styling and descriptions.

        string name = 1;
        Style style = 2;
        string description = 3;
    }

    Group group = 2;
    string description = 5;
    Logic logic = 3;
    Style style = 4;
}

message GetAnalysisConfigurationRequest {
    // The unique identifier assigned to this acquisition run.
    //
    // Since 6.2
    string run_id = 1;
}


// Since 5.3
message ReadScalingParams
{
    // Quantile Information:

    // Position of quantiles in scaling data to use when computing scale parameters.
    repeated float quantile_locations = 3;

    // If present, must be the same length as quantile_locations.
    // Represents the coefficients that shall be multiplied with measured quantiles to give a predicted_shift
    repeated float quantile_weights_shift = 1;

    // If present, must be the same length as quantile_locations.
    // Represents the coefficients that shall be multiplied with measured quantiles to give a predicted_scale
    repeated float quantile_weights_scale = 2;

    // Tracking Information:

    // Alpha value to use in ewma calculation for scale and shift tracking. 1 updates instantly. 0 does not update.
    float tracking_alpha = 4;

    // Alpha decay value to use. Higher values cause a more rapid decay in greater trust of earlier numbers.
    float alpha_number_estimates_decay = 5;

    // Maximum difference in event quantiles which will be added into trackers.
    // This is used to filter away cases where pore signal is included in the read and thus cannot be trusted.
    float quantile_maxdiff = 10;


    // Maximum fraction change between one tracked value and the next which will be trusted. Higher values are not trusted.
    float trust_limit_fraction = 6;

    // Event collection Params:

    // The minimum difference between an event and the next to include it in the subsampling
    float diff_threshold = 7;

    // After how many cumulative pA is a new event emitted in the subsampling
    float emission_threshold = 8;

    // Cumulative pA sum required to compute scaling. Any events after this sum are not considered in scaling.
    float dacs_breakpoint = 9;

    // Scale factor applied to conductance to produce a basic scale estimate, also combined with q90_q10_to_normal.
    float conductance_factor_scale = 11;

    // Scale factor applied to conductance to produce a basic shift estimate.
    float conductance_factor_shift = 12;
    float q90_q10_to_normal = 13;
}

message AnalysisConfiguration {
    EventDetection event_detection = 1;
    ReadDetectionParams read_detection = 2;

    ReadClassificationParams read_classification = 4;
    map<string, ChannelStates> channel_states = 7;

    // Add read scale tracking to the pipeline.
    // If this message is unspecified, read scaling is not enabled.
    ReadScalingParams read_scaling = 8;
}

message SetAnalysisConfigurationResponse {
}


message ResetAnalysisConfigurationRequest {}
message ResetAnalysisConfigurationResponse {}

message SetAnalysisEnabledStateRequest {
    bool enable = 1 [(rpc_required) = true];
}

message SetAnalysisEnabledStateResponse {
}

message GetChannelStatesDescRequest {}
message GetChannelStatesDescResponse {
    message Style {
        // The human-readable name to display when rendering this channel state or group.
        string label = 1;
        // A sentence describing the meaning of the channel state or group.
        //
        // This can be used as a tooltip, for example.
        string description = 2;
        // The colour to use when rendering this channel state or group.
        //
        // This is a six-digit hex string describing an RGB colour (eg: "ff00ff" for purple).
        string colour = 3;
    }
    message ChannelState {
        // The numeric identifier of the state.
        //
        // This is what is reported in any other APIs that return a channel state ID.
        uint32 id = 1;
        // The internal name of the state.
        //
        // This is what is reported in any other APIs that return a channel state name.
        string name = 2;
        // How to render the channel state in a graphical user interface.
        //
        // Note that the style may be missing from some channel states (such as the ones that are
        // built in to MinKNOW).
        Style style = 3;
        // An order ranking for the channel states when they are ungrouped.
        //
        // This can be used to order the channel states after merging the groups.
        uint32 global_order = 4;
    }
    message Group {
        // The name of the group.
        string name = 1;
        // How to render the group in a graphical user interface.
        //
        // Note that the style may be missing from some groups (such as the ones that are built in
        // to MinKNOW).
        Style style = 2;
        // The channel states contained in the group.
        //
        // The groups are ordered according to the "order" attribute of the channel state style in
        // the channel states configuration.
        repeated ChannelState states = 3;
    }

    // The groups of channel states.
    //
    // The groups are ordered according to the "order" attribute of the group style in the channel
    // states configuration.
    repeated Group groups = 1;
}

message GetSummaryRequest {}
message GetSummaryResponse {
    // Whether any analysis is enabled.
    //
    // If this is false, everything else will be false as well.
    bool analysis_enabled = 1;

    // Whether basecalling is enabled.
    bool basecalling_enabled = 2;
}


// Since 3.5
message BarcodingConfiguration
{
    // The barcoding kits in use
    // One entry per kit
    // If no barcoding kits are supplied, barcoding is disabled.
    repeated string barcoding_kits = 1;

    // Whether the basecaller should trim barcodes
    // If not specified, this value defaults to false (not trimming barcodes)
    // If barcoding is not enabled (e.g., because no barcoding kits are specified),
    // this parameter has no effect.
    bool trim_barcodes = 2;

    // Barcode is only classified if a barcode above `min_score` is present at both ends of the basecalled read.
    bool require_barcodes_both_ends = 3;


    reserved "detect_mid_strand_barcodes";
    reserved 4;
    reserved "min_score";
    reserved 5;
    reserved "min_score_rear";
    reserved 6;
    reserved "min_score_mid";
    reserved 7;
    reserved "min_score_mask";
    reserved 8;

    // If set, barcodes that aren't in barcode user data list will be ignored
    //
    // Since 5.6
    bool ignore_unspecified_barcodes = 9;

}

// Since 4.0
message AlignmentConfiguration
{
    // Provide an index to align reads against once basecalled.
    //
    // Any acceptable reference format to the basecaller can be passed here:
    //   - fasta reference file
    //   - minimap index file
    repeated string reference_files = 1;

    // Provide a bed file for use indicating areas of interest in alignment results.
    //
    // Note: alignment_index must be provided for this argument to be valid.
    string bed_file = 2;

    // Minimum coverage for the basecaller to accept an alignment.
    //
    // If not specified a default value is used.
    //
    // Note: this option cannot be used during live basecalling.
    google.protobuf.FloatValue minimum_coverage = 3;

    // Control how statistics for bed results are aggregated.
    //
    // If set to false only the bed hit with the highest overlap is
    // used when computing heatmap/throughput graphs with bed hits.
    //
    // If set to true each bed hit is considered and bases for all hits are counted.
    // This may give more honest representation of individual bed hit results
    // but will skew read count statistics - as each hit will be counted for every
    // bed hit.
    //
    // Note: this option has no effect in offline basecalling.
    bool aggregate_statistics_for_multiple_bed_hits = 4;
}

// Since 4.1
//
// DEPRECATED 6.0: Lamp support has been removed and all of these options will be ignored.
message LampConfiguration
{
    // Set the lamp kit being used.
    string lamp_kit = 1;

    // Optionally specify a min score to detect a valid lamp barcode.
    google.protobuf.FloatValue min_score_barcodes = 2;

    // Optionally set the minimimum valid score for a lamp mask.
    google.protobuf.FloatValue min_score_masks = 3;

    // Optionally specify a minimum score for lamp targets.
    google.protobuf.FloatValue min_score_targets = 4;
}

// Since 3.0
message BasecallerConfiguration
{
    message ReadFiltering {
        google.protobuf.DoubleValue min_qscore = 1;
        reserved "min_samples"; // Removed as of 6.1 as this option is no longer supported.
        reserved 2;
        reserved "max_samples"; // Removed as of 6.1 as this option is no longer supported.
        reserved 3;
        google.protobuf.UInt64Value min_bases = 4;
        google.protobuf.UInt64Value max_bases = 5;
        reserved "max_failed_chunks"; // Removed as of 6.1 as this option is no longer supported.
        reserved 6;

        // Since 5.8
        google.protobuf.DoubleValue min_duplex_qscore = 7;
    }

    // Since 3.7
    message TargetFiltering {
        google.protobuf.DoubleValue min_qscore = 1;
        google.protobuf.UInt64Value min_bases = 2;
        google.protobuf.UInt64Value max_bases = 3;
    }

    // A set of model names to run in the basecaller.
    message ModelNames {
        // Simplex model to use when basecalling.
        //
        // This field is not optional - empty values are invalid.
        string simplex_model = 1;

        // An optional list of modified bases to use, the caller is responsible
        // for ensuring these are compatible modifications.
        //
        // An empty list will lead to no modified base calling.
        repeated string modified_models = 2;

        // An optional stereo model to use for calling.
        //
        // And empty string will perform no stereo step.
        string stereo_model = 3;
    }

    // Choose if the basecaller is enabled or disabled.
    //
    // If set to false then no basecalling will take place, and the rest of the config is ignored.
    bool enable = 2;

    oneof basecall_model {
        // The basecaller cfg file with all the settings.
        //
        // Filename can be absolute, or a basename (eg dna_r9.4_450bps.cfg)
        // which the basecaller should locate (see basecaller application config entry: "data_path")
        string config_filename = 1;

        // Specify the models to run by name (see find_basecall_configurations in manager.proto)
        //
        // Model names should be taken from the `name` field of the above RPC directly.
        //
        // Since 6.3
        ModelNames model_names = 12;
    }

    // Enable or disable pass/fail filtering based on alignment.  When enabled, reads which
    // do not align to any references will be marked as "failed", and written to the folder
    // specified in MinKNOW configuration for failed reads.
    //
    // The setting applies to both regular read filtering and target filtering; if it is
    // enabled, then a read will not be marked as a target read if it does not align to a reference.
    //
    // Default setting is false, i.e. disabled.
    //
    // Since 5.4
    bool align_filter = 10;

    // Control how read filtering is applied to output of basecaller.
    // These settings determine whether a read is marked as "passed"
    // or "failed".  Reads are written to different folders based on
    // the result of this filtering.  Those folders are specified in
    // MinKNOW configuration.
    //
    // If no filtering parameters are provided then reads will not
    // be filtered.
    ReadFiltering read_filtering = 3;

    // Control the barcoding configuration.
    // If no barcoding configuration is supplied, barcoding is disabled.
    //
    // Since 3.5
    BarcodingConfiguration barcoding_configuration = 4;

    // Control how target filtering is applied to output of basecaller.
    // Reads which pass these filtering criteria will be marked as
    // "target" reads, and will be written to a separate folder; this
    // folder is specified in MinKNOW configuration.  Reads which do
    // not pass these criteria will have the regular read filtering
    // applied to them, as specified by the `read-filtering` settings
    // above.
    //
    // If no filtering parameters are provided then reads will not
    // be target-filtered.
    //
    // Since 3.7
    TargetFiltering target_filtering = 5;

    // Alignment configuration parameters.
    // If no configuration is specified alignment is disabled.
    //
    // Since 4.0
    AlignmentConfiguration alignment_configuration = 6;

    // Lamp configuration parameters.
    // If no configuration is specified lamp is disabled.
    //
    // Since 4.1
    //
    // DEPRECATED 6.0: Lamp support has been removed and this option will be ignored.
    LampConfiguration lamp_configuration = 7;

    // Enable read splitting in the basecaller.
    //
    // Since 4.5
    //
    // Note: Since 5.9 this option has no effect, the basecaller is responsible for deciding when read splitting should be enabled.
    bool enable_read_splitting = 8;

    // Override score to use for the basecaller read splitting. If not specified a default value
    // is used from the basecaller.
    //
    // Since 4.5
    //
    // Note: Since 5.9 this option has no effect, the basecaller is responsible for deciding read splitting score.
    google.protobuf.FloatValue min_score_read_splitting = 9;

    // Enable poly a tail estimation.
    //
    // Since 6.3
    bool estimate_poly_a = 11;
}

message SetBasecallerConfigurationRequest
{
    BasecallerConfiguration configs = 1 [(rpc_unwrap) = true];
}

message SetBasecallerConfigurationResponse{}

message GetBasecallerConfigurationRequest
{
    // The unique identifier assigned to this acquisition run.
    //
    // Since 6.0
    string run_id = 1;
}

message GetPoreTypeConfigurationRequest {}

// The pore type configuration
//
// The ways of specifying a configuration are as follows:
// - global_pore_type: all wells have a pore type of global_pore_type.
// - channel_well_pore_types: channels are allowed different values per channel/well
//   (allows a subset of channels to be set).
message PoreTypeConfiguration {
    message ChannelWell {
        // Channel number to control pore type for.
        //
        // Must be less than channel count for the current platform
        uint32 channel = 1;

        // Well to control pore type for.
        //
        // Wells outside the available wells on the flowcell are ignored.
        uint32 well = 2;
    }

    message ChannelWellPoreTypeConfigurations {
        message ChannelWellList {
            repeated ChannelWell channel_well = 1;
        }

        // Map with pore type as key, mapped to the list of wells to set for.
        //
        // It is undefined what will happen if one call sets the pore type of
        // a channel and well to two pore types.
        map<string, ChannelWellList> pore_types = 1;
    }


    oneof pore_type_config {
        // Set all channel/wells to one pore type.
        string global_pore_type = 1;

        // Set channel/wells to different pore types.
        //
        // Pore types can be created without being used by adding an empty
        // entry.
        ChannelWellPoreTypeConfigurations channel_well_pore_types = 2;
    }
}

message SetPoreTypeConfigurationResponse {}

// Configuration for the output writers for MinKNOWs
// analysis pipeline.
//
// Each writer has its own section in this message, where individual data elements
// can be enabled or disabled.
//
// File pattern attributes
// -----------------------
// Writers have a 'file_pattern' field which controls where individual files will be
// written to. The pattern is expanded for each individual read, and then the read
// placed in the required file.
// The tokens used to expand depend on the file type:
//
// Read centric files (fastq, (multi-)fast5, protobuf):
//  - batch_number:         The batch number of this read, evaluated based on the destination file.
//  - read_id:              Unique read id for each read, formatted as a hash.
//  - channel_name:         The name of the channel which produced the read.
//  - read_start_time:      Read start time formatted in rfc3339 format.
//  - basecall_status:      Basecalling output status (derived from WriterDefaults section in analysis config).
//  - pore_type:            Type of pore (as specified by #set_pore_type_configuration).
//
// General attributes:
//  - daq_start_time:       Data acquisition start time formatted as YYYYMMDD_hhmm.
//  - protocol_start_time:  Time the current protocol was started.
//  - run_id:               Acquisition run id formatted as hash.
//  - short_run_id:         Shortened version of acquisition run id formatted as hash.
//  - protocol_run_id:      Protocol run id formatted as hash.
//  - short_protocol_run_id: Shortened protocol run id formatted as hash.
//  - asic_id:              Integer id assigned to the asic in the connected flow cell.
//  - flow_cell_id:         Flow cell integer as read from eeprom.
//  - machine_id:           Name of the machine (hostname or machine identifier depending on the sequencer type).
//  - device_id:            Name of the connected sequencing device (eg. MN12345).
//  - sample_id:            Sample id entered by the user when starting a protocol.
//  - version_string:       Version string of the running MinKNOW instance
//  - protocol_group_id:    Protocol group entered by user when starting a protocol.
//  - protocol_purpose:     Prupose of protocol (see protocol.set_protocol_purpose())
message WriterConfiguration {
    // Control the type of compression applied to the read data.
    //
    // By default the vbz compressor is used (except in the single read case).
    enum CompressionType {
        DefaultCompression = 0;
        ZlibCompression = 1;
        VbzCompression = 2;
    }

    // Used to control which channels for a specific
    // data type emit data
    message ChannelConfiguration {
        message ChannelList
        {
            // List of channel names (one based)
            // which should be enabled for writing.
            repeated int32 channels = 1;
        }

        message ChannelRanges
        {
            message ChannelRange
            {
                int32 start = 1;
                int32 end = 2;
            }
            // List of start/end paired channel numbers
            // which should be enabled for writing.
            //
            // All channels in inclusive ranges should be enabled.
            repeated ChannelRange ranges = 1;
        }

        // Control the way channels are enabled for this data type.
        oneof channels {
            bool all_channels = 1;
            ChannelList specific_channels = 2;
            ChannelRanges channel_ranges = 3;
        }
    }

    message ReadFast5Configuration {
        // Control the level of compression applied to read data.
        //
        // 0:   No compression will be applied to data.
        // 1-9: Passed to zlib compression, 1 is the fastest
        //      compression, 9 is the smallest possible output.
        int32 compression_level = 1;

        // Control the type of compression applied to the read data.
        //
        // By default the vbz compressor is used (except in the single read case).
        CompressionType compression_type = 14;

        // Raw data, stored with calibration data, and read attributes.
        //
        // Stored under /Raw/Reads_*/Signal
        ChannelConfiguration raw = 2;

        // Fastq data, stored as a string.
        //
        // Stored under /Analyses/Basecall_1D_*/BaseCalled_(template|complement)/Fastq
        ChannelConfiguration fastq = 3;

        // Trace table received from the basecaller
        //
        // Stored under /Analyses/Basecall_1D_*/BaseCalled_template/Trace
        ChannelConfiguration trace_table = 11;

        // Move table received from the basecaller
        //
        // Stored under /Analyses/Basecall_1D_*/BaseCalled_template/Move
        ChannelConfiguration move_table = 12;

        // Base modification probability table
        //
        // Store under /Analyses/Basecall_1D_*/BaseCalled_template/ModBaseProbs
        ChannelConfiguration modifications_table = 13;

        // Prevent reads which have successfully basecalled being written to fast5.
        bool disable_writing_passed_reads = 5;
        // Prevent reads which have failed basecalling being written to fast5.
        bool disable_writing_failed_reads = 6;
        // disable writing reads which have been force skipped by the basecaller.
        bool disable_writing_force_skipped_reads = 7;

        // The pattern used to find a fast5 files name.
        //
        // default: fast5{basecall_status}/{flow_cell_id}_{run_id}_{batch_number}.fast5
        // Where each {xxx} section is replaced with an attribute from the minknow state
        // when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 8;

        // The pattern used to find a fastq header.
        //
        // default: {read_id} runid={run_id} ch={channel_name} start_time={read_start_time}
        // Where each {xxx} section is replaced with an attribute from the minknow state
        // when the fastq is generated.
        string fastq_header_pattern = 9;

        oneof batch_info {
            // How many reads are placed in each batch (after batch_count reads {batch_number}
            // is increased in the pattern).
            uint32 batch_count = 10;

            // Number of estimated bases within a batch before it rotates to a new batch
            uint64 bases_per_batch = 15;

            // Do not perform batching based on output
            // (time-based batching is still performed, if specified)
            google.protobuf.Empty no_output_based_batching = 17;
        }

        // The batch duration, for time-based batching
        //
        // If time-based batching is enabled then, in addition to completing batches when the
        // `batch_count` or `bases_per_batch` target (above) is reached, batches will also be
        // completed when:
        // - At least one read has been written to the batch, AND
        // - `batch_duration` has elapsed since the last batch was completed (or since the start
        //   of the acquisition, for the first batch)
        //
        // If this field is not set, then the default time-based batching configuration will be
        // used.  If this field is set to zero or a negative value, then time-based batching will
        // be disabled.
        //
        // Since 5.6
        google.protobuf.Duration batch_duration = 16;
    }

    message ReadFastqConfiguration {
        // Control if a fastq file should be generated per channel.
        ChannelConfiguration enable = 1;

        // The pattern used to find a fastq files name.
        //
        // default: fastq{basecall_status}/{flow_cell_id}_{run_id}_{batch_number}.fastq
        // Where each {xxx} section is replaced with an attribute from the minknow state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 2;

        // The pattern used to find a fastq header.
        //
        // default: {read_id} runid={run_id} ch={channel_name} start_time={read_start_time}
        // Where each {xxx} section is replaced with an attribute from the minknow state
        // when the fastq is generated.
        string header_pattern = 3;

        oneof batch_info {
            // How many reads are placed in each batch (after batch_count reads {batch_number}
            // is increased in the pattern).
            uint32 batch_count = 4;

            // Number of estimated bases within a batch before it rotates to a new batch
            uint64 bases_per_batch = 6;

            // Do not perform batching based on output
            // (time-based batching is still performed, if specified)
            google.protobuf.Empty no_output_based_batching = 11;
        }

        // Compress fastq files with gzip compression.
        // default: false
        bool compression = 5;

        // Since 5.8
        // Prevent reads which have successfully basecalled being written to fastq.
        bool disable_writing_passed_reads = 7;
        // Prevent reads which have failed basecalling being written to fastq.
        bool disable_writing_failed_reads = 8;
        // disable writing reads which have been force skipped by the basecaller.
        bool disable_writing_force_skipped_reads = 9;

        // The batch duration, for time-based batching
        //
        // If time-based batching is enabled then, in addition to completing batches when the
        // `batch_count` or `bases_per_batch` target (above) is reached, batches will also be
        // completed when:
        // - At least one read has been written to the batch, AND
        // - `batch_duration` has elapsed since the last batch was completed (or since the start
        //   of the acquisition, for the first batch)
        //
        // If this field is not set, then the default time-based batching configuration will be
        // used.  If this field is set to zero or a negative value, then time-based batching will
        // be disabled.
        //
        // Since 5.6
        google.protobuf.Duration batch_duration = 10;
    }

    message ReadBamConfiguration {
        // Control if a BAM file should be generated per channel.
        ChannelConfiguration enable = 1;

        // The pattern used to find a BAM files name.
        //
        // default: bam{basecall_status}/{flow_cell_id}_{run_id}_{batch_number}.bam
        // Where each {xxx} section is replaced with an attribute from the minknow state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 2;

        oneof batch_info {
            // How many reads are placed in each batch (after batch_count reads {batch_number}
            // is increased in the pattern).
            uint32 batch_count = 3;

            // Number of estimated bases within a batch before it rotates to a new batch
            uint64 bases_per_batch = 5;

            // Do not perform batching based on output
            // (time-based batching is still performed, if specified)
            google.protobuf.Empty no_output_based_batching = 10;
        }

        // If true minknow will only write the primary alignment for each read.
        bool disable_writing_multiple_alignments = 4;

        // Since 5.8
        // Prevent reads which have successfully basecalled being written to bam.
        bool disable_writing_passed_reads = 6;
        // Prevent reads which have failed basecalling being written to bam.
        bool disable_writing_failed_reads = 7;
        // disable writing reads which have been force skipped by the basecaller.
        bool disable_writing_force_skipped_reads = 8;

        // The batch duration, for time-based batching
        //
        // If time-based batching is enabled then, in addition to completing batches when the
        // `batch_count` or `bases_per_batch` target (above) is reached, batches will also be
        // completed when:
        // - At least one read has been written to the batch, AND
        // - `batch_duration` has elapsed since the last batch was completed (or since the start
        //   of the acquisition, for the first batch)
        //
        // If this field is not set, then the default time-based batching configuration will be
        // used.  If this field is set to zero or a negative value, then time-based batching will
        // be disabled.
        //
        // Since 5.6
        google.protobuf.Duration batch_duration = 9;
    }

    message ReadPod5Configuration {
        // Control if a POD5 file should be generated per channel.
        ChannelConfiguration enable = 1;

        // The pattern used to find a POD5 files name.
        //
        // default: pod5{basecall_status}/{flow_cell_id}_{run_id}_{batch_number}.pod5
        // Where each {xxx} section is replaced with an attribute from the minknow state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 2;

        oneof batch_info {
            // How many reads are placed in each batch (after batch_count reads {batch_number}
            // is increased in the pattern).
            uint32 batch_count = 3;

            // Number of estimated bases within a batch before it rotates to a new batch
            uint64 bases_per_batch = 7;

            // Do not perform batching based on output
            // (time-based batching is still performed, if specified)
            google.protobuf.Empty no_output_based_batching = 9;
        }

        // Prevent reads which have successfully basecalled being written to pod5.
        bool disable_writing_passed_reads = 4;
        // Prevent reads which have failed basecalling being written to pod5.
        bool disable_writing_failed_reads = 5;
        // disable writing reads which have been force skipped by the basecaller.
        bool disable_writing_force_skipped_reads = 6;

        // The batch duration, for time-based batching
        //
        // If time-based batching is enabled then, in addition to completing batches when the
        // `batch_count` or `bases_per_batch` target (above) is reached, batches will also be
        // completed when:
        // - At least one read has been written to the batch, AND
        // - `batch_duration` has elapsed since the last batch was completed (or since the start
        //   of the acquisition, for the first batch)
        //
        // If this field is not set, then the default time-based batching configuration will be
        // used.  If this field is set to zero or a negative value, then time-based batching will
        // be disabled.
        //
        // Since 5.6
        google.protobuf.Duration batch_duration = 8;
    }

    message SequencingSummaryConfiguration {
        // Should a sequencing summary file be generated
        ChannelConfiguration enable = 1;

        // The pattern used to find a summary files name.
        //
        // default: sequencing_summary_{flow_cell_id}_{short_run_id}.txt
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 2;
    }

    // Control settings for the bulk writer
    message BulkConfiguration {
        // Control the level of compression applied to read data.
        //
        // 0:   No compression will be applied to data.
        // 1-9: Passed to zlib compression, 1 is the fastest
        //      compression, 9 is the smallest possible output.
        int32 compression_level = 2;

        // Control the type of compression applied to the read data.
        //
        // By default the vbz compressor is used (except in the single read case).
        CompressionType compression_type = 13;

        // The pattern used to find a bulk files name. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: {data_set}.fast5
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string file_pattern = 14;

        // Raw data, stored with channel calibration data
        //
        // Stored under /Raw/Channel_*/Signal
        ChannelConfiguration raw = 3;

        // Minknow event data
        //
        // Stored under /IntermediateData/Channel_*/Events
        ChannelConfiguration events = 4;

        // Minknow read data
        //
        // Stored under /IntermediateData/Channel_*/Reads
        ChannelConfiguration reads = 5;

        // Device multiplex data
        //
        // Stored under /MultiplexData/Channel_*/Multiplex
        ChannelConfiguration multiplex = 6;

        // Channel state data
        //
        // Stored under /StateData/Channel_*/States
        ChannelConfiguration channel_states = 7;

        // Device metadata (bias and temperature information)
        //
        // Stored in a per frame sequence in /Device/MetaData
        bool device_metadata = 11;

        // Device commands
        //
        // Stored with the frame commands take effect sequence in /Device/AsicCommands
        bool device_commands = 12;

        // Dynamic analysis configuration
        //
        // Stored with the frame config took effect in /Meta/User/DynamicAnalysisConfiguration
        bool dynamic_analysis_config = 15;
    }

    // Control settings for the report writer
    message ReportConfiguration {
        // DEPRECATED 6.0: As of 5.1 a pdf report is not generated at all. This field will
        // be removed in 6.0
        //
        // The pattern used to find the pdf report filename. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: report_{flow_cell_id}_{daq_start_time}_{short_protocol_run_id}.pdf
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string pdf_report_file_pattern = 1;

        // The pattern used to find the json report filename. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: report_{flow_cell_id}_{daq_start_time}_{short_protocol_run_id}.json
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string json_report_file_pattern = 2;

        // The pattern used to find the html report filename. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: report_{flow_cell_id}_{daq_start_time}_{short_protocol_run_id}.html
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string html_report_file_pattern = 9;

        // The pattern used to find the markdown report filename. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: report_{flow_cell_id}_{daq_start_time}_{short_protocol_run_id}.md
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string markdown_report_file_pattern = 8;

        // The pattern used to find the duty time csv report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: duty_time_{flow_cell_id}_{short_run_id}.csv
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string duty_time_report_file_pattern = 3;

        // The pattern used to find the throughput csv report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: throughput_{flow_cell_id}_{short_run_id}.csv
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string throughput_report_file_pattern = 4;

        // The pattern used to find the final summary report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: final_summary_{flow_cell_id}_{short_run_id}.txt
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string final_summary_report_file_pattern = 5;

        // The pattern used to name the barcode-alignment report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: barcode_alignment_{flow_cell_id}_{short_run_id}.tsv
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string barcode_alignment_report_file_pattern = 6;

        // The pattern used to name the sample sheet report. If left empty but output is
        // enabled a default pattern is used.
        //
        // default: sample_sheet_{flow_cell_id}_{daq_start_time}_{short_protocol_run_id}.csv
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // See file pattern attributes above.
        string sample_sheet_report_file_pattern = 10;

        // The pattern used to suffix custom reports.
        //
        // default: "_{flow_cell_id}_{short_run_id}"
        // Where each {xxx} section is replaced with an attribute from the minknow
        // state when the file is written.
        //
        // Custom reports use this to build filenames:
        //   - "custom_report{suffix}.txt"
        //
        // See file pattern attributes above.
        string custom_report_suffix_pattern = 7;
    }

    // Configuration for the fast5 writer.
    //
    // If not specified, no multi fast5 outputs are generated.
    ReadFast5Configuration read_fast5 = 2;

    // Configuration for the fastq writer.
    //
    // If not specified, no fastq outputs are generated.
    ReadFastqConfiguration read_fastq = 3;

    // Configuration for the BAM writer.
    //
    // If not specified, no BAM outputs are generated.
    ReadBamConfiguration read_bam = 8;

    // Configuration for the POD5 writer.
    //
    // If not specified no POD5 outputs are generated.
    ReadPod5Configuration read_pod5 = 10;

    // Configuration for Sequencing Summary file
    //
    // If not specified, no summary file is generated.
    SequencingSummaryConfiguration sequencing_summary = 5;

    // Configuration for the bulk writer.
    //
    // If not specified, a basic bulk output is generated.
    BulkConfiguration bulk = 6;

    // Configuration for the report writer
    //
    // If acquisition.StartRequest.generate_report is set for the
    // acquisition period, and empty paths (or no report config) are supplied
    // for reports default paths are used.
    ReportConfiguration report = 7;

    // Parameters for filtering reads for writing.  If not present, then
    // no filtering will be applied, so no reads will be excluded.
    ReadFilters read_filters = 9;
}

message SetWriterConfigurationResponse {
}

message GetWriterConfigurationRequest
{
    // The unique identifier assigned to this acquisition run.
    //
    // Since 6.0
    string run_id = 1;
}

message GetReadClassificationsRequest {}

message GetReadClassificationsResponse {
    map<int32, string> read_classifications = 1;
}

message DynamicAnalysisConfiguration {

    message ReadScaleTracking {
        // Set the voltage the most recent conductance scan occurred at.
        float conductance_scan_voltage = 1;

        message ChannelConductance {
            // Per well conductance values.
            repeated float well_conductance = 1;
        }

        // Per channel/well conductance values
        repeated ChannelConductance channel_conductance = 2;
    }

    // Parameters for read scale tracking:
    ReadScaleTracking read_scale_tracking = 1;

    // Force MinKNOW to not write or basecall all data from the live
    // sequencing stream.
    //
    // This may be useful if there is a section of data that is not
    // wanted in the final output files and reports.
    bool force_veto_all_reads = 2;

    // Force MinKNOW to not write or basecall data with specific end reasons.
    //
    // This may be useful if there is a section of data that is not
    // wanted in the final output files and reports.
    repeated read_end_reason.ReadEndReason force_veto_end_reasons = 3;
}

message GetDynamicAnalysisConfigurationRequest {}
message SetDynamicAnalysisConfigurationResponse {}

message FindBasecallConfigurationDefaultsRequest {
}

message FindBasecallConfigurationDefaultsResponse {
    // The default variant to be used.
    //
    // This can be used to search the results of manager.find_basecall_configurations
    // for a simplex model with a matching variant.
    string default_variant = 1;
}
